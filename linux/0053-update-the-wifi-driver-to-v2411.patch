From 686749e042b02b031c3243b94612f23921e56f05 Mon Sep 17 00:00:00 2001
From: Mk16kawai <1041324852hzq@sina.com>
Date: Fri, 11 Apr 2025 09:34:26 +0800
Subject: [PATCH] update the wifi driver to v2411

---
 drivers/net/wireless/aic8800/Makefile         |    63 +-
 drivers/net/wireless/aic8800/Makefile.bak     |    71 +
 .../wireless/aic8800/aic8800_fdrv/Makefile    |    92 +-
 .../aic8800/aic8800_fdrv/aic_priv_cmd.c       |  1694 +++
 .../aic8800/aic8800_fdrv/aic_priv_cmd.h       |    33 +
 .../aic8800/aic8800_fdrv/aic_vendor.c         |   166 +-
 .../aic8800_fdrv/aicwf_compat_8800d80.c       |    38 +-
 .../aic8800_fdrv/aicwf_compat_8800d80.h       |     3 +
 .../aic8800_fdrv/aicwf_compat_8800d80x2.c     |    97 +
 .../aic8800_fdrv/aicwf_compat_8800d80x2.h     |     9 +
 .../aic8800_fdrv/aicwf_compat_8800dc.c        |   949 +-
 .../aic8800_fdrv/aicwf_compat_8800dc.h        |    19 +-
 .../aic8800/aic8800_fdrv/aicwf_debug.h        |   104 +-
 .../aic8800/aic8800_fdrv/aicwf_rx_prealloc.h  |    54 +-
 .../aic8800/aic8800_fdrv/aicwf_sdio.c         |     5 +-
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.c      |    11 +-
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.h      |    19 -
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |   467 +-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.h       |    36 +-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c |   600 +-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |    31 +-
 .../aic8800/aic8800_fdrv/aicwf_wext_linux.c   |    28 +-
 .../wireless/aic8800/aic8800_fdrv/lmac_mac.h  |     1 +
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |   191 +-
 .../aic8800/aic8800_fdrv/lmac_types.h         |   124 +-
 .../aic8800/aic8800_fdrv/reg_access.h         |     2 +-
 .../net/wireless/aic8800/aic8800_fdrv/regdb.c |     1 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |    56 +-
 .../aic8800/aic8800_fdrv/rwnx_compat.h        |     5 +
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       |   159 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |   814 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c | 11236 ++++++----------
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.h |    14 -
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |   179 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |   204 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        |   578 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |     9 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |  1001 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |    11 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |   842 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.h   |    10 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   |   100 +-
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |     2 +-
 .../aic8800/aic8800_fdrv/rwnx_wakelock.c      |    92 +
 .../aic8800/aic8800_fdrv/rwnx_wakelock.h      |    21 +
 .../net/wireless/aic8800/aic_load_fw/Makefile |    19 +-
 .../aic8800/aic_load_fw/aic_bluetooth_main.c  |   162 +-
 .../aic8800/aic_load_fw/aic_compat_8800d80.c  |   121 +-
 .../aic8800/aic_load_fw/aic_compat_8800d80.h  |    11 +
 .../aic_load_fw/aic_compat_8800d80x2.c        |   688 +
 .../aic_load_fw/aic_compat_8800d80x2.h        |    45 +
 .../aic8800/aic_load_fw/aicbluetooth.c        |  2675 ++--
 .../aic8800/aic_load_fw/aicbluetooth.h        |    72 +-
 .../aic8800/aic_load_fw/aicbluetooth_cmds.h   |     7 +
 .../aic8800/aic_load_fw/aicwf_rx_prealloc.c   |     9 +-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.c  |    95 +-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.h  |    19 +-
 .../aic8800/aic_load_fw/rwnx_version_gen.h    |     2 +-
 58 files changed, 14291 insertions(+), 9875 deletions(-)
 create mode 100644 drivers/net/wireless/aic8800/Makefile.bak
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
 create mode 100644 drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c
 create mode 100644 drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h

diff --git a/drivers/net/wireless/aic8800/Makefile b/drivers/net/wireless/aic8800/Makefile
index 3d06d677a..509f64291 100644
--- a/drivers/net/wireless/aic8800/Makefile
+++ b/drivers/net/wireless/aic8800/Makefile
@@ -1,54 +1,63 @@
 CONFIG_AIC_LOADFW_SUPPORT := m
 CONFIG_AIC8800_WLAN_SUPPORT := m
 
-
 obj-$(CONFIG_AIC_LOADFW_SUPPORT)    += aic_load_fw/
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) += aic8800_fdrv/
 
+########## config option ##########
+export CONFIG_USE_FW_REQUEST = n
+export CONFIG_PREALLOC_RX_SKB = y
+export CONFIG_PREALLOC_TXQ = y
+###################################
 
-# Platform support list
-CONFIG_PLATFORM_ROCKCHIP ?= n
-CONFIG_PLATFORM_ALLWINNER ?= n
-CONFIG_PLATFORM_AMLOGIC ?= n
-CONFIG_PLATFORM_UBUNTU ?= y
+########## platform support list ##########
+export CONFIG_PLATFORM_ROCKCHIP = n
+export CONFIG_PLATFORM_ALLWINNER = n
+export CONFIG_PLATFORM_AMLOGIC = n
+export CONFIG_PLATFORM_HI = n
+export CONFIG_PLATFORM_UBUNTU = y
 
 ifeq ($(CONFIG_PLATFORM_ROCKCHIP), y)
-#KDIR := /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-KDIR  := /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
-ARCH ?= arm
-CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
-#KDIR  := /home/yaya/E/Rockchip/3399/rk3399-android-10/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3399/rk3399-android-10/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+ARCH = arm64
+KDIR = /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
+CROSS_COMPILE = /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 endif
 
 ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
-KDIR  := /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/kernel/linux-4.9
-ARCH ?= arm64
-CROSS_COMPILE ?= /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/out/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+KDIR  = /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/kernel/linux-4.9
+ARCH = arm64
+CROSS_COMPILE = /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/out/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 endif
 
 ifeq ($(CONFIG_PLATFORM_AMLOGIC), y)
 ccflags-y += -DANDROID_PLATFORM
-ARCH := arm
-CROSS_COMPILE := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
-KDIR := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+ARCH = arm
+CROSS_COMPILE = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+endif
 
+ifeq ($(CONFIG_PLATFORM_HI), y)
+ccflags-y += -DANDROID_PLATFORM
+ARCH = arm
+CROSS_COMPILE = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
 endif
 
 ifeq ($(CONFIG_PLATFORM_UBUNTU), y)
-KDIR  := /lib/modules/$(shell uname -r)/build
-PWD   := $(shell pwd)
-KVER := $(shell uname -r)
-MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH ?= x86_64
+KDIR  = /lib/modules/$(shell uname -r)/build
+PWD   = $(shell pwd)
+KVER = $(shell uname -r)
+MODDESTDIR = /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE ?=
 endif
 
+###########################################
+
+MAKEFLAGS +=-j$(shell nproc)
 
 all: modules
 modules:
@@ -68,4 +77,4 @@ uninstall:
 clean:
 	cd aic_load_fw/;make clean;cd ..
 	cd aic8800_fdrv/;make clean;cd ..
-	rm -rf modules.order Module.symvers .tmp_versions/
+	rm -rf modules.order Module.symvers .modules.order.cmd .Module.symvers.cmd .tmp_versions/
diff --git a/drivers/net/wireless/aic8800/Makefile.bak b/drivers/net/wireless/aic8800/Makefile.bak
new file mode 100644
index 000000000..3d06d677a
--- /dev/null
+++ b/drivers/net/wireless/aic8800/Makefile.bak
@@ -0,0 +1,71 @@
+CONFIG_AIC_LOADFW_SUPPORT := m
+CONFIG_AIC8800_WLAN_SUPPORT := m
+
+
+obj-$(CONFIG_AIC_LOADFW_SUPPORT)    += aic_load_fw/
+obj-$(CONFIG_AIC8800_WLAN_SUPPORT) += aic8800_fdrv/
+
+
+# Platform support list
+CONFIG_PLATFORM_ROCKCHIP ?= n
+CONFIG_PLATFORM_ALLWINNER ?= n
+CONFIG_PLATFORM_AMLOGIC ?= n
+CONFIG_PLATFORM_UBUNTU ?= y
+
+ifeq ($(CONFIG_PLATFORM_ROCKCHIP), y)
+#KDIR := /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
+#ARCH ?= arm
+#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
+KDIR  := /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
+ARCH ?= arm
+CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
+#KDIR  := /home/yaya/E/Rockchip/3399/rk3399-android-10/kernel
+#ARCH ?= arm64
+#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3399/rk3399-android-10/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+ccflags-y += -DANDROID_PLATFORM
+endif
+
+ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
+KDIR  := /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/kernel/linux-4.9
+ARCH ?= arm64
+CROSS_COMPILE ?= /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/out/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+ccflags-y += -DANDROID_PLATFORM
+endif
+
+ifeq ($(CONFIG_PLATFORM_AMLOGIC), y)
+ccflags-y += -DANDROID_PLATFORM
+ARCH := arm
+CROSS_COMPILE := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+
+endif
+
+ifeq ($(CONFIG_PLATFORM_UBUNTU), y)
+KDIR  := /lib/modules/$(shell uname -r)/build
+PWD   := $(shell pwd)
+KVER := $(shell uname -r)
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
+ARCH ?= x86_64
+CROSS_COMPILE ?=
+endif
+
+
+all: modules
+modules:
+	make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+
+install:
+	mkdir -p $(MODDESTDIR)
+	install -p -m 644 aic_load_fw/aic_load_fw.ko  $(MODDESTDIR)/
+	install -p -m 644 aic8800_fdrv/aic8800_fdrv.ko  $(MODDESTDIR)/
+	/sbin/depmod -a ${KVER}
+
+uninstall:
+	rm -rfv $(MODDESTDIR)/aic_load_fw.ko
+	rm -rfv $(MODDESTDIR)/aic8800_fdrv.ko
+	/sbin/depmod -a ${KVER}
+
+clean:
+	cd aic_load_fw/;make clean;cd ..
+	cd aic8800_fdrv/;make clean;cd ..
+	rm -rf modules.order Module.symvers .tmp_versions/
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 17b64f397..d0970cbd3 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -30,7 +30,7 @@ CONFIG_RWNX_FHOST ?= n
 #
 # DEBUG OPTIONS
 CONFIG_RWNX_UM_HELPER_DFLT ?= "/dini/dini_bin/rwnx_umh.sh"
-CONFIG_AIC_FW_PATH = "/usr/lib/firmware"
+CONFIG_AIC_FW_PATH = "/vendor/etc/firmware"
 export CONFIG_AIC_FW_PATH
 
 #
@@ -59,17 +59,17 @@ CONFIG_RWNX_BFMER ?= n
 
 CONFIG_SDIO_SUPPORT =n
 CONFIG_USB_SUPPORT =y
-CONFIG_RX_REORDER ?=y
+CONFIG_RX_REORDER =y
 CONFIG_ARP_OFFLOAD =y
-CONFIG_USE_5G ?= y
+CONFIG_USE_5G = y
 CONFIG_RADAR_OR_IR_DETECT =n
 CONFIG_DOWNLOAD_FW =n
 CONFIG_RFTEST=y
 CONFIG_USB_BT=y
 CONFIG_MAC_RANDOM_IF_NO_MAC_IN_EFUSE = y
-CONFIG_WPA3_FOR_OLD_KERNEL ?= n
-CONFIG_HE_FOR_OLD_KERNEL ?= n
-CONFIG_VHT_FOR_OLD_KERNEL ?= n
+CONFIG_WPA3_FOR_OLD_KERNEL = n
+CONFIG_HE_FOR_OLD_KERNEL = n
+CONFIG_VHT_FOR_OLD_KERNEL = n
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
 CONFIG_ALIGN_8BYTES = y
@@ -81,6 +81,7 @@ CONFIG_RX_NETIF_RECV_SKB = y
 CONFIG_BR_SUPPORT = n
 CONFIG_USB_MSG_OUT_EP = y
 CONFIG_USB_MSG_IN_EP = y
+CONFIG_USB_RX_REASSEMBLE = n
 
 #DCDW support tx aggr, D80 support both
 CONFIG_USB_RX_AGGR = n
@@ -99,18 +100,34 @@ CONFIG_FWLOG_EN = n
 CONFIG_FOR_IPCAM = n
 CONFIG_5M10M = n
 # Need to set fw path in BOARD_KERNEL_CMDLINE
-CONFIG_USE_FW_REQUEST = n
+CONFIG_USE_FW_REQUEST ?= n
 CONFIG_USE_P2P0 = n
 CONFIG_ONE_TXQ = n
 CONFIG_PER_STA_FC = n
-CONFIG_PREALLOC_RX_SKB = n
-CONFIG_PREALLOC_TXQ = y
-CONFIG_USE_WIRELESS_EXT = n
+CONFIG_PREALLOC_RX_SKB ?= n
+CONFIG_PREALLOC_TXQ ?= y
+CONFIG_USE_WIRELESS_EXT = y
 CONFIG_DPD = y
 CONFIG_FORCE_DPD_CALIB = y
+CONFIG_LOFT_CALIB = n
 CONFIG_GKI = n
 CONFIG_SCHED_SCAN = n
 CONFIG_TEMP_COMP = n
+CONFIG_POWER_LIMIT = n
+CONFIG_EXT_FEM_8800DCDW = n
+# CONFIG_MCC = n for sta and p2p concurrent in same channel.
+CONFIG_MCC = y
+CONFIG_LOAD_BT_PATCH_IN_FDRV = n
+
+ifneq ($(CONFIG_WIRELESS_EXT), y)
+CONFIG_USE_WIRELESS_EXT = n
+endif
+
+ifeq ($(CONFIG_EXT_FEM_8800DCDW), y)
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
+CONFIG_LOFT_CALIB = y
+endif
 
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
@@ -130,15 +147,16 @@ CONFIG_RWNX_MON_DATA =n
 CONFIG_RWNX_MON_XMIT ?= n
 CONFIG_RWNX_MON_RXFILTER ?= n
 
-CONFIG_FILTER_TCP_ACK =n
+CONFIG_FILTER_TCP_ACK =y
 
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
-CONFIG_RWNX_DBG ?= n
+CONFIG_RWNX_DBG ?= y
 BR_NAME = br0
 
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) := $(MODULE_NAME).o
 $(MODULE_NAME)-y := \
+    rwnx_wakelock.o        \
 	rwnx_msg_tx.o          \
 	rwnx_msg_rx.o          \
 	rwnx_utils.o           \
@@ -161,8 +179,10 @@ $(MODULE_NAME)-y := \
 	regdb.o                \
 	md5.o                  \
 	aic_vendor.o           \
+        aic_priv_cmd.o         \
 	aicwf_compat_8800dc.o  \
-	aicwf_compat_8800d80.o
+	aicwf_compat_8800d80.o \
+	aicwf_compat_8800d80x2.o
 
 $(MODULE_NAME)-$(CONFIG_BR_SUPPORT)       += aic_br_ext.o
 $(MODULE_NAME)-$(CONFIG_RWNX_RADAR)       += rwnx_radar.o
@@ -229,7 +249,8 @@ ccflags-$(CONFIG_RWNX_DBG) += -DCONFIG_RWNX_DBG
 ccflags-$(CONFIG_RWNX_SW_PROFILING) += -DCONFIG_RWNX_SW_PROFILING
 ccflags-$(CONFIG_RWNX_MUMIMO_TX) += -DCONFIG_RWNX_MUMIMO_TX
 ccflags-$(CONFIG_RFTEST) += -DCONFIG_RFTEST
-
+ccflags-$(CONFIG_MCC) += -DCONFIG_MCC
+ccflags-$(CONFIG_LOAD_BT_PATCH_IN_FDRV) += -DCONFIG_LOAD_BT_PATCH_IN_FDRV
 
 ifeq ($(CONFIG_SDIO_SUPPORT), y)
 ccflags-y += -DAICWF_SDIO_SUPPORT
@@ -275,6 +296,7 @@ ccflags-y += -DDEFAULT_COUNTRY_CODE=""\$(CONFIG_COUNTRY_CODE)"\"
 ccflags-$(CONFIG_RX_NETIF_RECV_SKB) += -DCONFIG_RX_NETIF_RECV_SKB
 ccflags-$(CONFIG_USB_MSG_OUT_EP) += -DCONFIG_USB_MSG_OUT_EP
 ccflags-$(CONFIG_USB_MSG_IN_EP) += -DCONFIG_USB_MSG_IN_EP
+ccflags-$(CONFIG_USB_RX_REASSEMBLE) += -DCONFIG_USB_RX_REASSEMBLE
 ccflags-$(CONFIG_USB_RX_AGGR)  += -DCONFIG_USB_RX_AGGR
 ccflags-$(CONFIG_USB_TX_AGGR) += -DCONFIG_USB_TX_AGGR
 ccflags-$(CONFIG_USB_NO_TRANS_DMA_MAP) += -DCONFIG_USB_NO_TRANS_DMA_MAP
@@ -287,7 +309,7 @@ ccflags-$(CONFIG_STA_SCAN_WHEN_P2P_WORKING) += -DCONFIG_STA_SCAN_WHEN_P2P_WORKIN
 ccflags-$(CONFIG_SUPPORT_REALTIME_CHANGE_MAC) += -DCONFIG_SUPPORT_REALTIME_CHANGE_MAC
 ccflags-$(CONFIG_SET_VENDOR_EXTENSION_IE) += -DCONFIG_SET_VENDOR_EXTENSION_IE
 ccflags-$(CONFIG_FWLOG_EN) += -DCONFIG_FWLOG_EN
-ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM -DCONFIG_ONE_TXQ
 ccflags-$(CONFIG_5M10M) += -DCONFIG_5M10M
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
 ccflags-$(CONFIG_USE_P2P0) += -DCONFIG_USE_P2P0
@@ -298,42 +320,26 @@ ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
 ccflags-$(CONFIG_USE_WIRELESS_EXT) += -DCONFIG_USE_WIRELESS_EXT
 ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
 ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
+ccflags-$(CONFIG_LOFT_CALIB) += -DCONFIG_LOFT_CALIB
 ccflags-$(CONFIG_GKI) += -DCONFIG_GKI
 ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
 ccflags-$(CONFIG_FILTER_TCP_ACK) += -DCONFIG_FILTER_TCP_ACK
 ccflags-$(CONFIG_TEMP_COMP) += -DCONFIG_TEMP_COMP
+ccflags-$(CONFIG_POWER_LIMIT) += -DCONFIG_POWER_LIMIT
+ccflags-$(CONFIG_EXT_FEM_8800DCDW) += -DCONFIG_EXT_FEM_8800DCDW
+MAKEFLAGS +=-j$(shell nproc)
 
 # Platform support list
 CONFIG_PLATFORM_ROCKCHIP ?= n
 CONFIG_PLATFORM_ALLWINNER ?= n
 CONFIG_PLATFORM_AMLOGIC ?= n
+CONFIG_PLATFORM_HI ?= n
 CONFIG_PLATFORM_UBUNTU ?= y
 
 ifeq ($(CONFIG_PLATFORM_ROCKCHIP), y)
-#KDIR ?= /home/yaya/E/Rockchip/3288/Android5/kernel/
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR  ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
+ARCH := arm64
 KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
-ARCH ?= arm64
-CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#ARCH ?= arm
-#CROSS_COMPILE ?=/home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR ?=/home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/kernel
-#KDIR := /home/yaya/E/Rockchip/3566/Android/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#KDIR ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#KDIR ?= /home/yaya/D/samba1/aiden/SDK/Rockchip/3588/Android12/RK3588_Android12.0/kernel-5.10
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/D/samba1/aiden/SDK/Rockchip/3588/Android12/RK3588_Android12.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+CROSS_COMPILE := /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 ccflags-y += -DCONFIG_PLATFORM_ROCKCHIP
 endif
@@ -350,7 +356,14 @@ ccflags-y += -DANDROID_PLATFORM
 ARCH ?= arm
 CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
 KDIR ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+endif
 
+ifeq ($(CONFIG_PLATFORM_HI), y)
+ccflags-y += -DANDROID_PLATFORM
+ccflags-y += -DCONFIG_PLATFORM_HI
+ARCH ?= arm
+CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
 endif
 
 ifeq ($(CONFIG_PLATFORM_UBUNTU), y)
@@ -359,7 +372,8 @@ KDIR  ?= /lib/modules/$(shell uname -r)/build
 PWD   ?= $(shell pwd)
 KVER ?= $(shell uname -r)
 MODDESTDIR ?= /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH ?= x86_64
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE ?=
 endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
new file mode 100644
index 000000000..0f123e83e
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
@@ -0,0 +1,1694 @@
+/**
+ ******************************************************************************
+ *
+ * @file aic_priv_cmd.c
+ *
+ * @brief Entry point of the AIC driver
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ctype.h>
+#include "rwnx_defs.h"
+#include "rwnx_msg_tx.h"
+#include "rwnx_debugfs.h"
+#include "rwnx_main.h"
+#include "aic_priv_cmd.h"
+#include "aicwf_compat_8800dc.h"
+#include "aicwf_compat_8800d80.h"
+#include "aicwf_compat_8800d80x2.h"
+
+extern void set_testmode(int);
+extern int testmode;
+static void print_help(const char *cmd);
+struct dbg_rftest_cmd_cfm cfm = {{0,}};
+
+#ifdef CONFIG_RFTEST
+enum {
+	SET_TX,
+	SET_TXSTOP,
+	SET_TXTONE,
+	SET_RX,
+	GET_RX_RESULT,
+	SET_RXSTOP,
+	SET_RX_METER,
+	SET_POWER,
+	SET_XTAL_CAP,
+	SET_XTAL_CAP_FINE,
+	GET_EFUSE_BLOCK,
+	SET_FREQ_CAL,
+	SET_FREQ_CAL_FINE,
+	GET_FREQ_CAL,
+	SET_MAC_ADDR,
+	GET_MAC_ADDR,
+	SET_BT_MAC_ADDR,
+	GET_BT_MAC_ADDR,
+	SET_VENDOR_INFO,
+	GET_VENDOR_INFO,
+	RDWR_PWRMM,
+	RDWR_PWRIDX,
+	RDWR_PWRLVL = RDWR_PWRIDX,
+	RDWR_PWROFST,
+	RDWR_DRVIBIT,
+	RDWR_EFUSE_PWROFST,
+	RDWR_EFUSE_DRVIBIT,
+	SET_PAPR,
+	SET_CAL_XTAL,
+	GET_CAL_XTAL_RES,
+	SET_COB_CAL,
+	GET_COB_CAL_RES,
+	RDWR_EFUSE_USRDATA,
+	SET_NOTCH,
+	RDWR_PWROFSTFINE,
+	RDWR_EFUSE_PWROFSTFINE,
+	RDWR_EFUSE_SDIOCFG,
+	RDWR_EFUSE_USBVIDPID,
+	SET_SRRC,
+	SET_FSS,
+	RDWR_EFUSE_HE_OFF,
+	SET_USB_OFF,
+	SET_PLL_TEST,
+	SET_ANT_MODE,
+	RDWR_BT_EFUSE_PWROFST,
+};
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+	u8_l mode;
+	u8_l rate;
+	u16_l length;
+	u16_l tx_intv_us;
+	s8_l max_pwr;
+} cmd_rf_settx_t;
+
+typedef struct {
+	u8_l val;
+} cmd_rf_setfreq_t;
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+} cmd_rf_rx_t;
+
+typedef struct {
+	u8_l block;
+} cmd_rf_getefuse_t;
+
+typedef struct {
+	u8_l dutid;
+	u8_l chip_num;
+	u8_l dis_xtal;
+} cmd_rf_setcobcal_t;
+
+typedef struct {
+	u16_l dut_rcv_golden_num;
+	u8_l golden_rcv_dut_num;
+	s8_l rssi_static;
+	s8_l snr_static;
+	s8_l dut_rssi_static;
+	u16_l reserved;
+} cob_result_ptr_t;
+#endif
+
+typedef struct
+{
+	u8_l func;
+	u8_l cnt;
+	u8_l reserved[2];
+	u32_l usrdata[3]; // 3 words totally
+} cmd_ef_usrdata_t;
+
+#define CMD_MAXARGS 30
+
+#if 0//#include <linux/ctype.h>
+#define isblank(c)		((c) == ' ' || (c) == '\t')
+#define isascii(c)		(((unsigned char)(c)) <= 0x7F)
+
+static int isdigit(unsigned char c)
+{
+	return ((c >= '0') && (c <='9'));
+}
+
+static int isxdigit(unsigned char c)
+{
+	if ((c >= '0') && (c <='9'))
+		return 1;
+	if ((c >= 'a') && (c <='f'))
+		return 1;
+	if ((c >= 'A') && (c <='F'))
+		return 1;
+	return 0;
+}
+
+static int islower(unsigned char c)
+{
+	return ((c >= 'a') && (c <='z'));
+}
+
+static unsigned char toupper(unsigned char c)
+{
+	if (islower(c))
+		c -= 'a'-'A';
+	return c;
+}
+#endif
+
+static int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+	while (nargs < CMD_MAXARGS) {
+		/* skip any white space */
+		while ((*line == ' ') || (*line == '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		/* Argument include space should be bracketed by quotation mark */
+		if (*line == '\"') {
+			/* Skip quotation mark */
+			line++;
+
+			/* Begin of argument string */
+			argv[nargs++] = line;
+
+			/* Until end of argument */
+			while (*line && (*line != '\"')) {
+				++line;
+			}
+		} else {
+			argv[nargs++] = line;    /* begin of argument string    */
+
+			/* find end of string */
+			while (*line && (*line != ' ') && (*line != '\t')) {
+				++line;
+			}
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		*line++ = '\0';         /* terminate current arg     */
+	}
+
+	printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
+
+	return nargs;
+}
+
+unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned int result = 0, value, is_neg = 0;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	if (*cp == '-') {
+		is_neg = 1;
+		cp++;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (is_neg)
+		result = (unsigned int)((int)result * (-1));
+
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+int str_starts(const char *str, const char *start)
+{
+	return strncmp(str, start, strlen(start)) == 0;
+}
+
+/*
+ * aic_priv_cmd handers.
+ */
+static int aic_priv_cmd_set_tx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_settx_t settx_param;
+#ifdef CONFIG_POWER_LIMIT
+	int8_t max_pwr;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+	txpwr_loss_conf_t *txpwr_loss;
+	txpwr_loss = &txpwr_loss_tmp;
+#endif
+
+	if (argc < 6)
+		return -EINVAL;
+
+	settx_param.chan = command_strtoul(argv[1], NULL, 10);
+	settx_param.bw = command_strtoul(argv[2], NULL, 10);
+	settx_param.mode = command_strtoul(argv[3], NULL, 10);
+	settx_param.rate = command_strtoul(argv[4], NULL, 10);
+	settx_param.length = command_strtoul(argv[5], NULL, 10);
+	if (argc > 6) {
+		settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
+	} else {
+		settx_param.tx_intv_us = 10000; // set default val 10ms
+	}
+	settx_param.max_pwr = POWER_LEVEL_INVALID_VAL;
+	AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
+		settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
+#ifdef CONFIG_POWER_LIMIT
+	txpwr_loss = &txpwr_loss_tmp;
+	get_userconfig_txpwr_loss(txpwr_loss);
+	if (txpwr_loss->loss_enable_2g4 == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+					txpwr_loss->loss_value_2g4);
+	if (txpwr_loss->loss_enable_5g == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+	max_pwr = get_powerlimit_by_chnum(settx_param.chan);
+	if (settx_param.chan >= 36) {
+		if (txpwr_loss->loss_enable_5g == 1)
+			max_pwr -= txpwr_loss->loss_value_5g;
+	} else {
+		if (txpwr_loss->loss_enable_2g4 == 1)
+			max_pwr -= txpwr_loss->loss_value_2g4;
+	}
+	settx_param.max_pwr = max_pwr;
+	AICWFDBG(LOGINFO, "max_pwr:%d\n", settx_param.max_pwr);
+#endif
+	rwnx_send_rftest_req(rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_txstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_rx_t setrx_param;
+
+	if (argc < 3) {
+		return -EINVAL;
+	}
+	setrx_param.chan = command_strtoul(argv[1], NULL, 10);
+	setrx_param.bw = command_strtoul(argv[2], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_rx_result (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	return 8;
+}
+
+static int aic_priv_cmd_set_rxstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_tx_tone (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	u8_l buf[2];
+	s8_l freq_ = 0;
+
+	AICWFDBG(LOGINFO, "%s argc:%d\n", argv[0], argc);
+	if ((argc == 2) || (argc == 3)) {
+		AICWFDBG(LOGINFO, "argv 1:%s\n",argv[1]);
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		if (argc == 3) {
+			AICWFDBG(LOGINFO, "argv 2:%s\n",argv[2]);
+			freq_ = (u8_l)command_strtoul(argv[2], NULL, 10);
+		} else {
+			freq_ = 0;
+		};
+		buf[0] = func;
+		buf[1] = (u8_l)freq_;
+		rwnx_send_rftest_req(rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx_meter (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	s8_l freq = 0;
+
+	freq = (int)command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX_METER, sizeof(freq), (u8_l *)&freq, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_set_power (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l ana_pwr;
+	u8_l dig_pwr;
+	u8_l pwr;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801) {
+		ana_pwr = command_strtoul(argv[1], NULL, 16);
+		dig_pwr = command_strtoul(argv[2], NULL, 16);
+		pwr = (ana_pwr << 4 | dig_pwr);
+		if (ana_pwr > 0xf || dig_pwr > 0xf)
+			return -EINVAL;
+	} else {
+		ana_pwr = command_strtoul(argv[1], NULL, 10);
+		pwr = ana_pwr;
+		if (ana_pwr > 0x1e)
+			return -EINVAL;
+	}
+	AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
+	rwnx_send_rftest_req(rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_xtal_cap (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_xtal_cap_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap_fine;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_efuse_block (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_getefuse_t getefuse_param;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	getefuse_param.block = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, GET_EFUSE_BLOCK, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
+	AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l val;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	val = cfm.rftest_result[0];
+	if (dev->chipid != PRODUCT_ID_AIC8801) {
+		AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
+				val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
+	} else {
+		AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
+	}
+	return 4;
+}
+
+static int aic_priv_cmd_set_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l vendor_info;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	vendor_info = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
+	rwnx_send_rftest_req(rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_get_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_rdwr_pwrmm (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	if (argc <= 1) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
+	} else { // write
+		u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
+		pwrmm = (pwrmm) ? 1 : 0;
+		AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_pwridx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid != PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr idx
+		if (argc > 3) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, type, pwridx};
+			AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 9);
+	return 9;
+}
+
+static int aic_priv_cmd_rdwr_pwrlvl (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr lvl
+		if (argc > 4) {
+			u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l idx, size;
+			u8_l buf[14] = {func, grp,};
+			if (argc > 12) { // set all grp
+			AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+				   "  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
+				if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
+					size = 10;
+				} else {
+					size = 12;
+				}
+				for (idx = 0; idx < size; idx++) {
+					s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
+					buf[2 + idx] = (u8_l)pwrlvl;
+					if (idx && !(idx & 0x3)) {
+						AICWFDBG(LOGINFO, " ");
+					}
+					AICWFDBG(LOGINFO, " %2d", pwrlvl);
+				}
+				AICWFDBG(LOGINFO, "\n");
+				size += 2;
+			} else { // set grp[idx]
+				u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
+				s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
+				buf[2] = idx;
+				buf[3] = (u8_l)pwrlvl;
+				size = 4;
+				AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+					   "  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
+			}
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
+		} else {
+		AICWFDBG(LOGERROR, "wrong args\n");
+		return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)){
+		memcpy(command, &cfm.rftest_result[0], 6 * 12);
+		return (6 * 12);
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 3 * 12);
+		return (3 * 12);
+	}
+}
+
+static int aic_priv_cmd_rdwr_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 4) { // write 2.4g/5g pwr ofst and ant0/1
+		if ((argc > 4) && ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2))) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && ((dev->chipid == PRODUCT_ID_AIC8801) || (dev->chipid == PRODUCT_ID_AIC8800DW) || (dev->chipid == PRODUCT_ID_AIC8800DC))) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
+		res_len = 3;
+	} else if (dev->chipid == PRODUCT_ID_AIC8800D81) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = 3 * 3 + 3 * 6;
+	} else if ((dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)) { // ant0/1
+		res_len = ( 3 * 3 + 3 * 6 ) * 2;
+	} else {
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set drvibit:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 16);
+	return 16;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 4) { // write 2.4g/5g pwr ofst and ant0/1
+		if ((argc > 4) && ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2))) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && ((dev->chipid == PRODUCT_ID_AIC8801) || (dev->chipid == PRODUCT_ID_AIC8800DW) || (dev->chipid == PRODUCT_ID_AIC8800DC))) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
+		res_len = 3 * 2;
+	} else if ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = (3 * 3 + 3 * 6) * 2;
+	} else { // 7 = 3(2.4g) + 4(5g)
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_efuse_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+		u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+		u8_l buf[2] = {func, ibit};
+		AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usrdata (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_ef_usrdata_t cmd_ef_usrdata;
+
+	if (argc <= 1) { // read all
+		cmd_ef_usrdata.func = 0;
+		cmd_ef_usrdata.cnt = 3;
+	} else if (argc >= 2) { // read/write
+		cmd_ef_usrdata.func = (u8_l)command_strtoul(argv[1], NULL, 10);
+		cmd_ef_usrdata.cnt = (u8_l)command_strtoul(argv[2], NULL, 10);
+		if (cmd_ef_usrdata.func == 1) {
+			int idx;
+			for (idx = 0; idx < cmd_ef_usrdata.cnt; idx++) {
+				cmd_ef_usrdata.usrdata[idx] = (u32_l)command_strtoul(argv[3 + idx], NULL, 16);
+			}
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong argc: %x\n", argc);
+		return -EINVAL;
+	}
+	rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USRDATA, sizeof(cmd_ef_usrdata), (u8_l *)&cmd_ef_usrdata, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 12);
+	return 12;
+}
+
+static int aic_priv_cmd_rdwr_efuse_sdiocfg (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
+	} else if (func == 1) { // write sdiocfg
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usbvidpid (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	AICWFDBG(LOGINFO, "read/write usb vid/pid into efuse\n");
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, 0, NULL, &cfm);
+	} else if (func == 1) { // write USB vid+pid
+		if (argc > 2) {
+			u32_l usb_id = (u32_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[5] = {func, (u8_l)usb_id, (u8_l)(usb_id >> 8), (u8_l)(usb_id >> 16), (u8_l)(usb_id >> 24)};
+			AICWFDBG(LOGINFO, "set efuse usb vid/pid:[%x]=%x\r\n", func, usb_id);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_he_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	func = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "set he off: %d\n", func);
+	if(func == 1 || func == 0) {
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_HE_OFF, sizeof(func), (u8_l *)&func, &cfm);
+		AICWFDBG(LOGINFO, "he_off cfm: %d\n", cfm.rftest_result[0]);
+		memcpy(command, &cfm.rftest_result[0], 4);
+		return 4;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_cal_xtal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_CAL_XTAL, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cal_xtal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_CAL_XTAL_RES, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
+	return 4;
+}
+
+static int aic_priv_cmd_set_cob_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setcobcal_t setcob_cal;
+
+	if (argc < 3)
+		return -EINVAL;
+	setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
+	setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
+	setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cob_cal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cob_result_ptr_t *cob_result_ptr;
+
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_do_cob_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cmd_rf_setcobcal_t setcob_cal;
+	cob_result_ptr_t *cob_result_ptr;
+
+	setcob_cal.dutid = 1;
+	setcob_cal.chip_num = 1;
+	setcob_cal.dis_xtal = 0;
+	if (argc > 1)
+		setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	msleep(2000);
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_set_papr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "papr %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_PAPR, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_notch (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "notch %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_NOTCH, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_srrc (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "srrc %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_SRRC, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_fss (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "fss %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_FSS, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_usb_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_USB_OFF, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_pll_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0, tx_pwr = 0xc;
+	s8_l freq = 0;
+
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 16);
+	}
+	if (argc > 3) {
+		freq = (s8_l)command_strtoul(argv[2], NULL, 10);
+		tx_pwr = command_strtoul(argv[3], NULL, 16);
+	}
+	if (func <= 1) {
+		u8_l buf[3] = {func, (u8_l)freq, tx_pwr};
+		AICWFDBG(LOGINFO, "set pll_test %d: freq=%d, tx_pwr=0x%x\n", func, freq, tx_pwr);
+		rwnx_send_rftest_req(rwnx_hw, SET_PLL_TEST, sizeof(buf), buf, &cfm);
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_ant_mode (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "ant %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_ANT_MODE, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_rdwr_bt_efuse_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc == 1) {
+		func = 0;
+	} else if (argc == 2) {
+		func = 1;
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_BT_EFUSE_PWROFST, 0, NULL, &cfm);
+	} else if (func == 1) { // write bt tx pwrofst
+			int8_t bt_txpwrofst = command_strtoul(argv[1], NULL, 10);
+			AICWFDBG(LOGINFO, "set bt efuse pwrofst %d\r\n",bt_txpwrofst);
+			if (bt_txpwrofst < -7 ||  bt_txpwrofst > 7) {
+				AICWFDBG(LOGERROR, "wrong params %d,  pwrofst limit -7 ~ 7\n", bt_txpwrofst);
+				return -EINVAL;
+			} else {
+				rwnx_send_rftest_req(rwnx_hw, RDWR_BT_EFUSE_PWROFST, sizeof(bt_txpwrofst), &bt_txpwrofst, &cfm);
+			}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 2);
+	return 2;
+}
+
+
+static int aic_priv_cmd_help (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	print_help(argc > 0 ? argv[0] : NULL);
+	return 0;
+}
+
+struct aic_priv_cmd {
+	const char *cmd;
+	int (*handler)(struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command);
+	const char *usage;
+};
+
+static const struct aic_priv_cmd aic_priv_commands[] = {
+	{ "set_tx", aic_priv_cmd_set_tx,
+	  "<chan> <bw> <mode> <rate> <length> <interval>" },
+	{ "set_txstop", aic_priv_cmd_set_txstop,
+	  "= stop tx " },
+	{ "set_rx", aic_priv_cmd_set_rx,
+	  "<chan_num> <bw> " },
+	{ "get_rx_result", aic_priv_cmd_get_rx_result,
+	  "= display rx fcsok/total pkt num" },
+	{ "set_rxstop", aic_priv_cmd_set_rxstop,
+	  "= stop rx " },
+	{ "set_txtone", aic_priv_cmd_set_tx_tone,
+	  "<val> val = 0/off" },
+	{ "set_rx_meter", aic_priv_cmd_set_rx_meter,
+	  "= set rx meter " },
+	{ "set_power", aic_priv_cmd_set_set_power,
+	  "<dec val> " },
+	{ "set_xtal_cap", aic_priv_cmd_set_xtal_cap,
+	  "<dec val> [0 ~ 31]" },
+	{ "set_xtal_cap_fine", aic_priv_cmd_set_xtal_cap_fine,
+	  "<dec val> [0 ~ 63]" },
+	{ "get_efuse_block", aic_priv_cmd_get_efuse_block,
+	  "<val>" },
+	{ "set_freq_cal", aic_priv_cmd_set_freq_cal,
+	  "<hex val>" },
+	{ "set_freq_cal_fine", aic_priv_cmd_set_freq_cal_fine,
+	  "<hex val>" },
+	{ "get_freq_cal", aic_priv_cmd_get_freq_cal,
+	  "= display cap & cap fine" },
+	{ "set_mac_addr", aic_priv_cmd_set_mac_addr,
+	  "= write WiFi MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_mac_addr", aic_priv_cmd_get_mac_addr,
+	  "= display WiFi MAC stored in efuse or flash" },
+	{ "set_bt_mac_addr", aic_priv_cmd_set_bt_mac_addr,
+	  "= write BT MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_bt_mac_addr", aic_priv_cmd_get_bt_mac_addr,
+	  "= display BT MAC stored in efuse or flash" },
+	{ "set_vendor_info", aic_priv_cmd_set_vendor_info,
+	  "= write vendor info into efuse or flash is allowed only once" },
+	{ "get_vendor_info", aic_priv_cmd_get_vendor_info,
+	  "= display vendor info stored in efuse or flash" },
+	{ "rdwr_pwrmm", aic_priv_cmd_rdwr_pwrmm,
+	  "<val> = 0/rdwr_pwrlvl, 1/set_power = read/write txpwr manul mode" },
+	{ "rdwr_pwridx", aic_priv_cmd_rdwr_pwridx,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrlvl", aic_priv_cmd_rdwr_pwrlvl,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrofst", aic_priv_cmd_rdwr_pwrofst,
+	  "<band> <rate> <ch> <ofst>" },
+	{ "rdwr_pwrofstfine", aic_priv_cmd_rdwr_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine>" },
+	{ "rdwr_drvibit", aic_priv_cmd_rdwr_drvibit,
+	  "<func> <val> read/write 8800D pa drvibit" },
+	{ "set_cal_xtal", aic_priv_cmd_set_cal_xtal,
+	  "= set cal xtal" },
+	{ "get_cal_xtal_res", aic_priv_cmd_get_cal_xtal_res,
+	  "= get cal xtal result cap & cap_fine" },
+	{ "set_cob_cal", aic_priv_cmd_set_cob_cal,
+	  "<dutid> <chip_num> <disxtal> = dut cob test" },
+	{ "get_cob_cal_res", aic_priv_cmd_get_cob_cal_res,
+	  "= get cob cal result" },
+	{ "do_cob_test", aic_priv_cmd_do_cob_test,
+	  "<func> = 0/xtal, 1/dis_xtal, 2/only_xtal" },
+	{ "rdwr_efuse_pwrofst", aic_priv_cmd_rdwr_efuse_pwrofst,
+	  "<band> <rate> <ch> <ofst> limited to a maximum of two times" },
+	{ "rdwr_efuse_pwrofstfine", aic_priv_cmd_rdwr_efuse_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine> limited to a maximum of two times" },
+	{ "rdwr_efuse_drvibit", aic_priv_cmd_rdwr_efuse_drvibit,
+	  "<func> <val> = read/write 8800D efuse pa drvibitis allowed only once" },
+	{ "rdwr_efuse_usrdata", aic_priv_cmd_rdwr_efuse_usrdata,
+	  "<func> <val> = read/write efuse usrdata" },
+	{ "rdwr_efuse_sdiocfg", aic_priv_cmd_rdwr_efuse_sdiocfg,
+	  "<func> <val> = read/write sdiocfg_bit into efuse" },
+	{ "rdwr_efuse_usbvidpid", aic_priv_cmd_rdwr_efuse_usbvidpid,
+	  "<func> <val> = read/write usb vid/pid into efuse" },
+	{ "rdwr_efuse_he_off", aic_priv_cmd_rdwr_efuse_he_off,
+	  "<func> = read/write he_off into efuse" },
+	{ "set_papr", aic_priv_cmd_set_papr,
+	  "<val> = configure papr filter to optimize sideband suppression" },
+	{ "set_notch", aic_priv_cmd_set_notch,
+	  "<val> = configure filter to optimize sideband suppression" },
+	{ "set_srrc", aic_priv_cmd_set_srrc,
+	  "<func> = disable/enable sideband suppression for SRRC" },
+	{ "set_fss", aic_priv_cmd_set_fss,
+	  "<func> = disable/enable treatment of spurious emissions and burrs" },
+	{ "set_usb_off", aic_priv_cmd_set_usb_off,
+	  "= off usb configure before usb disconnect" },
+	{ "set_pll_test", aic_priv_cmd_set_pll_test,
+	  "<func> <freq> <tx_pwr> = use pll test to measure saturation power" },
+	{ "set_ant", aic_priv_cmd_set_ant_mode,
+	  "<val> = 0/ant0, 1/ant1, 2/both" },
+	{ "rdwr_bt_efuse_pwrofst", aic_priv_cmd_rdwr_bt_efuse_pwrofst,
+	  "<pwrofst> = read/write bt tx power offset into efuse" },
+//Reserve for new aic_priv_cmd.
+	{ "help", aic_priv_cmd_help,
+	  "= show usage help" },
+	{ NULL, NULL, NULL },
+
+};
+
+
+/*
+ * Prints command usage, lines are padded with the specified string.
+ */
+static void print_help(const char *cmd)
+{
+	int n;
+	printk("commands:\n");
+	for (n = 0; aic_priv_commands[n].cmd; n++) {
+		if (cmd != NULL)
+			printk("%s %s\n", aic_priv_commands[n].cmd, aic_priv_commands[n].usage);
+	}
+}
+
+int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
+{
+	const struct aic_priv_cmd *cmd, *match = NULL;
+	int count;
+	int bytes_written = 0;
+	char *argv[CMD_MAXARGS + 1];
+	int argc;
+	struct rwnx_vif *vif = container_of(net->ieee80211_ptr, struct rwnx_vif, wdev);
+	struct rwnx_hw *p_rwnx_hw = vif->rwnx_hw;
+	
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	if(!testmode) {
+		AICWFDBG(LOGERROR, "not in testmode\n");
+		return -1;
+	}
+	argc = parse_line(command, argv);
+	if (argc == 0) {
+		return -1;
+	}
+
+	count = 0;
+	cmd = aic_priv_commands;
+	while (cmd->cmd) {
+		if (strncasecmp(cmd->cmd, argv[0], strlen(argv[0])) == 0)
+		{
+			match = cmd;
+			if (strcasecmp(cmd->cmd, argv[0]) == 0) {
+				/* we have an exact match */
+				count = 1;
+				break;
+			}
+			count++;
+		}
+		cmd++;
+	}
+
+	if (count > 1) {
+		AICWFDBG(LOGINFO, "Ambiguous command '%s'; possible commands:", argv[0]);
+		cmd = aic_priv_commands;
+		while (cmd->cmd) {
+			if (strncasecmp(cmd->cmd, argv[0],
+					   strlen(argv[0])) == 0) {
+				AICWFDBG(LOGINFO, " %s", cmd->cmd);
+			}
+			cmd++;
+		}
+		AICWFDBG(LOGINFO, "\n");
+	} else if (count == 0) {
+		AICWFDBG(LOGERROR, "Unknown command '%s'\n", argv[0]);
+	} else {
+		AICWFDBG(LOGINFO, "match %s", match->cmd);
+		bytes_written = match->handler(p_rwnx_hw, argc, &argv[0], command);
+	}
+
+	if (bytes_written < 0)
+		AICWFDBG(LOGERROR, "wrong param\n");
+
+	return bytes_written;
+}
+
+#define RWNX_COUNTRY_CODE_LEN 2
+#define CMD_SET_COUNTRY         "COUNTRY"
+#define CMD_SET_VENDOR_EX_IE    "SET_VENDOR_EX_IE"
+#define CMD_SET_AP_WPS_P2P_IE   "SET_AP_WPS_P2P_IE"
+#define CMD_SET_TESTMODE        "SET_TESTMODE"
+#define CMD_SET_BLE_WAKE	"SET_BLE_WAKE"
+#define CMD_SET_MON_FREQ	"SET_MON_FREQ"
+
+
+struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
+struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
+extern int reg_regdb_size;
+
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+extern u8_l vendor_extension_data[256];
+extern u8_l vendor_extension_len;
+
+void set_vendor_extension_ie(char *command){
+
+	char databyte[3]={0x00, 0x00, 0x00};
+	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
+	int command_index = skip;
+	int data_index = 0;
+
+	memset(vendor_extension_data, 0, 256);
+	vendor_extension_len = 0;
+	memcpy(databyte, command + command_index, 2);
+	vendor_extension_len = command_strtoul(databyte, NULL, 16);
+	AICWFDBG(LOGINFO, "%s len:%d \r\n", __func__, vendor_extension_len);
+
+	//parser command and save data in vendor_extension_data
+	for(data_index = 0;data_index < vendor_extension_len; data_index++){
+		command_index = command_index + 3;
+		memcpy(databyte, command + command_index, 2);
+		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
+	}
+
+}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+int rwnx_cfg80211_set_monitor_channel_(struct wiphy *wiphy,
+                                             struct cfg80211_chan_def *chandef);
+int rwnx_atoi2(char *value, int c_len);
+void set_mon_chan(struct rwnx_vif *vif, char *parameter){
+    struct cfg80211_chan_def *chandef = NULL;
+    int freq = 0;
+    
+    
+    chandef = (struct cfg80211_chan_def *)vmalloc(sizeof(struct cfg80211_chan_def));
+    memset(chandef, 0, sizeof(struct cfg80211_chan_def));
+    chandef->chan = (struct ieee80211_channel *)vmalloc(sizeof(struct ieee80211_channel));
+    memset(chandef->chan, 0, sizeof(struct ieee80211_channel));
+    
+    freq = rwnx_atoi2(parameter, 4);
+
+    if(freq <= 2484){
+        chandef->chan->band = NL80211_BAND_2GHZ;
+    }else{
+        chandef->chan->band = NL80211_BAND_5GHZ;
+    }
+    chandef->chan->center_freq = freq;
+    chandef->width = NL80211_CHAN_WIDTH_20;
+    chandef->center_freq1 = chandef->chan->center_freq;
+    chandef->center_freq2 = 0;
+
+    rwnx_cfg80211_set_monitor_channel_(vif->rwnx_hw->wiphy, chandef);
+
+    vfree(chandef->chan);
+    vfree(chandef);
+
+}
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+#define PRIVATE_COMMAND_MAX_LEN 8192
+#define PRIVATE_COMMAND_DEF_LEN 4096
+
+	struct rwnx_vif *vif = netdev_priv(net);
+	int ret = 0;
+	char *command = NULL;
+	int bytes_written = 0;
+	android_wifi_priv_cmd priv_cmd;
+	int buf_size = 0;
+	int skip = 0;
+	char *country = NULL;
+	struct ieee80211_regdomain *regdomain;
+	//int index = 0;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	///todo: add our lock
+	//net_os_wake_lock(net);
+
+
+/*	if (!capable(CAP_NET_ADMIN)) {
+		ret = -EPERM;
+		goto exit;
+	}*/
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+	}
+	if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
+		AICWFDBG(LOGERROR, "%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
+	command = kmalloc((buf_size + 1), GFP_KERNEL);
+
+	if (!command)
+	{
+		AICWFDBG(LOGERROR, "%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	command[priv_cmd.total_len] = '\0';
+
+	/* outputs */
+	AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
+	AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
+	AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
+
+
+#if 1//Handle Android command
+	if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
+		skip = strlen(CMD_SET_COUNTRY) + 1;
+		country = command + skip;
+		if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
+			AICWFDBG(LOGERROR, "%s: invalid country code\n", __func__);
+			ret = -EINVAL;
+			goto exit;
+		}
+#if 0
+		for(index = 0; index < reg_regdb_size; index++){
+			regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
+			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+				AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
+			}else{
+				AICWFDBG(LOGINFO, "regulatory_set_wiphy_regd ok \r\n");
+			}
+		}
+#endif
+		AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
+		regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+			AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
+		}
+#else
+		wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
+#endif
+#ifdef CONFIG_POWER_LIMIT
+		if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+		    rwnx_plat_powerlimit_load_8800dcdw(vif->rwnx_hw, PRODUCT_ID_AIC8800DW);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC)
+		    rwnx_plat_powerlimit_load_8800dcdw(vif->rwnx_hw, PRODUCT_ID_AIC8800DC);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81)
+		    rwnx_plat_powerlimit_load_8800d80(vif->rwnx_hw);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+				vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2)
+		    rwnx_plat_powerlimit_load_8800d80x2(vif->rwnx_hw);
+		if (!testmode){
+		    rwnx_send_me_chan_config_req(vif->rwnx_hw);
+		}
+#endif
+		ret = 0;
+		goto exit;
+	}
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+	else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
+		set_vendor_extension_ie(command);
+		ret = 0;
+		goto exit;
+	}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+	else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
+		ret = 0;
+		goto exit;
+	}else if(!strncasecmp(command, CMD_SET_TESTMODE, strlen(CMD_SET_TESTMODE))){
+		if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
+			if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81X2) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D89X2)){
+				set_testmode(!testmode);
+				rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
+			}
+		}
+		ret = 0;
+		goto exit;
+	}else if(!strncasecmp(command, CMD_SET_BLE_WAKE, strlen(CMD_SET_BLE_WAKE))){
+		if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
+			set_testmode(5);
+			rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
+		}
+		ret = 0;
+		goto exit;
+	}
+#ifdef CONFIG_RWNX_MON_DATA
+    else if(!strncasecmp(command, CMD_SET_MON_FREQ, strlen(CMD_SET_MON_FREQ))){
+	    char *set_parameter;
+        skip = strlen(CMD_SET_MON_FREQ) + 1;
+		set_parameter = command + skip;
+	    set_mon_chan(vif, set_parameter);
+		ret = 0;
+		goto exit;
+    }
+#endif
+#endif//Handle Android command
+
+
+	bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
+			command[0] = '\0';
+		}
+		if (bytes_written >= priv_cmd.total_len) {
+			AICWFDBG(LOGINFO, "%s: err. bytes_written:%d >= buf_size:%d \n",
+				__FUNCTION__, bytes_written, buf_size);
+			goto exit;
+		}
+		bytes_written++;
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+		AICWFDBG(LOGERROR, "%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		/* Propagate the error */
+		ret = bytes_written;
+	}
+
+exit:
+	///todo: add our unlock
+	//net_os_wake_unlock(net);
+	kfree(command);
+	return ret;
+}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
new file mode 100644
index 000000000..7449190f5
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
@@ -0,0 +1,33 @@
+/**
+ ******************************************************************************
+ *
+ * @file private_cmd.h
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#ifndef _AIC_PRIV_CMD_H_
+#define _AIC_PRIV_CMD_H_
+
+#include "rwnx_defs.h"
+
+typedef struct _android_wifi_priv_cmd {
+    char *buf;
+    int used_len;
+    int total_len;
+} android_wifi_priv_cmd;
+
+#ifdef CONFIG_COMPAT
+typedef struct _compat_android_wifi_priv_cmd {
+    compat_caddr_t buf;
+    int used_len;
+    int total_len;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#endif /* _AIC_PRIV_CMD_H_ */
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 5ef5995fa..5394c71ef 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -27,6 +27,15 @@ static struct wifi_ring_buffer_status ring_buffer[] = {
 static struct wlan_driver_wake_reason_cnt_t wake_reason_cnt = {
 	.total_cmd_event_wake = 10,
 };
+
+enum apf_attributes {
+        APF_ATTRIBUTE_VERSION,
+        APF_ATTRIBUTE_MAX_LEN,
+        APF_ATTRIBUTE_PROGRAM,
+        APF_ATTRIBUTE_PROGRAM_LEN,
+        APF_ATTRIBUTE_MAX
+};
+
 #endif
 
 int aic_dev_start_mkeep_alive(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
@@ -305,17 +314,28 @@ static int aicwf_vendor_subcmd_get_channel_list(struct wiphy *wiphy, struct wire
 	return -EMSGSIZE;
 }
 
+struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
+
 static int aicwf_vendor_subcmd_set_country_code(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
 	int ret = 0, rem, type;
 	const struct nlattr *iter;
+    struct ieee80211_regdomain *regdomain;
 
 	nla_for_each_attr(iter, data, len, rem) {
 		type = nla_type(iter);
 		switch (type) {
 		case ANDR_WIFI_ATTRIBUTE_COUNTRY:
 			printk("%s(%d), ANDR_WIFI_ATTRIBUTE_COUNTRY: %s\n", __func__, __LINE__, (char *)nla_data(iter));
+            regdomain = getRegdomainFromRwnxDB(wiphy, (char *)nla_data(iter));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+        if((ret = regulatory_set_wiphy_regd(wiphy, regdomain))){
+            AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
+        }
+#else
+            wiphy_apply_custom_regulatory(wiphy, regdomain);
+#endif
 			break;
 		default:
 			pr_err("%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
@@ -578,7 +598,69 @@ static int aicwf_vendor_logger_get_wake_reason_stats(struct wiphy *wiphy, struct
 	return -EMSGSIZE;
 }
 
-static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+static int aicwf_vendor_logger_get_tx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+static int aicwf_vendor_logger_get_rx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+static int aicwf_vendor_logger_start_pkt_fate_monitoring(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
 	/* TODO
@@ -587,6 +669,44 @@ static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct
 	return 0;
 }
 
+static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+	int ver, max_len;
+	int ret = 0;
+	struct sk_buff *skb = NULL;
+	
+	/* APF version */
+	ver = 4;
+	/* APF memory size limit */
+    max_len = 2048;
+
+	
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, max_len);
+	
+	ret = nla_put_u32(skb, APF_ATTRIBUTE_VERSION, ver);
+	if (ret < 0) {
+			AICWFDBG(LOGERROR, "Failed to put APF_ATTRIBUTE_VERSION, ret:%d\n", ret);
+			goto fail;
+	}
+	ret = nla_put_u32(skb, APF_ATTRIBUTE_MAX_LEN, max_len);
+	if (ret < 0) {
+			AICWFDBG(LOGERROR, "Failed to put APF_ATTRIBUTE_MAX_LEN, ret:%d\n", ret);
+			goto fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(ret)) {
+			AICWFDBG(LOGERROR, "vendor command reply failed, ret=%d\n", ret);
+	}
+
+fail:
+	/* TODO
+	 * Add handle in the future
+	 */
+	return ret;
+}
+
 static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
@@ -594,8 +714,6 @@ static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev
 	const struct nlattr *iter;
 	u8 mac[ETH_ALEN];
 
-    printk("%s enter \r\n", __func__);
-
 	nla_for_each_attr(iter, data, len, rem) {
 		type = nla_type(iter);
 		switch (type) {
@@ -859,6 +977,48 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_START_PKT_FATE_MONITORING
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_start_pkt_fate_monitoring,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_TX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_tx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_RX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_rx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
index 706e9f315..3a9ca060d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
@@ -3,6 +3,7 @@
 #include "reg_access.h"
 
 #define FW_USERCONFIG_NAME_8800D80         "aic_userconfig_8800d80.txt"
+#define FW_POWERLIMIT_NAME_8800D80         "aic_powerlimit_8800d80.txt"
 
 extern char aic_fw_path[200];
 
@@ -19,13 +20,14 @@ int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_
 	if ((ret = rwnx_send_txpwr_lvl_v3_req(rwnx_hw))) {
 		return -1;
 	}
+	if ((ret = rwnx_send_txpwr_lvl_adj_req(rwnx_hw))) {
+		return -1;
+	}
 	if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
 		return -1;
 	}
-	if (testmode == 0) {
-		if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
-			return -1;
-		}
+	if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
+		return -1;
 	}
 	return 0 ;
 }
@@ -62,5 +64,33 @@ int	rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw){
 
 }
 
+#ifdef CONFIG_POWER_LIMIT
+extern char country_code[];
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw)
+{
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_POWERLIMIT_NAME_8800D80;
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    /* parsing the file */
+    rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
 
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
index 27565d802..134fd1a53 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
@@ -1,6 +1,9 @@
 #include <linux/types.h>
 
 int rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw);
+#endif
 int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c
new file mode 100644
index 000000000..11a09f829
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c
@@ -0,0 +1,97 @@
+#include "rwnx_main.h"
+#include "rwnx_msg_tx.h"
+#include "reg_access.h"
+
+#define FW_USERCONFIG_NAME_8800D80X2         "aic_userconfig_8800d80x2.txt"
+#define FW_POWERLIMIT_NAME_8800D80X2         "aic_powerlimit_8800d80x2.txt"
+
+extern char aic_fw_path[200];
+
+int rwnx_request_firmware_common(struct rwnx_hw *rwnx_hw,
+	u32** buffer, const char *filename);
+void rwnx_plat_userconfig_parsing_8800d80x2(char *buffer, int size);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+void rwnx_release_firmware_common(u32** buffer);
+
+
+int aicwf_set_rf_config_8800d80x2(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm)
+{
+	int ret = 0;
+
+	if ((ret = rwnx_send_txpwr_lvl_v4_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_txpwr_lvl_adj_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_txpwr_ofst2x_v2_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
+		return -1;
+	}
+	return 0 ;
+}
+
+
+int	rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw){
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800D80X2;
+
+#ifndef ANDROID_PLATFORM
+    sprintf(aic_fw_path, "%s/%s", aic_fw_path, "aic8800D80X2");
+#endif
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+    /* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    rwnx_plat_userconfig_parsing_8800d80x2((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
+
+#ifdef CONFIG_POWER_LIMIT
+extern char default_ccode[];
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw)
+{
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_POWERLIMIT_NAME_8800D80X2;
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    /* parsing the file */
+    rwnx_plat_powerlimit_parsing((char *)dst, size, default_ccode);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h
new file mode 100644
index 000000000..dbd4de9a2
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h
@@ -0,0 +1,9 @@
+#include <linux/types.h>
+
+int rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+#endif
+int aicwf_set_rf_config_8800d80x2(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
+
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
index a1e542368..f0bad8024 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -19,6 +19,16 @@
 #define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
 #define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_h_u02.bin"
 
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+#define FW_8800DC_U02_ADID_ADDR         0x1017d8
+#define FW_RAM_PATCH_BASE_ADDR          0x184000
+#define FW_ADID_BASE_NAME               "fw_adid_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02         "fw_patch_table_8800dc_u02.bin"
+#define FW_PATCH_BASE_NAME_U02          "fw_patch_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02H        "fw_patch_table_8800dc_u02h.bin"
+#define FW_PATCH_BASE_NAME_U02H         "fw_patch_8800dc_u02h.bin"
+#define AICBT_PT_TAG                    "AICBT_PT_TAG"
+#endif
 #ifdef CONFIG_FOR_IPCAM
 #define RWNX_MAC_PATCH_TABLE_NAME_8800DC "fmacfw_patch_tbl_8800dc_ipc"
 #else
@@ -33,7 +43,105 @@
 #define RWNX_MAC_RF_PATCH_NAME_8800DC RWNX_MAC_RF_PATCH_BASE_NAME_8800DC".bin"
 #define FW_USERCONFIG_NAME_8800DC         "aic_userconfig_8800dc.txt"
 #define FW_USERCONFIG_NAME_8800DW         "aic_userconfig_8800dw.txt"
+#define FW_POWERLIMIT_NAME_8800DC         "aic_powerlimit_8800dc.txt"
+#define FW_POWERLIMIT_NAME_8800DW         "aic_powerlimit_8800dw.txt"
+
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+enum aicbt_patch_table_type {
+    AICBT_PT_NULL = 0x00,
+    AICBT_PT_TRAP,
+    AICBT_PT_B4,
+    AICBT_PT_BTMODE,
+    AICBT_PT_PWRON,
+    AICBT_PT_AF,
+    AICBT_PT_VER,
+    AICBT_PT_MAX,
+};
+
+struct aicbt_patch_table {
+    char     *name;
+    uint32_t type;
+    uint32_t *data;
+    uint32_t len;
+    struct aicbt_patch_table *next;
+};
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+    uint32_t lpm_enable;
+    uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+#define AICBT_TXPWR_DFT                0x6F2F
+
 
+#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_WIFI_COMBO
+#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT    0
+#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_DFT
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+static struct aicbt_info_t aicbt_info = {
+    .btmode        = AICBT_BTMODE_DEFAULT,
+    .btport        = AICBT_BTPORT_DEFAULT,
+    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+};
+#endif
 
 int rwnx_plat_bin_fw_upload_2(struct rwnx_hw *rwnx_hw, u32 fw_addr,
                                char *filename);
@@ -1345,6 +1453,7 @@ uint32_t agc_cfg_ram[] = {
     0x00000000
 };
 
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 uint32_t txgain_map[96] =  {
 #ifdef CONFIG_FPGA_VERIFICATION
     0x20c0c971,
@@ -1482,8 +1591,8 @@ uint32_t txgain_map[96] =  {
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
-    0x00ffca7d,
-    0x00ffca88,
+    0x00ffcc4b,
+    0x00ffcc54,
     0x00ffcc5e,
     0x00ffcc69,
     0x00ffcc78,
@@ -1515,8 +1624,8 @@ uint32_t txgain_map[96] =  {
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
-    0x00ffca7d,
-    0x00ffca88,
+    0x00ffcc4b,
+    0x00ffcc54,
     0x00ffcc5e,
     0x00ffcc69,
     0x00ffcc78,
@@ -1524,9 +1633,9 @@ uint32_t txgain_map[96] =  {
     0x00ffcd70,
     0x00ffcd80,
     0x00ffcd90,
-    0x00ffce80,
-    0x00ffce93,
-    0x00ffcf90,
+    0x00ffcf68,
+    0x00ffcf75,
+    0x00ffcf83,
     0x00ffc080,
     0x00ffc090,
     0x00ffc180,
@@ -1585,8 +1694,8 @@ const uint32_t txgain_map_h[96] =
     0xffc879, //8
     0xffc96b, //9
     0xffc979, //10
-    0xffca6b, //11
-    0xffca79, //12
+    0xffcc45, //11
+    0xffcc4d, //12
     0xffcc56, //13
     0xffcc60, //14
     0xffcc6b, //15
@@ -1618,15 +1727,15 @@ const uint32_t txgain_map_h[96] =
     0xffc879, //8
     0xffc96b, //9
     0xffc979, //10
-    0xffca6b, //11
-    0xffca79, //12
+    0xffcc45, //11
+    0xffcc4d, //12
     0xffcc56, //13
     0xffcc60, //14
     0xffcc6b, //15
     0xffcc79, //16
     0xffcd72, //17
-    0xffce60, //18
-    0xffce72, //19
+    0xffcf5b, //18
+    0xffcf66, //19
     0xffcf72, //20
     0xffcf80, //21
     0xffcf90, //22
@@ -1649,6 +1758,214 @@ const uint32_t txgain_map_h[96] =
     0xffc86b, //7
 };
 
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+const uint32_t txgain_map_femkct[96] =
+{
+    //11b
+    0x00ffd780,//15
+    0x00ffd872,//16
+    0x00ffd880,//17
+    0x00ffd972,//18
+    0x00ffd980,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd36d,//6
+    0x00ffd379,//7
+    0x00ffd46d,//8
+    0x00ffd479,//9
+    0x00ffd572,//10
+    0x00ffd580,//11
+    0x00ffd672,//12
+    0x00ffd680,//13
+    0x00ffd772,//14
+    //high
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+    //low
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//26
+    0x00ffcf80,//27
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+};
+
+const uint32_t txgain_map_femkct_h[96] =
+{
+    //11b
+    0x00ffd872,//15
+    0x00ffd880,//16
+    0x00ffd972,//17
+    0x00ffd980,//18
+    0x00ffd990,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd379,//6
+    0x00ffd46d,//7
+    0x00ffd479,//8
+    0x00ffd572,//9
+    0x00ffd580,//10
+    0x00ffd672,//11
+    0x00ffd680,//12
+    0x00ffd772,//13
+    0x00ffd780,//14
+    //high
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+    //low
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+};
+#endif
+
 u32 patch_tbl_func[][2] =
 {
     {0x00110054, 0x0018186D}, // same as jump_tbl idx 168
@@ -1662,6 +1979,7 @@ u32 patch_tbl_rf_func[][2] =
 };
 
 
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 u32 wifi_txgain_table_24g_8800dcdw[32] =
 {
     0xA4B22189, //index 0
@@ -1806,6 +2124,80 @@ u32 wifi_txgain_table_24g_1_8800dcdw_h[32] =
     0x00001825,
 };
 
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+// ofdm
+uint32_t wifi_txgain_table_24g_8800dcdw_femkct[32] = {
+    0x919221C2, //index 0
+    0x00007825,
+    0x899221C3, //index 1
+    0x00007825,
+    0x8B9221C3, //index 2
+    0x00007825,
+    0x929221C3, //index 3
+    0x00007825,
+    0x949221C4, //index 4
+    0x00007825,
+    0x969221C4, //index 5
+    0x00007825,
+    0x949221C6, //index 6
+    0x00007825,
+    0x949221C8, //index 7
+    0x00007825,
+    0x9C9221C8, //index 8
+    0x00007825,
+    0x9C9221CA, //index 9
+    0x00007825,
+    0x9C9221CB, //index 10
+    0x00007825,
+    0x939221D5, //index 11
+    0x00007825,
+    0x9B9221D7, //index 12
+    0x00007825,
+    0xA49221D7, //index 13
+    0x00007825,
+    0xA79221D7, //index 14
+    0x00007825,
+    0xBD9221D7, //index 15
+    0x00007825,
+};
+
+// 11b
+uint32_t wifi_txgain_table_24g_1_8800dcdw_femkct[32] = {
+    0x836E20C2, //index 0
+    0x00003024,
+    0x856E20C2, //index 1
+    0x00003024,
+    0x826E20C3, //index 2
+    0x00003024,
+    0x836E20C3, //index 3
+    0x00003024,
+    0x856E20C3, //index 4
+    0x00003024,
+    0x876E20C3, //index 5
+    0x00003024,
+    0x8B6E20C3, //index 6
+    0x00003024,
+    0x926E20C4, //index 7
+    0x00003024,
+    0x9A6E20C4, //index 8
+    0x00003024,
+    0x936E20C5, //index 9
+    0x00003024,
+    0x936E20C7, //index 10
+    0x00003024,
+    0xA16E20C8, //index 11
+    0x00003024,
+    0xA16E20CA, //index 12
+    0x00003024,
+    0xA26E20CB, //index 13
+    0x00003024,
+    0xAA6E20CD, //index 14
+    0x00003024,
+    0xAC7220CF, //index 15
+    0x00003024,
+};
+#endif
+
 u32 wifi_rxgain_table_24g_20m_8800dcdw[64] = {
     0x82f282d1,//index 0
     0x9591a324,
@@ -1948,10 +2340,231 @@ u32 adaptivity_patch_tbl[][2] = {
 };
 //adap test
 
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+int rwnx_get_patch_addr_from_patch_table(struct rwnx_hw *rwnx_hw, char *filename, uint32_t *fw_patch_base_addr)
+{
+    int size;
+    int ret = 0;
+    uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+    uint32_t *data = NULL;
+    uint32_t type = 0, len = 0;
+    int j;
+
+    /* load aic firmware */
+    size = rwnx_request_firmware_common(rwnx_hw, (u32 **)&rawdata, filename);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        p += 16;
+
+        type = *(uint32_t *)p;
+        p += 4;
+
+        len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", type, len);
+
+        if(type >= 1000 ) {//Temp Workaround
+            len = 0;
+        }else{
+            data = (uint32_t *)p;
+            if (type == AICBT_PT_NULL) {
+                *(fw_patch_base_addr) = *(data + 3);
+                printk("addr found %x\n", *(fw_patch_base_addr));
+                for (j = 0; j < len; j++) {
+                    printk("addr %x\n", *(data+j));
+                }
+                break;
+            }
+            p += len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+
+int rwnx_patch_table_free(struct aicbt_patch_table **head)
+{
+	struct aicbt_patch_table *p = *head, *n = NULL;
+	while (p) {
+		n = p->next;
+		vfree(p->name);
+		vfree(p->data);
+		vfree(p);
+		p = n;
+	}
+	*head = NULL;
+	return 0;
+}
+
+int rwnx_patch_table_load(struct rwnx_hw *rwnx_hw, struct aicbt_patch_table *_head)
+{
+	struct aicbt_patch_table *head, *p;
+	int ret = 0, i;
+	uint32_t *data = NULL;
+
+	head = _head;
+	for (p = head; p != NULL; p = p->next) {
+		data = p->data;
+		if(AICBT_PT_BTMODE == p->type){
+			*(data + 1)  = aicbsp_info.hwinfo < 0;
+			*(data + 3) = aicbsp_info.hwinfo;
+			*(data + 5)  = aicbsp_info.cpmode;
+
+			*(data + 7) = aicbt_info.btmode;
+			*(data + 9) = aicbt_info.btport;
+			*(data + 11) = aicbt_info.uart_baud;
+			*(data + 13) = aicbt_info.uart_flowctrl;
+			*(data + 15) = aicbt_info.lpm_enable;
+			*(data + 17) = aicbt_info.txpwr_lvl;
+
+		}
+		if (p->type == AICBT_PT_NULL || p->type == AICBT_PT_PWRON) {
+            continue;
+        }
+
+
+        if (p->type == AICBT_PT_VER) {
+            char *data_s = (char *)p->data;
+            printk("patch version %s\n", data_s);
+            continue;
+        }
+
+        if (p->len == 0) {
+            printk("len is 0\n");
+            continue;
+        }
+
+		for (i = 0; i < p->len; i++) {
+			ret = rwnx_send_dbg_mem_write_req(rwnx_hw, *data, *(data + 1));
+			if (ret != 0)
+				return ret;
+			data += 2;
+		}
+
+	}
+	rwnx_patch_table_free(&head);
+	return 0;
+}
+
+
+
+
+int rwnx_patch_table_download(struct rwnx_hw *rwnx_hw, char *filename)
+{
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_table *new = NULL;
+    struct aicbt_patch_table *cur = NULL;
+        int size;
+    int ret = 0;
+    uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = rwnx_request_firmware_common(rwnx_hw, (u32 **)&rawdata, filename);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+        memset(new, 0, sizeof(struct aicbt_patch_table));
+        if (head == NULL) {
+            head = new;
+            cur  = new;
+        } else {
+            cur->next = new;
+            cur = cur->next;
+        }
+
+        cur->name = (char *)vmalloc(sizeof(char) * 16);
+        memset(cur->name, 0, sizeof(char) * 16);
+        memcpy(cur->name, p, 16);
+        p += 16;
+
+        cur->type = *(uint32_t *)p;
+        p += 4;
+
+        cur->len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", cur->type, cur->len);
+
+        if((cur->type )  >= 1000 ) {//Temp Workaround
+            cur->len = 0;
+        }else{
+            cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+            memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+            memcpy(cur->data, p, cur->len * 8);
+            p += cur->len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    rwnx_patch_table_load(rwnx_hw, head);
+    printk("fw_patch_table download complete\n\n");
+
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+#endif
+
 #ifdef CONFIG_DPD
 rf_misc_ram_lite_t dpd_res;
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 {
     int err = 0;
@@ -2011,6 +2624,53 @@ int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 
 }
 
+#define PATCH_VARGRP_MAGIC_NUM          0x47564150
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+
+int aicwf_patch_var_config_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    uint32_t rd_patch_addr, rd_var_magic_addr, rd_ext_flags_addr;
+    uint32_t rd_ext_flags_val, wr_ext_flags_val;
+    struct dbg_mem_read_cfm cfm;
+    if (chip_sub_id != 2) {
+        AICWFDBG(LOGERROR, "unsupport sub_id: %d\r\n", chip_sub_id);
+        return 0;
+    }
+    rd_patch_addr = ROM_FMAC_PATCH_ADDR;
+    rd_var_magic_addr = rd_patch_addr;
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, rd_var_magic_addr, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "var_magic rd fail: %d\r\n", ret);
+        return ret;
+    }
+    if (cfm.memdata != PATCH_VARGRP_MAGIC_NUM) {
+        AICWFDBG(LOGINFO, "old patch file: %s\r\n", RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
+        return 0;
+    }
+    rd_ext_flags_addr = rd_patch_addr + 4;
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, rd_ext_flags_addr, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "ext_flags rd fail: %d\r\n", ret);
+        return ret;
+    }
+    rd_ext_flags_val = cfm.memdata;
+    wr_ext_flags_val = cfm.memdata;
+    AICWFDBG(LOGINFO, "rd ext_flags: 0x%x\r\n", rd_ext_flags_val);
+    #ifdef CONFIG_POWER_LIMIT
+    wr_ext_flags_val = rd_ext_flags_val | USER_CHAN_MAX_TXPWR_EN_FLAG;
+    #endif
+    if (wr_ext_flags_val != rd_ext_flags_val) {
+        ret = rwnx_send_dbg_mem_write_req(rwnx_hw, rd_ext_flags_addr, wr_ext_flags_val);
+        if (ret) {
+            AICWFDBG(LOGERROR, "ext_flags wr fail: %d\r\n", ret);
+            return ret;
+        }
+        AICWFDBG(LOGINFO, "wr ext_flags: 0x%x\r\n", wr_ext_flags_val);
+    }
+    return ret;
+}
+
 //adap test
 extern int get_adap_test(void);
 //adap test
@@ -2141,11 +2801,21 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
 
         #if !defined(CONFIG_FPGA_VERIFICATION)
         if ((IS_CHIP_ID_H())) {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct_h);
+            txgain_cfg_array = (u32 *)txgain_map_femkct_h;
+            #else
             txgain_cfg_size = sizeof(txgain_map_h);
             txgain_cfg_array = (u32 *)txgain_map_h;
+            #endif
         } else {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct);
+            txgain_cfg_array = (u32 *)txgain_map_femkct;
+            #else
             txgain_cfg_size = sizeof(txgain_map);
             txgain_cfg_array = (u32 *)txgain_map;
+            #endif
         }
         ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_cfg_array);
         if (ret) {
@@ -2179,6 +2849,10 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
             if(ret){
                 printk("patch_tbl upload fail: err:%d\r\n", ret);
             }
+            ret = aicwf_patch_var_config_8800dc(rwnx_hw);
+            if (ret) {
+                printk("patch_var cfg fail: err:%d\r\n", ret);
+            }
         } else {
             printk("unsupported id: %d\n", chip_sub_id);
         }
@@ -2212,6 +2886,7 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 
 
 	if (testmode == FW_NORMAL_MODE) {
+        #if !defined(CONFIG_EXT_FEM_8800DCDW)
         if (IS_CHIP_ID_H()) {
             if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_h, 128)))
                 return -1;
@@ -2223,6 +2898,18 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
             if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw, 128)))
                 return -1;
         }
+        #else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+        {
+            ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+            ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+        }
+        #endif
 
 		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	0, (u8_l *)wifi_rxgain_table_24g_20m_8800dcdw, 256)))
 			return -1;
@@ -2253,6 +2940,14 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
                     return ret;
                 }
             }
+            #elif defined(CONFIG_LOFT_CALIB)
+            if (loft_res_local.bit_mask[1]) {
+                ret = aicwf_loft_result_apply_8800dc(rwnx_hw, &loft_res_local);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply loft res fail: %d\n", ret);
+                    return ret;
+                }
+            }
             #else
             {
                 ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
@@ -2282,8 +2977,32 @@ int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw)
     if (chip_sub_id == 0) {
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
     } else if (chip_sub_id == 1) {
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+		uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+		ret = rwnx_get_patch_addr_from_patch_table(rwnx_hw, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
+		//bt patch
+		printk("%s %x\n", __func__, fw_ram_patch_base_addr);
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, FW_8800DC_U02_ADID_ADDR, FW_ADID_BASE_NAME);
+		//fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02);
+		//bt patch table
+		ret = rwnx_patch_table_download(rwnx_hw, FW_PATCH_TABLE_NAME_U02);
+#endif
+		//wifi patch
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
     } else if (chip_sub_id == 2) {
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+		uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+		ret = rwnx_get_patch_addr_from_patch_table(rwnx_hw, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
+		//bt patch
+		printk("%s %x\n", __func__, fw_ram_patch_base_addr);
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, FW_8800DC_U02_ADID_ADDR, FW_ADID_BASE_NAME);
+		//fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02H);
+		//bt patch table
+		ret = rwnx_patch_table_download(rwnx_hw, FW_PATCH_TABLE_NAME_U02H);
+#endif
+		//wifi patch
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
     } else {
         printk("unsupported id: %d\n", chip_sub_id);
@@ -2303,7 +3022,7 @@ int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw)
     return ret;
 }
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out)
 {
     int ret = 0;
@@ -2479,7 +3198,7 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
         for (i = 0; i < ram_word_cnt; i++) {
             ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
             if (ret) {
-                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                AICWFDBG(LOGERROR, "dpd_high[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
                 return ret;
             }
             dpd_res->dpd_high[i] = cfm.memdata;
@@ -2490,7 +3209,7 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
         for (i = 0; i < ram_word_cnt; i++) {
             ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
             if (ret) {
-                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                AICWFDBG(LOGERROR, "loft_res[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
                 return ret;
             }
             dpd_res->loft_res[i] = cfm.memdata;
@@ -2623,6 +3342,117 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 #endif /* !CONFIG_FORCE_DPD_CALIB */
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t fw_addr, boot_type;
+    int valid_flag;
+    ret = aicwf_misc_ram_valid_check_8800dc(rwnx_hw, &valid_flag);
+    if (ret) {
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
+        return ret;
+    }
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
+    ret = aicwf_plat_calib_load_8800dc(rwnx_hw);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    /* fw start */
+    fw_addr = 0x00130009;
+    boot_type = HOST_START_APP_FNCALL;
+    AICWFDBG(LOGINFO, "Start app: %08x, %d\n", fw_addr, boot_type);
+    ret = rwnx_send_dbg_start_app_req(rwnx_hw, fw_addr, boot_type);
+    if (ret) {
+        AICWFDBG(LOGINFO, "start app fail: %d\n", ret);
+        return ret;
+    }
+    { // read loft res
+        const uint32_t cfg_base = 0x10164;
+        struct dbg_mem_read_cfm cfm;
+        uint32_t misc_ram_addr;
+        uint32_t ram_base_addr, ram_word_cnt;
+        int i;
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+            return ret;
+        }
+        misc_ram_addr = cfm.memdata;
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->bit_mask[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "loft_res[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->loft_res[i] = cfm.memdata;
+        }
+    }
+    return ret;
+}
+
+int aicwf_loft_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", loft_res->bit_mask[1]);
+    if (loft_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void loft_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
+    /* Copy loft_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", loft_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->bit_mask[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", loft_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    return ret;
+}
+#endif
+
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw){
     int size;
     u32 *dst=NULL;
@@ -2677,6 +3507,85 @@ int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw){
 
 }
 
+#ifdef CONFIG_POWER_LIMIT
+extern char country_code[];
+
+int rwnx_plat_powerlimit_load_8800dcdw(struct rwnx_hw *rwnx_hw, uint16_t chip_id)
+{
+    int size;
+    u32 *dst = NULL;
+    char *filename;
+    if (chip_id == PRODUCT_ID_AIC8800DC) {
+        filename = FW_POWERLIMIT_NAME_8800DC;
+    } else if (chip_id == PRODUCT_ID_AIC8800DW) {
+        filename = FW_POWERLIMIT_NAME_8800DW;
+    } else {
+        AICWFDBG(LOGERROR, "invalid chip_id: %d\n", chip_id);
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    /* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
+
+//Crystal provided by CPU (start)
+int set_bbpll_config(struct rwnx_hw *rwnx_hw){
+//    {0x40505010, 0x7C301010},//bbpll
+	int ret = 0;
+	struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+	//Read crystal provided by CPU or not.
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40500148, &rd_mem_addr_cfm);
+    if (ret) {
+		AICWFDBG(LOGERROR, "%x rd fail: %d\n", 0x40500148, ret);
+        return -1;
+    }
+
+	AICWFDBG(LOGDEBUG, "%s rd_mem_addr_cfm.memdata:%x \r\n", __func__, rd_mem_addr_cfm.memdata);
+
+	if(!(rd_mem_addr_cfm.memdata & 0x01)){
+		AICWFDBG(LOGINFO, "%s Crystal not provided by CPU \r\n", __func__);
+		return 0;
+	}else{
+		AICWFDBG(LOGINFO, "%s Crystal provided by CPU \r\n", __func__);
+		//Read 0x40505010 value to check bbpll set or not.
+		ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40505010, &rd_mem_addr_cfm);
+		if(ret < 0){
+			AICWFDBG(LOGERROR, "%s error ret_val:%d\r\n", __func__, ret);
+			return -1;
+		}
+
+		if((rd_mem_addr_cfm.memdata >> 29) == 3){
+			AICWFDBG(LOGERROR, "%s Not need to set \r\n", __func__);
+			return 0;
+		}else{
+			rd_mem_addr_cfm.memdata |= ((0x1 << 29) | (0x1 << 30));
+			rd_mem_addr_cfm.memdata &= (~(0x1 << 31));
+			rwnx_send_dbg_mem_write_req(rwnx_hw, 0x40505010, rd_mem_addr_cfm.memdata);
+		}
+	}
+	return 0;
+}
+//Crystal provided by CPU (end)
+
 
 void system_config_8800dc(struct rwnx_hw *rwnx_hw){
     int syscfg_num;
@@ -2706,6 +3615,14 @@ void system_config_8800dc(struct rwnx_hw *rwnx_hw){
 	AICWFDBG(LOGINFO, "chip_id=%x, chip_sub_id=%x\n", chip_id, chip_sub_id);
 
 
+	//Crystal provided by CPU (start)
+	ret = set_bbpll_config(rwnx_hw);
+    if (ret) {
+		AICWFDBG(LOGERROR, "set_bbpll_config fail: %d\n", ret);
+        return;
+    }
+	//Crystal provided by CPU (end)
+
 	ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40500010, &rd_mem_addr_cfm);
 	printk("[0x40500010]=%x\n", rd_mem_addr_cfm.memdata);
 	if (ret) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
index 1939bda48..c0e53cb95 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
@@ -1,6 +1,6 @@
 #include <linux/types.h>
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 typedef struct {
     uint32_t bit_mask[3];
     uint32_t reserved;
@@ -22,17 +22,25 @@ typedef struct {
 
 #define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
 #define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+#endif
 
+#ifdef CONFIG_DPD
 extern rf_misc_ram_lite_t dpd_res;
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+extern rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename);
 void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw);
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out);
 int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw);
+#endif
+#ifdef CONFIG_DPD
 int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
 int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
 #ifndef CONFIG_FORCE_DPD_CALIB
@@ -40,8 +48,15 @@ int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dp
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
 #endif
 #endif
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res);
+int aicwf_loft_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res);
+#endif
 int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800dcdw(struct rwnx_hw *rwnx_hw, uint16_t chip_id);
+#endif
 void system_config_8800dc(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
index 12fdca688..be72268e1 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
@@ -1,52 +1,52 @@
-
-
-#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
-
-
-
-/* message levels */
-#define LOGERROR		0x0001
-#define LOGINFO			0x0002
-#define LOGTRACE		0x0004
-#define LOGDEBUG		0x0008
-#define LOGDATA			0x0010
-
-extern int aicwf_dbg_level;
-void rwnx_data_dump(char* tag, void* data, unsigned long len);
-
-#define AICWF_LOG		"AICWFDBG("
-
-#define AICWFDBG(level, args, arg...)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG#level")\t" args, ##arg); \
-	}	\
-} while (0)
-
-#define RWNX_DBG(fmt, ...)	\
-do {	\
-	if (aicwf_dbg_level & LOGTRACE) {	\
-		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
-	}	\
-} while (0)
-
-
-
-#if 0
-#define RWNX_DBG(fmt, ...)	\
-	do {	\
-		if (aicwf_dbg_level & LOGTRACE) {	\
-			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
-		}	\
-	} while (0)
-#define AICWFDBG(args, level)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG"(%s)\t" ,#level);	\
-		printf args;	\
-	}	\
-} while (0)
-#endif
-
-
-
+
+
+#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
+
+
+
+/* message levels */
+#define LOGERROR		0x0001
+#define LOGINFO			0x0002
+#define LOGTRACE		0x0004
+#define LOGDEBUG		0x0008
+#define LOGDATA			0x0010
+
+extern int aicwf_dbg_level;
+void rwnx_data_dump(char* tag, void* data, unsigned long len);
+
+#define AICWF_LOG		"AICWFDBG("
+
+#define AICWFDBG(level, args, arg...)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG#level")\t" args, ##arg); \
+	}	\
+} while (0)
+
+#define RWNX_DBG(fmt, ...)	\
+do {	\
+	if (aicwf_dbg_level & LOGTRACE) {	\
+		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
+	}	\
+} while (0)
+
+
+
+#if 0
+#define RWNX_DBG(fmt, ...)	\
+	do {	\
+		if (aicwf_dbg_level & LOGTRACE) {	\
+			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
+		}	\
+	} while (0)
+#define AICWFDBG(args, level)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG"(%s)\t" ,#level);	\
+		printf args;	\
+	}	\
+} while (0)
+#endif
+
+
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
index dc805a53d..a08927fe6 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
@@ -1,27 +1,27 @@
-
-#ifndef _AICWF_RX_PREALLOC_H_
-#define _AICWF_RX_PREALLOC_H_
-
-#ifdef CONFIG_PREALLOC_RX_SKB
-
-struct rx_buff {
-    struct list_head queue;
-    unsigned char *data;
-    u32 len;
-    uint8_t *start;
-    uint8_t *end;
-    uint8_t *read;
-};
-
-struct aicwf_rx_buff_list {
-    struct list_head rxbuff_list;
-    atomic_t rxbuff_list_len;
-};
-
-extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
-extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
-extern int aicwf_prealloc_init(void);
-extern void aicwf_prealloc_exit(void);
-extern int aicwf_rxbuff_size_get(void);
-#endif
-#endif /* _AICWF_RX_PREALLOC_H_ */
+
+#ifndef _AICWF_RX_PREALLOC_H_
+#define _AICWF_RX_PREALLOC_H_
+
+#ifdef CONFIG_PREALLOC_RX_SKB
+
+struct rx_buff {
+    struct list_head queue;
+    unsigned char *data;
+    u32 len;
+    uint8_t *start;
+    uint8_t *end;
+    uint8_t *read;
+};
+
+struct aicwf_rx_buff_list {
+    struct list_head rxbuff_list;
+    atomic_t rxbuff_list_len;
+};
+
+extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
+extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
+extern int aicwf_prealloc_init(void);
+extern void aicwf_prealloc_exit(void);
+extern int aicwf_rxbuff_size_get(void);
+#endif
+#endif /* _AICWF_RX_PREALLOC_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
index 1a96f4523..f8e79cc24 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
@@ -23,7 +23,6 @@
 #ifdef CONFIG_INGENIC_T20
 #include "mach/jzmmc.h"
 #endif /* CONFIG_INGENIC_T20 */
-extern uint8_t scanning;
 
 #ifdef CONFIG_PLATFORM_ALLWINNER
 void platform_wifi_power_off(void);
@@ -433,8 +432,8 @@ int aicwf_sdio_sleep_allow(struct aic_sdio_dev *sdiodev)
         }
     }
 
-    sdio_info("sleep: %d, %d\n", sdiodev->state, scanning);
-    if (sdiodev->state == SDIO_ACTIVE_ST  && !scanning && !rwnx_hw->is_p2p_alive \
+    sdio_info("sleep: %d, %d\n", sdiodev->state, rwnx_hw->scanning);
+    if (sdiodev->state == SDIO_ACTIVE_ST  && !rwnx_hw->scanning && !rwnx_hw->is_p2p_alive \
                 && !rwnx_hw->is_p2p_connected && dhcped) {
         down(&sdiodev->pwrctl_wakeup_sema);
         if (rwnx_hw->vif_started) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
index 2ad2b1931..480fd0768 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
@@ -188,7 +188,7 @@ int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
 				case TCPOPT_WINDOW:
 					if (*ptr < 15)
 						*win_scale = (1 << (*ptr));
-					printk("%d\n",*win_scale);
+					//printk("%d\n",*win_scale);
 					break;
 				default:
 					drop = 2;
@@ -442,7 +442,7 @@ int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
 	struct tcp_ack_msg *ack;
 	int ret = 0;
 	struct msg_buf *drop_msg = NULL;
-	struct msg_buf * send_msg = NULL;
+	//struct msg_buf * send_msg = NULL;
 	//printk("",);
 	write_seqlock_bh(&ack_info->seqlock);
 
@@ -470,8 +470,8 @@ int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
 				  (ack_info->drop_cnt >=
 				   atomic_read(&ack_m->max_drop_cnt)))){
 			ack_info->drop_cnt = 0;
-			send_msg = new_msgbuf;
-			ack_info->in_send_msg = send_msg;
+			//send_msg = new_msgbuf;
+			ack_info->in_send_msg = new_msgbuf;
 			del_timer(&ack_info->timer);
 		}else{
 			ret = 1;
@@ -550,9 +550,6 @@ int filter_send_tcp_ack(struct rwnx_hw *priv,
 	struct tcp_ack_info *ack_info;
 	struct tcp_ack_manage *ack_m = &priv->ack_m;
 
-	if (plen > MAX_TCP_ACK)
-		return 0;
-
 	tcp_ack_update(ack_m);
 	drop = tcp_check_ack(buf, &ack_msg, &win_scale);
 //	printk("drop:%d win_scale:%d",drop,win_scale);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
index ff7f11d91..542023fc5 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
@@ -27,26 +27,7 @@ struct msg_buf {
 	//struct list_head list;
 	struct sk_buff *skb;
 	struct rwnx_vif *rwnx_vif;
-
 	/* data just tx cmd use,not include the head */
-	/*void *data;
-	void *tran_data;
-	unsigned long pcie_addr;
-	u8 type;
-	u8 mode;
-	u16 len;
-	unsigned long timeout;*/
-	/* marlin 2 */
-	/*unsigned int fifo_id;
-	struct sprdwl_msg_list *msglist;*/
-	/* marlin 3 */
-	/*unsigned char buffer_type;
-	struct sprdwl_xmit_msg_list *xmit_msg_list;
-	unsigned char msg_type;
-
-	unsigned long last_time;
-	u8 ctxt_id;*/
-
 };
 
 struct tcp_ack_msg {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 2b9ebf4bf..b8484215a 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -108,8 +108,7 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
     init_completion(&bus_if->bustx_trgg);
     init_completion(&bus_if->busrx_trgg);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe) {
 		init_completion(&bus_if->msg_busrx_trgg);
 	}
 #endif
@@ -139,8 +138,8 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 #endif
 	
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe)
+	{
 		bus_if->msg_busrx_thread = kthread_run(usb_msg_busrx_thread, (void *)bus_if->bus_priv.usb->rx_priv, "aicwf_msg_busrx_thread");
 	}
 #endif
@@ -175,8 +174,7 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
     }
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe){
 		if (IS_ERR(bus_if->msg_busrx_thread)) {
 			bus_if->msg_busrx_thread  = NULL;
 			txrx_err("aicwf_msg_busrx_thread run fail\n");
@@ -223,7 +221,7 @@ void aicwf_bus_deinit(struct device *dev)
     }else{
     	AICWFDBG(LOGINFO, "%s g_rwnx_plat->enabled is false\r\n", __func__);
 	}
-    	
+
 #endif
 #ifdef AICWF_SDIO_SUPPORT
     sdiodev =bus_if->bus_priv.sdio;
@@ -259,7 +257,7 @@ void aicwf_bus_deinit(struct device *dev)
     rwnx_cmd_mgr_deinit(&usb->cmd_mgr);
 
 #ifdef CONFIG_TX_TASKLET//AIDEN tasklet
-		tasklet_kill(&usb->xmit_tasklet);
+	tasklet_kill(&usb->xmit_tasklet);
 #endif
 
 	AICWFDBG(LOGINFO, "%s Exit \n", __func__);
@@ -331,7 +329,11 @@ static bool aicwf_another_ptk_1(struct rx_buff *buffer)
     u8 *read = buffer->read;
     u16 aggr_len = 0;
 
-    if(read == NULL || read >= buffer->end) {
+    if(read == NULL || read >= (buffer->end - 2)) {
+        return false;
+    }
+
+    if(buffer->len < 2) {
         return false;
     }
 
@@ -348,7 +350,7 @@ static bool aicwf_another_ptk(struct sk_buff *skb)
 	u8 *data;
 	u16 aggr_len = 0;
 
-	if (skb->data == NULL || skb->len == 0) {
+	if (skb->data == NULL || skb->len < 2) {
 		return false;
 	}
 	data = skb->data;
@@ -369,54 +371,55 @@ void rwnx_frame_parser(char* tag, char* data, unsigned long len);
 #ifdef CONFIG_RX_TASKLET
 int aicwf_tasklet_rxframes(struct aicwf_rx_priv *rx_priv)
 {
-
-		int ret = 0;
-		unsigned long flags = 0;
-		struct sk_buff *skb = NULL; /* Packet for event or data frames */
-		u16 pkt_len = 0;
-		//struct sk_buff *skb_inblock = NULL;
-		u16 aggr_len = 0, adjust_len = 0;
-		u8 *data = NULL;
-		u8_l *msg = NULL;
-	
-		while (1) {
-			//aicwf_usb_rx_submit_all_urb_(rx_priv->usbdev);
-			spin_lock_irqsave(&rx_priv->rxqlock, flags);
-			if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
-				usb_info("no more rxdata\n");
-				spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
-				break;
-			}
-			skb = aicwf_frame_dequeue(&rx_priv->rxq);		
-			spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
-			if (skb == NULL) {
-				txrx_err("skb_error\r\n");
-				break;
-			}
-			data = skb->data;
-			pkt_len = (*skb->data | (*(skb->data + 1) << 8));
-			//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
-			if (pkt_len > 1600) {
-				dev_kfree_skb(skb);
-				atomic_dec(&rx_priv->rx_cnt);
-					continue;
-			}
-	
-			if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+	int ret = 0;
+	unsigned long flags = 0;
+	struct sk_buff *skb = NULL; /* Packet for event or data frames */
+	u16 pkt_len = 0;
+	//struct sk_buff *skb_inblock = NULL;
+	u16 aggr_len = 0, adjust_len = 0;
+	u8 *data = NULL;
+	u8_l *msg = NULL;
+
+	while (1) {
+		//aicwf_usb_rx_submit_all_urb_(rx_priv->usbdev);
+		spin_lock_irqsave(&rx_priv->rxqlock, flags);
+		if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
+			usb_info("no more rxdata\n");
+			spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+			break;
+		}
+		skb = aicwf_frame_dequeue(&rx_priv->rxq);		
+		spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+		if (skb == NULL) {
+			txrx_err("skb_error\r\n");
+			break;
+		}
+		data = skb->data;
+		pkt_len = (*skb->data | (*(skb->data + 1) << 8));
+		//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+		if (pkt_len > skb->len) {
+			AICWFDBG(LOGERROR, "%s pkt_len:%d skb->len:%d\r\n", __func__, pkt_len, skb->len);
+			dev_kfree_skb(skb);
+			atomic_dec(&rx_priv->rx_cnt);
+			continue;
+		}
+#endif
+		if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
 #if 0
 			aggr_len = pkt_len + RX_HWHRD_LEN;
 			if (aggr_len & (RX_ALIGNMENT - 1))
 				adjust_len = roundup(aggr_len, RX_ALIGNMENT);
 			else
 				adjust_len = aggr_len;
-	
+
 			skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_ATOMIC);//8 is for ccmp mic or wep icv
 			if(skb_inblock == NULL){
 				txrx_err("no more space! skip!\n");
 				skb_pull(skb, adjust_len);
 				continue;
 			}
-	
+
 			skb_put(skb_inblock, aggr_len);
 			memcpy(skb_inblock->data, data, aggr_len);
 #if 0//AIDEN	
@@ -426,14 +429,14 @@ int aicwf_tasklet_rxframes(struct aicwf_rx_priv *rx_priv)
 			rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb, (void *)rx_priv);
 			///TODO: here need to add rx data process
 			//skb_pull(skb, adjust_len);
-			}
-			else { //  type : config
-				aggr_len = pkt_len;
-				if (aggr_len & (RX_ALIGNMENT - 1))
-					adjust_len = roundup(aggr_len, RX_ALIGNMENT);
-				else
-					adjust_len = aggr_len;
-	
+		}
+		else { //  type : config
+			aggr_len = pkt_len;
+			if (aggr_len & (RX_ALIGNMENT - 1))
+				adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+			else
+				adjust_len = aggr_len;
+
 			msg = kmalloc(aggr_len+4, GFP_ATOMIC);
 			if(msg == NULL){
 			txrx_err("no more space for msg!\n");
@@ -443,22 +446,23 @@ int aicwf_tasklet_rxframes(struct aicwf_rx_priv *rx_priv)
 				memcpy(msg, data, aggr_len + 4);
 			if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP)
 					rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
-	
+
 				if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
 					aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
 			skb_pull(skb, adjust_len+4);
 			kfree(msg);
 			dev_kfree_skb(skb);
-			}
-	
-			//dev_kfree_skb(skb);
-			atomic_dec(&rx_priv->rx_cnt);
 		}
-	
-		return ret;
+
+		//dev_kfree_skb(skb);
+		atomic_dec(&rx_priv->rx_cnt);
 	}
+
+	return ret;
+}
 #endif
 
+extern bool rx_urb_sched;
 int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 {
 #ifdef AICWF_SDIO_SUPPORT
@@ -580,16 +584,18 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                 data = buffer->read;
                 pkt_len = (*data | (*(data + 1) << 8));
                 //printk("%s cnt:%d pkt_len:%d \r\n", __func__, cnt, pkt_len);
-                if (pkt_len > 1600) {
-                    AICWFDBG(LOGERROR, "%s pkt_len > 1600 \r\n", __func__);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+                if (pkt_len > buffer->len) {
+                    AICWFDBG(LOGERROR, "%s pkt_len:%d buffer->len:%d\r\n", __func__, pkt_len, buffer->len);
                     aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
                     atomic_dec(&rx_priv->rx_cnt);
                     return -EBADE;
                 }
-               
+#endif
+
                 if((data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
-                	aggr_len = pkt_len + RX_HWHRD_LEN;
-                    
+                    aggr_len = pkt_len + RX_HWHRD_LEN;
+
                     skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);
                     if (skb_inblock == NULL) {
                         txrx_err("no more space! skip\n");
@@ -597,11 +603,12 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                         atomic_dec(&rx_priv->rx_cnt);
                         return -EBADE;
                     }
-                    
+
                     skb_put(skb_inblock, aggr_len);
                     memcpy(skb_inblock->data, data, aggr_len);
                     rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
                     buffer->read = buffer->read + aggr_len;
+                    buffer->len -= aggr_len;
                 }
                 else { //  type : config
                     aggr_len = pkt_len;
@@ -617,21 +624,26 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                         return -EBADE;
                     }
                     memcpy(msg, data, aggr_len + 4);
-            
+
                     if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
                         rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
-            
+
                     if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
                         aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
-            
+
                     if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
                         rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
 
                     buffer->read = buffer->read + (adjust_len + 4);
+                    buffer->len -= (adjust_len + 4);
                     kfree(msg);
                 }
             }
             aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+            if (rx_urb_sched) {
+                schedule_work(&rx_priv->usbdev->rx_urb_work);
+                rx_urb_sched = false;
+            }
             atomic_dec(&rx_priv->rx_cnt);
         }
     }else{
@@ -644,7 +656,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
             }
             buffer = rxbuff_dequeue(&rx_priv->rxq);
             spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
-            
+
             if (buffer == NULL) {
                 txrx_err("skb_error\r\n");
                 ASSERT_ERR(1);
@@ -653,12 +665,14 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
             data = buffer->data;
             pkt_len = (*data | (*(data + 1) << 8));
             //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
-            if (pkt_len > 1600) {
+#ifndef CONFIG_USB_RX_REASSEMBLE
+            if (pkt_len > buffer->len) {
+                AICWFDBG(LOGERROR, "%s pkt_len:%d buffer->len:%d\r\n", __func__, pkt_len, buffer->len);
                 aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
                 atomic_dec(&rx_priv->rx_cnt);
                 continue;
             }
-        
+#endif
             if((data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
                 skb_inblock = __dev_alloc_skb(pkt_len + RX_HWHRD_LEN + CCMP_OR_WEP_INFO, GFP_KERNEL);
                 if (skb_inblock == NULL) {
@@ -667,7 +681,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                     atomic_dec(&rx_priv->rx_cnt);
                     continue;
                 }
-                
+
                 skb_put(skb_inblock, pkt_len + RX_HWHRD_LEN);
                 memcpy(skb_inblock->data, data, pkt_len + RX_HWHRD_LEN);
                 rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
@@ -678,7 +692,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                     adjust_len = roundup(aggr_len, RX_ALIGNMENT);
                 else
                     adjust_len = aggr_len;
-        
+
                 msg = kmalloc(aggr_len+4, GFP_KERNEL);
                 if(msg == NULL){
                     txrx_err("no more space for msg!\n");
@@ -686,166 +700,176 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
                     return -EBADE;
                 }
                 memcpy(msg, data, aggr_len + 4);
-        
+
                 if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
                     rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
-        
+
                 if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
                     aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
-        
+
                 if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
                     rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
-        
+
                 kfree(msg);
             }
-            
+
             aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+            if (rx_urb_sched) {
+                schedule_work(&rx_priv->usbdev->rx_urb_work);
+                rx_urb_sched = false;
+            }
             atomic_dec(&rx_priv->rx_cnt);
         }
     }
 #else
-	if(aicwf_usb_rx_aggr){
-	    while (1) {
-	        spin_lock_irqsave(&rx_priv->rxqlock, flags);
-	        if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
-	            usb_info("no more rxdata\n");
-	            spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
-	            break;
-	        }
-	        skb = aicwf_frame_dequeue(&rx_priv->rxq);
-	        spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
-
-	        if (skb == NULL) {
-	            txrx_err("skb_error\r\n");
-	            ASSERT_ERR(1);
-	            break;
-	        }
-	        while(aicwf_another_ptk(skb)) {
-	        cnt++;
-	        if (cnt > 30) {
-	            //printk("%s err, break %d\n", __func__, cnt);
-	            //break;
-	        }
-	        data = skb->data;
-	        pkt_len = (*skb->data | (*(skb->data + 1) << 8));
-	        //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
-	        if (pkt_len > 1600) {
-	            dev_kfree_skb(skb);
-	            atomic_dec(&rx_priv->rx_cnt);
-	                continue;
-	        }
-
-	        if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
-				aggr_len = pkt_len + RX_HWHRD_LEN;
-				adjust_len = aggr_len;
-	            skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);//8 is for ccmp mic or wep icv
-	            if(skb_inblock == NULL){
-	                txrx_err("no more space! skip!\n");
-	                skb_pull(skb, adjust_len);
-	                continue;
-	            }
+    if(aicwf_usb_rx_aggr){
+        while (1) {
+            spin_lock_irqsave(&rx_priv->rxqlock, flags);
+            if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
+                usb_info("no more rxdata\n");
+                spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+                break;
+            }
+            skb = aicwf_frame_dequeue(&rx_priv->rxq);
+            spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
 
-	            skb_put(skb_inblock, aggr_len);
-	            memcpy(skb_inblock->data, data, aggr_len);
-	            rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
+            if (skb == NULL) {
+                txrx_err("skb_error\r\n");
+                ASSERT_ERR(1);
+                break;
+            }
+            while(aicwf_another_ptk(skb)) {
+                cnt++;
+                if (cnt > 30) {
+                    //printk("%s err, break %d\n", __func__, cnt);
+                    //break;
+                }
+                data = skb->data;
+                pkt_len = (*skb->data | (*(skb->data + 1) << 8));
+                //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+                if (pkt_len > skb->len) {
+                    AICWFDBG(LOGERROR, "%s pkt_len:%d skb->len:%d\r\n", __func__, pkt_len, skb->len);
+                    //dev_kfree_skb(skb);
+                    //atomic_dec(&rx_priv->rx_cnt);
+                    //continue;
+                    break;
+                }
+#endif
+                if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+                    aggr_len = pkt_len + RX_HWHRD_LEN;
+                    adjust_len = aggr_len;
+                    skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);//8 is for ccmp mic or wep icv
+                    if(skb_inblock == NULL){
+                        txrx_err("no more space! skip!\n");
+                        skb_pull(skb, adjust_len);
+                        continue;
+                    }
 
-				///TODO: here need to add rx data process
+                    skb_put(skb_inblock, aggr_len);
+                    memcpy(skb_inblock->data, data, aggr_len);
+                    rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
 
-				skb_pull(skb, adjust_len);
+                    ///TODO: here need to add rx data process
 
-	        }
-	        else { //  type : config
-	            aggr_len = pkt_len;
-	            if (aggr_len & (RX_ALIGNMENT - 1))
-	                adjust_len = roundup(aggr_len, RX_ALIGNMENT);
-	            else
-	                adjust_len = aggr_len;
+                    skb_pull(skb, adjust_len);
 
-	            msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
-	            if(msg == NULL){
-	                txrx_err("no more space for msg!\n");
-	                aicwf_dev_skb_free(skb);
-	                return -EBADE;
-	            }
-	            memcpy(msg, data, aggr_len + 4);
+                }
+                else { //  type : config
+                    aggr_len = pkt_len;
+                    if (aggr_len & (RX_ALIGNMENT - 1))
+                        adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+                    else
+                        adjust_len = aggr_len;
 
-	            if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
-	                rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+                    msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
+                    if(msg == NULL){
+                        txrx_err("no more space for msg!\n");
+                        aicwf_dev_skb_free(skb);
+                        return -EBADE;
+                    }
+                    memcpy(msg, data, aggr_len + 4);
 
-	            if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
-	                aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+                    if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+                        rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
 
-	            if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
-	                rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+                    if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+                        aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
 
+                    if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+                        rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
 
-	            skb_pull(skb, adjust_len+4);
-	            kfree(msg);
 
-				}
-			}
-			dev_kfree_skb(skb);
-	        atomic_dec(&rx_priv->rx_cnt);
-	    }
-	}else{
-	    while (1) {
-	        spin_lock_irqsave(&rx_priv->rxqlock, flags);
-	        if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
-	            usb_info("no more rxdata\n");
-	            spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
-	            break;
-	        }
-	        skb = aicwf_frame_dequeue(&rx_priv->rxq);
-	        spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
-
-	        if (skb == NULL) {
-	            txrx_err("skb_error\r\n");
-	            ASSERT_ERR(1);
-	            break;
-	        }
-	        data = skb->data;
-	        pkt_len = (*skb->data | (*(skb->data + 1) << 8));
-	        //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
-	        if (pkt_len > 1600) {
-	            dev_kfree_skb(skb);
-	            atomic_dec(&rx_priv->rx_cnt);
-	                continue;
-	        }
-
-	        if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
-				rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb, (void *)rx_priv);
-	        }
-	        else { //  type : config
-	            aggr_len = pkt_len;
-	            if (aggr_len & (RX_ALIGNMENT - 1))
-	                adjust_len = roundup(aggr_len, RX_ALIGNMENT);
-	            else
-	                adjust_len = aggr_len;
-
-	            msg = kmalloc(aggr_len+4, GFP_KERNEL);
-	            if(msg == NULL){
-	                txrx_err("no more space for msg!\n");
-	                aicwf_dev_skb_free(skb);
-	                return -EBADE;
-	            }
-	            memcpy(msg, data, aggr_len + 4);
-
-	            if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
-	                rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
-
-	            if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
-	                aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
-
-	            if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
-	                rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
-
-	            skb_pull(skb, adjust_len+4);
-	            kfree(msg);
-				dev_kfree_skb(skb);
-	        }
-	        atomic_dec(&rx_priv->rx_cnt);
-	    }
-	}
+                    skb_pull(skb, adjust_len+4);
+                    kfree(msg);
+
+                }
+            }
+            dev_kfree_skb(skb);
+            atomic_dec(&rx_priv->rx_cnt);
+        }
+    }else{
+        while (1) {
+            spin_lock_irqsave(&rx_priv->rxqlock, flags);
+            if(aicwf_is_framequeue_empty(&rx_priv->rxq)) {
+                usb_info("no more rxdata\n");
+                spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+                break;
+            }
+            skb = aicwf_frame_dequeue(&rx_priv->rxq);
+            spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+
+            if (skb == NULL) {
+                txrx_err("skb_error\r\n");
+                ASSERT_ERR(1);
+                break;
+            }
+            data = skb->data;
+            pkt_len = (*skb->data | (*(skb->data + 1) << 8));
+            //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+            if (pkt_len > skb->len) {
+                AICWFDBG(LOGERROR, "%s pkt_len:%d skb->len:%d\r\n", __func__, pkt_len, skb->len);
+                dev_kfree_skb(skb);
+                atomic_dec(&rx_priv->rx_cnt);
+                continue;
+            }
+#endif
+
+            if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+                rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb, (void *)rx_priv);
+            }
+            else { //  type : config
+                aggr_len = pkt_len;
+                if (aggr_len & (RX_ALIGNMENT - 1))
+                    adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+                else
+                    adjust_len = aggr_len;
+
+                msg = kmalloc(aggr_len+4, GFP_KERNEL);
+                if(msg == NULL){
+                    txrx_err("no more space for msg!\n");
+                    aicwf_dev_skb_free(skb);
+                    return -EBADE;
+                }
+                memcpy(msg, data, aggr_len + 4);
+
+                if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+                    rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+
+                if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+                    aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+
+                if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+                    rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+
+                skb_pull(skb, adjust_len+4);
+                kfree(msg);
+                dev_kfree_skb(skb);
+            }
+            atomic_dec(&rx_priv->rx_cnt);
+        }
+    }
 #endif
 
     return ret;
@@ -882,7 +906,7 @@ int aicwf_process_msg_rxframes(struct aicwf_rx_priv *rx_priv)
         pkt_len = (*skb->data | (*(skb->data + 1) << 8));
         //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
 #if 0 //amsdu > 1600
-	if (pkt_len > 1600) {
+        if (pkt_len > 1600) {
             dev_kfree_skb(skb);
             atomic_dec(&rx_priv->rx_cnt);
                 continue;
@@ -965,7 +989,7 @@ static struct recv_msdu *aicwf_rxframe_queue_init(struct list_head *q, int qsize
     for (i = 0; i < qsize; i++) {
         INIT_LIST_HEAD(&req->rxframe_list);
         list_add(&req->rxframe_list, q);
-        req->len = 0;
+        //req->len = 0;
         req++;
     }
 
@@ -998,8 +1022,7 @@ struct aicwf_rx_priv *aicwf_rx_init(void *arg)
     atomic_set(&rx_priv->rx_cnt, 0);
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
     	aicwf_frame_queue_init(&rx_priv->msg_rxq, 1, MAX_RXQLEN);
     	spin_lock_init(&rx_priv->msg_rxqlock);
     	atomic_set(&rx_priv->msg_rx_cnt, 0);
@@ -1065,8 +1088,7 @@ void aicwf_rx_deinit(struct aicwf_rx_priv* rx_priv)
         rx_priv->usbdev->bus_if->busrx_thread = NULL;
     }
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
 		if (rx_priv->usbdev->bus_if->msg_busrx_thread) {
 			complete_all(&rx_priv->usbdev->bus_if->msg_busrx_trgg);
 			kthread_stop(rx_priv->usbdev->bus_if->msg_busrx_thread);
@@ -1074,12 +1096,19 @@ void aicwf_rx_deinit(struct aicwf_rx_priv* rx_priv)
 		}
 	}
 #endif
+#ifdef CONFIG_USB_RX_REASSEMBLE
+    if (rx_priv->rx_reassemble_skb) {
+        aicwf_dev_skb_free(rx_priv->rx_reassemble_skb);
+    }
+    if (rx_priv->rx_msg_reassemble_skb) {
+        aicwf_dev_skb_free(rx_priv->rx_msg_reassemble_skb);
+    }
+#endif
 
 #endif
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
 		aicwf_frame_queue_flush(&rx_priv->msg_rxq);
 	}
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
index 552398806..3e40e389d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
@@ -152,6 +152,7 @@ struct aicwf_tx_priv {
 };
 
 
+#define DEFRAG_MAX_WAIT         40 //100
 #ifdef AICWF_RX_REORDER
 #define MAX_REORD_RXFRAME       250
 #define REORDER_UPDATE_TIME     500//50
@@ -178,13 +179,21 @@ struct reord_ctrl_info {
 };
 
 struct recv_msdu {
-     struct sk_buff  *pkt;
-     u8 tid;
-	 u8 forward;
-     u16 seq_num;
-     uint len;
-     u8 *rx_data;
-     //for pending rx reorder list
+    struct sk_buff  *pkt;
+    u8 tid;
+    u8 forward;
+    u16 seq_num;
+    //uint len;
+    u8 is_amsdu;
+    u8 is_ap_reord;
+    u8 ap_fwd_cnt;
+    u8 ap_resend_cnt;
+    u8 *rx_data;
+    struct sk_buff *first_fwd_skb;
+    struct sk_buff *last_fwd_skb;
+    struct sk_buff *first_resend_skb;
+    struct sk_buff *last_resend_skb;
+    //for pending rx reorder list
     struct list_head reord_pending_list;
     //for total frame list, when rxframe from busif, dequeue, when submit frame to net, enqueue
     struct list_head rxframe_list;
@@ -209,6 +218,19 @@ struct aicwf_rx_priv {
 #else
 	struct frame_queue rxq;
 #endif
+#ifdef CONFIG_USB_RX_REASSEMBLE
+    struct sk_buff *rx_reassemble_skb;
+    u32 rx_reassemble_total_len;
+    u32 rx_reassemble_cur_len;
+    u32 rx_reassemble_total_frags;
+    u32 rx_reassemble_cur_frags;
+
+    struct sk_buff *rx_msg_reassemble_skb;
+    u32 rx_msg_reassemble_total_len;
+    u32 rx_msg_reassemble_cur_len;
+    u32 rx_msg_reassemble_total_frags;
+    u32 rx_msg_reassemble_cur_frags;
+#endif
 
 #ifdef CONFIG_USB_MSG_IN_EP
 	atomic_t msg_rx_cnt;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
index 9d881140d..c086988fe 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
@@ -36,7 +36,7 @@ extern atomic_t aicwf_deinit_atomic;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
 #include "uapi/linux/sched/types.h"
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 #include "linux/sched/types.h"
 #else
 #include "linux/sched/rt.h"
@@ -54,6 +54,8 @@ bool aicwf_usb_rx_aggr = true;
 bool aicwf_usb_rx_aggr = false;
 #endif
 atomic_t rx_urb_cnt;
+bool rx_urb_sched = false;
+u32 aicwf_usb_max_pkt_size = AICWF_USB_MAX_PKT_SIZE;
 
 void aicwf_usb_tx_flowctrl(struct rwnx_hw *rwnx_hw, bool state)
 {
@@ -154,23 +156,23 @@ static void aicwf_usb_msg_rx_buf_put(struct aic_usb_dev *usb_dev, struct aicwf_u
 
 void rwnx_stop_sta_all_queues(struct rwnx_sta *sta, struct rwnx_hw *rwnx_hw)
 {
-        u8 tid;
-         struct rwnx_txq *txq;
-         for(tid=0; tid<8; tid++) {
-                 txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
-                 netif_stop_subqueue(txq->ndev, txq->ndev_idx);
-         }
- }
+    u8 tid;
+    struct rwnx_txq *txq;
+    for(tid=0; tid<8; tid++) {
+        txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+        netif_stop_subqueue(txq->ndev, txq->ndev_idx);
+    }
+}
 
 void rwnx_wake_sta_all_queues(struct rwnx_sta *sta, struct rwnx_hw *rwnx_hw)
 {
-        u8 tid;
-         struct rwnx_txq *txq;
-         for(tid=0; tid<8; tid++) {
-                 txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
-                 netif_wake_subqueue(txq->ndev, txq->ndev_idx);
-         }
- }
+    u8 tid;
+    struct rwnx_txq *txq;
+    for(tid=0; tid<8; tid++) {
+        txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+        netif_wake_subqueue(txq->ndev, txq->ndev_idx);
+    }
+}
 
 static void usb_txc_sta_flowctrl(struct aicwf_usb_buf *usb_buf, struct aic_usb_dev *usb_dev)
 {
@@ -220,6 +222,7 @@ static void aicwf_usb_tx_complete(struct urb *urb)
 #ifdef CONFIG_USB_ALIGN_DATA
 	if(usb_buf->usb_align_data) {
 		kfree(usb_buf->usb_align_data);
+        usb_buf->usb_align_data = NULL;
 	}
 #endif
 #ifndef CONFIG_USB_TX_AGGR
@@ -256,68 +259,68 @@ void aicwf_usb_rx_submit_all_urb_(struct aic_usb_dev *usb_dev);
 
 #ifdef CONFIG_PREALLOC_RX_SKB
 static void aicwf_usb_rx_complete(struct urb *urb)
-    {
-        struct aicwf_usb_buf *usb_buf = (struct aicwf_usb_buf *) urb->context;
-        struct aic_usb_dev *usb_dev = usb_buf->usbdev;
-        struct aicwf_rx_priv* rx_priv = usb_dev->rx_priv;
-        struct rx_buff *rx_buff = NULL;
-        unsigned long flags = 0;
-    
-        rx_buff = usb_buf->rx_buff;
-        usb_buf->rx_buff = NULL;
-    
-        atomic_dec(&rx_urb_cnt);
-        if(atomic_read(&rx_urb_cnt) < 10){
-            AICWFDBG(LOGDEBUG, "%s %d \r\n", __func__, atomic_read(&rx_urb_cnt));
-            //printk("%s %d \r\n", __func__, atomic_read(&rx_urb_cnt));
-        }
+{
+    struct aicwf_usb_buf *usb_buf = (struct aicwf_usb_buf *) urb->context;
+    struct aic_usb_dev *usb_dev = usb_buf->usbdev;
+    struct aicwf_rx_priv* rx_priv = usb_dev->rx_priv;
+    struct rx_buff *rx_buff = NULL;
+    unsigned long flags = 0;
+
+    rx_buff = usb_buf->rx_buff;
+    usb_buf->rx_buff = NULL;
+
+    atomic_dec(&rx_urb_cnt);
+    if(atomic_read(&rx_urb_cnt) < 10){
+        AICWFDBG(LOGDEBUG, "%s %d \r\n", __func__, atomic_read(&rx_urb_cnt));
+        //printk("%s %d \r\n", __func__, atomic_read(&rx_urb_cnt));
+    }
+
+    if(!usb_dev->rwnx_hw){
+        aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
+        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+        AICWFDBG(LOGERROR, "usb_dev->rwnx_hw is not ready \r\n");
+        return;
+    }
+
+    if (urb->actual_length > urb->transfer_buffer_length) {
+        aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
+        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+        aicwf_usb_rx_submit_all_urb_(usb_dev);
+        return;
+    }
+
+    if (urb->status != 0 || !urb->actual_length) {
+        aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
+        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+        if(urb->status < 0){
+            AICWFDBG(LOGDEBUG, "%s urb->status:%d \r\n", __func__, urb->status);
+
+            if(g_rwnx_plat->wait_disconnect_cb == false){
+                g_rwnx_plat->wait_disconnect_cb = true;
+                if(atomic_read(&aicwf_deinit_atomic) > 0){
+                    atomic_set(&aicwf_deinit_atomic, 0);
+                    down(&aicwf_deinit_sem);
+                    AICWFDBG(LOGINFO, "%s need to wait for disconnect callback \r\n", __func__);
+                }else{
+                    g_rwnx_plat->wait_disconnect_cb = false;
+                }
+            }
 
-        if(!usb_dev->rwnx_hw){
-            aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
-            aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-            AICWFDBG(LOGERROR, "usb_dev->rwnx_hw is not ready \r\n");
             return;
-        }
-    
-        if (urb->actual_length > urb->transfer_buffer_length) {
-            aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
-            aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+        }else{
+            //schedule_work(&usb_dev->rx_urb_work);
             aicwf_usb_rx_submit_all_urb_(usb_dev);
             return;
         }
-    
-        if (urb->status != 0 || !urb->actual_length) {
-            aicwf_prealloc_rxbuff_free(rx_buff, &rx_priv->rxbuff_lock);
-            aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-            if(urb->status < 0){
-                AICWFDBG(LOGDEBUG, "%s urb->status:%d \r\n", __func__, urb->status);
-    
-                if(g_rwnx_plat->wait_disconnect_cb == false){
-                    g_rwnx_plat->wait_disconnect_cb = true;
-                    if(atomic_read(&aicwf_deinit_atomic) > 0){
-                        atomic_set(&aicwf_deinit_atomic, 0);
-                        down(&aicwf_deinit_sem);
-                        AICWFDBG(LOGINFO, "%s need to wait for disconnect callback \r\n", __func__);
-                    }else{
-                        g_rwnx_plat->wait_disconnect_cb = false;
-                    }
-                }
-    
-                return;
-            }else{
-                //schedule_work(&usb_dev->rx_urb_work);
-                aicwf_usb_rx_submit_all_urb_(usb_dev);
-                return;
-            }
-        }
-    
+    }
+
     if (usb_dev->state == USB_UP_ST) {
         spin_lock_irqsave(&rx_priv->rxqlock, flags);
-        if (aicwf_usb_rx_aggr) {
-	        rx_buff->len = urb->actual_length;
+        //if (aicwf_usb_rx_aggr) {
+            rx_buff->len = urb->actual_length;
             //printk("%s rx_buff->len:%d \r\n", __func__, rx_buff->len);
-        }
-        
+        //}
+
         if(!aicwf_rxbuff_enqueue(usb_dev->dev, &rx_priv->rxq, rx_buff)){
             spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
             usb_err("rx_priv->rxq is over flow!!!\n");
@@ -328,7 +331,7 @@ static void aicwf_usb_rx_complete(struct urb *urb)
         }
         spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
         atomic_inc(&rx_priv->rx_cnt);
-            
+
         if(atomic_read(&rx_priv->rx_cnt) == 1){
             complete(&rx_priv->usbdev->bus_if->busrx_trgg);
         }
@@ -367,6 +370,7 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 	}
 
     if (urb->actual_length > urb->transfer_buffer_length) {
+        usb_err("urb_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
         aicwf_dev_skb_free(skb);
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
         aicwf_usb_rx_submit_all_urb_(usb_dev);
@@ -408,10 +412,136 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 
         skb_put(skb, urb->actual_length);
 
-        spin_lock_irqsave(&rx_priv->rxqlock, flags);
         if (aicwf_usb_rx_aggr) {
-	    skb->len = urb->actual_length;
+            skb->len = urb->actual_length;
+        } else {
+#ifdef CONFIG_USB_RX_REASSEMBLE
+            bool pkt_check = false;
+            if (rx_priv->rx_reassemble_skb) {
+                u32 frag_len = skb->len;
+                struct sk_buff *reassemble_skb = rx_priv->rx_reassemble_skb;
+                bool reassemble_valid = false;
+                bool reassemble_done = false;
+                if ((rx_priv->rx_reassemble_cur_frags + 1) == rx_priv->rx_reassemble_total_frags) {
+                    if ((rx_priv->rx_reassemble_cur_len + frag_len) == rx_priv->rx_reassemble_total_len) {
+                        reassemble_valid = true;
+                        reassemble_done = true;
+                    }
+                } else {
+                    if (frag_len == aicwf_usb_max_pkt_size) {
+                        reassemble_valid = true;
+                    }
+                }
+
+                if (reassemble_valid) {
+                    memcpy((reassemble_skb->data + reassemble_skb->len), skb->data, frag_len);
+                    skb_put(reassemble_skb, skb->len);
+                    rx_priv->rx_reassemble_cur_len += frag_len;
+                    rx_priv->rx_reassemble_cur_frags++;
+                    aicwf_dev_skb_free(skb);
+                    if (reassemble_done) {
+                        skb = reassemble_skb;
+                        rx_priv->rx_reassemble_skb = NULL;
+                        rx_priv->rx_reassemble_total_len = 0;
+                        rx_priv->rx_reassemble_cur_len = 0;
+                        rx_priv->rx_reassemble_total_frags = 0;
+                        rx_priv->rx_reassemble_cur_frags = 0;
+                    } else {
+                        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_rx_submit_all_urb_(usb_dev);
+                        return;
+                    }
+                } else {
+                    usb_err("invalid frag pkt, len=%u/%u/%u, frags=%u/%u\n", frag_len,
+                        rx_priv->rx_reassemble_cur_len, rx_priv->rx_reassemble_cur_len,
+                        rx_priv->rx_reassemble_cur_frags, rx_priv->rx_reassemble_total_frags);
+                    aicwf_dev_skb_free(reassemble_skb);
+                    rx_priv->rx_reassemble_skb = NULL;
+                    rx_priv->rx_reassemble_total_len = 0;
+                    rx_priv->rx_reassemble_cur_len = 0;
+                    rx_priv->rx_reassemble_total_frags = 0;
+                    rx_priv->rx_reassemble_cur_frags = 0;
+                    pkt_check = true;
+                }
+            } else {
+                pkt_check = true;
+            }
+
+            if (pkt_check) {
+                bool pkt_drop = false;
+                u8 type = skb->data[2];
+                u32 pkt_len = skb->data[0] | (skb->data[1] << 8);
+                if ((type & USB_TYPE_CFG) != USB_TYPE_CFG) {
+                    u32 pkt_total_len = pkt_len + RX_HWHRD_LEN;
+                    if ((pkt_total_len > aicwf_usb_max_pkt_size) && (skb->len == aicwf_usb_max_pkt_size)) {
+                        AICWFDBG(LOGINFO, "reassemble pkt, len=%u\n", pkt_total_len);
+                        struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                        if (reassemble_skb) {
+                            memcpy(reassemble_skb->data, skb->data, skb->len);
+                            skb_put(reassemble_skb, skb->len);
+                            rx_priv->rx_reassemble_skb = reassemble_skb;
+                            rx_priv->rx_reassemble_total_len = pkt_total_len;
+                            rx_priv->rx_reassemble_cur_len = skb->len;
+                            rx_priv->rx_reassemble_total_frags = ALIGN(pkt_total_len, aicwf_usb_max_pkt_size) / aicwf_usb_max_pkt_size;
+                            rx_priv->rx_reassemble_cur_frags = 1;
+                        } else {
+                            usb_err("reassemble pkt alloc fail, len=%u\n", pkt_total_len);
+                        }
+                        aicwf_dev_skb_free(skb);
+                        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_rx_submit_all_urb_(usb_dev);
+                        return;
+                    } else if (pkt_total_len != skb->len) {
+                        usb_err("invalid DATA, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else {
+                    if (type == USB_TYPE_CFG_CMD_RSP) {
+                        u32 pkt_total_len = ALIGN((pkt_len + 4), 4);
+                        if ((pkt_total_len > aicwf_usb_max_pkt_size) && (skb->len == aicwf_usb_max_pkt_size)) {
+                            AICWFDBG(LOGINFO, "reassemble pkt, len=%u\n", pkt_total_len);
+                            struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                            if (reassemble_skb) {
+                                memcpy(reassemble_skb->data, skb->data, skb->len);
+                                skb_put(reassemble_skb, skb->len);
+                                rx_priv->rx_reassemble_skb = reassemble_skb;
+                                rx_priv->rx_reassemble_total_len = pkt_total_len;
+                                rx_priv->rx_reassemble_cur_len = skb->len;
+                                rx_priv->rx_reassemble_total_frags = ALIGN(pkt_total_len, aicwf_usb_max_pkt_size) / aicwf_usb_max_pkt_size;
+                                rx_priv->rx_reassemble_cur_frags = 1;
+                            } else {
+                                usb_err("reassemble pkt alloc fail, len=%u\n", pkt_total_len);
+                            }
+                            aicwf_dev_skb_free(skb);
+                            aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                            aicwf_usb_rx_submit_all_urb_(usb_dev);
+                            return;
+                        } else if (pkt_total_len != skb->len) {
+                            usb_err("invalid CMD_RSP, len=%u/%u\n", pkt_len, skb->len);
+                            pkt_drop = true;
+                        }
+                    } else if (type == USB_TYPE_CFG_DATA_CFM) {
+                        if (!((pkt_len == 8) && (skb->len == 12))) {
+                            usb_err("invalid DATA_CFM, len=%u/%u\n", pkt_len, skb->len);
+                            pkt_drop = true;
+                        }
+                    } else {
+                        usb_err("invalid pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                }
+
+                if (pkt_drop) {
+                    aicwf_dev_skb_free(skb);
+                    aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                    aicwf_usb_rx_submit_all_urb_(usb_dev);
+                    return;
+                }
+            }
+#endif
         }
+
+        spin_lock_irqsave(&rx_priv->rxqlock, flags);
         if(!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->rxq, skb)){
             spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
             usb_err("rx_priv->rxq is over flow!!!\n");
@@ -457,6 +587,7 @@ static void aicwf_usb_msg_rx_complete(struct urb *urb)
     usb_buf->skb = NULL;
 
     if (urb->actual_length > urb->transfer_buffer_length) {
+        usb_err("usb_msg_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
         aicwf_dev_skb_free(skb);
         aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
 		aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
@@ -481,6 +612,109 @@ static void aicwf_usb_msg_rx_complete(struct urb *urb)
     if (usb_dev->state == USB_UP_ST) {
         skb_put(skb, urb->actual_length);
 
+#ifdef CONFIG_USB_RX_REASSEMBLE
+        bool pkt_check = false;
+        if (rx_priv->rx_msg_reassemble_skb) {
+            u32 frag_len = skb->len;
+            struct sk_buff *reassemble_skb = rx_priv->rx_msg_reassemble_skb;
+            bool reassemble_valid = false;
+            bool reassemble_done = false;
+            if ((rx_priv->rx_msg_reassemble_cur_frags + 1) == rx_priv->rx_msg_reassemble_total_frags) {
+                if ((rx_priv->rx_msg_reassemble_cur_len + frag_len) == rx_priv->rx_msg_reassemble_total_len) {
+                    reassemble_valid = true;
+                    reassemble_done = true;
+                }
+            } else {
+                if (frag_len == AICWF_USB_MSG_MAX_PKT_SIZE) {
+                    reassemble_valid = true;
+                }
+            }
+
+            if (reassemble_valid) {
+                memcpy((reassemble_skb->data + reassemble_skb->len), skb->data, frag_len);
+                skb_put(reassemble_skb, skb->len);
+                rx_priv->rx_msg_reassemble_cur_len += frag_len;
+                rx_priv->rx_msg_reassemble_cur_frags++;
+                aicwf_dev_skb_free(skb);
+                if (reassemble_done) {
+                    skb = reassemble_skb;
+                    rx_priv->rx_msg_reassemble_skb = NULL;
+                    rx_priv->rx_msg_reassemble_total_len = 0;
+                    rx_priv->rx_msg_reassemble_cur_len = 0;
+                    rx_priv->rx_msg_reassemble_total_frags = 0;
+                    rx_priv->rx_msg_reassemble_cur_frags = 0;
+                } else {
+                    aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                    aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                    return;
+                }
+            } else {
+                usb_err("invalid frag msg pkt, len=%u/%u/%u, frags=%u/%u\n", frag_len,
+                    rx_priv->rx_msg_reassemble_cur_len, rx_priv->rx_msg_reassemble_cur_len,
+                    rx_priv->rx_msg_reassemble_cur_frags, rx_priv->rx_msg_reassemble_total_frags);
+                aicwf_dev_skb_free(reassemble_skb);
+                rx_priv->rx_msg_reassemble_skb = NULL;
+                rx_priv->rx_msg_reassemble_total_len = 0;
+                rx_priv->rx_msg_reassemble_cur_len = 0;
+                rx_priv->rx_msg_reassemble_total_frags = 0;
+                rx_priv->rx_msg_reassemble_cur_frags = 0;
+                pkt_check = true;
+            }
+        } else {
+            pkt_check = true;
+        }
+
+        if (pkt_check) {
+            bool pkt_drop = false;
+            u8 type = skb->data[2];
+            u32 pkt_len = skb->data[0] | (skb->data[1] << 8);
+            if ((type & USB_TYPE_CFG) != USB_TYPE_CFG) {
+                usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);;
+                pkt_drop = true;
+            } else {
+                if (type == USB_TYPE_CFG_CMD_RSP) {
+                    u32 pkt_total_len = ALIGN((pkt_len + 4), 4);
+                    if ((pkt_total_len > AICWF_USB_MSG_MAX_PKT_SIZE) && (skb->len == AICWF_USB_MSG_MAX_PKT_SIZE)) {
+                        AICWFDBG(LOGINFO, "reassemble msg pkt, len=%u\n", pkt_total_len);
+                        struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                        if (reassemble_skb) {
+                            memcpy(reassemble_skb->data, skb->data, skb->len);
+                            skb_put(reassemble_skb, skb->len);
+                            rx_priv->rx_msg_reassemble_skb = reassemble_skb;
+                            rx_priv->rx_msg_reassemble_total_len = pkt_total_len;
+                            rx_priv->rx_msg_reassemble_cur_len = skb->len;
+                            rx_priv->rx_msg_reassemble_total_frags = ALIGN(pkt_total_len, AICWF_USB_MSG_MAX_PKT_SIZE) / AICWF_USB_MSG_MAX_PKT_SIZE;
+                            rx_priv->rx_msg_reassemble_cur_frags = 1;
+                        } else {
+                            usb_err("reassemble msg pkt alloc fail, len=%u\n", pkt_total_len);
+                        }
+                        aicwf_dev_skb_free(skb);
+                        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                        return;
+                    } else if (pkt_total_len != skb->len) {
+                        usb_err("invalid CMD_RSP, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else if (type == USB_TYPE_CFG_DATA_CFM) {
+                    if (!((pkt_len == 8) && (skb->len == 12))) {
+                        usb_err("invalid DATA_CFM, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else {
+                    usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);
+                    pkt_drop = true;
+                }
+            }
+            if (pkt_drop) {
+                aicwf_dev_skb_free(skb);
+                aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                return;
+            }
+        }
+#endif
+
         spin_lock_irqsave(&rx_priv->msg_rxqlock, flags);
         if(!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->msg_rxq, skb)){
             spin_unlock_irqrestore(&rx_priv->msg_rxqlock, flags);
@@ -520,9 +754,10 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
     rx_buff =  aicwf_prealloc_rxbuff_alloc(&usb_dev->rx_priv->rxbuff_lock);
 	if (rx_buff == NULL) {
 		AICWFDBG(LOGERROR, "failed to alloc rxbuff\r\n");
-        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-        return -1;
-    }
+		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+		rx_urb_sched = true;
+		return -1;
+	}
 	rx_buff->len = 0;
 	rx_buff->start = rx_buff->data;
 	rx_buff->read = rx_buff->start;
@@ -570,9 +805,9 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
     }
 
     if(aicwf_usb_rx_aggr){
-	skb = __dev_alloc_skb(AICWF_USB_AGGR_MAX_PKT_SIZE, GFP_ATOMIC/*GFP_KERNEL*/);
+        skb = __dev_alloc_skb(AICWF_USB_AGGR_MAX_PKT_SIZE, GFP_ATOMIC/*GFP_KERNEL*/);
     } else {
-	skb = __dev_alloc_skb(AICWF_USB_MAX_PKT_SIZE, GFP_ATOMIC/*GFP_KERNEL*/);
+        skb = __dev_alloc_skb(aicwf_usb_max_pkt_size, GFP_ATOMIC/*GFP_KERNEL*/);
     }
     if (!skb) {
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
@@ -581,10 +816,17 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 
     usb_buf->skb = skb;
 
-    usb_fill_bulk_urb(usb_buf->urb,
-        usb_dev->udev,
-        usb_dev->bulk_in_pipe,
-        skb->data, skb_tailroom(skb), aicwf_usb_rx_complete, usb_buf);
+    if (aicwf_usb_rx_aggr) {
+        usb_fill_bulk_urb(usb_buf->urb,
+            usb_dev->udev,
+            usb_dev->bulk_in_pipe,
+            skb->data, AICWF_USB_AGGR_MAX_PKT_SIZE, aicwf_usb_rx_complete, usb_buf);
+    } else {
+        usb_fill_bulk_urb(usb_buf->urb,
+            usb_dev->udev,
+            usb_dev->bulk_in_pipe,
+            skb->data, aicwf_usb_max_pkt_size, aicwf_usb_rx_complete, usb_buf);
+    }
 
     usb_buf->usbdev = usb_dev;
 
@@ -598,10 +840,10 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
-	    return -1;
+        return -1;
     }else{
-    	atomic_inc(&rx_urb_cnt);
-	}
+        atomic_inc(&rx_urb_cnt);
+    }
     return 0;
 }
 #endif
@@ -619,7 +861,7 @@ static void aicwf_usb_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
     while((usb_buf = aicwf_usb_rx_buf_get(usb_dev)) != NULL) {
         if (aicwf_usb_submit_rx_urb(usb_dev, usb_buf)) {
             AICWFDBG(LOGERROR, "sub rx fail\n");
-		return;
+            return;
             #if 0
             AICWFDBG(LOGERROR, "usb rx refill fail\n");
             if (usb_dev->state != USB_UP_ST)
@@ -646,7 +888,7 @@ static int aicwf_usb_submit_msg_rx_urb(struct aic_usb_dev *usb_dev,
         return -1;
     }
 
-    skb = __dev_alloc_skb(AICWF_USB_MAX_PKT_SIZE, GFP_ATOMIC);
+    skb = __dev_alloc_skb(AICWF_USB_MSG_MAX_PKT_SIZE, GFP_ATOMIC);
     if (!skb) {
         aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
         return -1;
@@ -657,7 +899,7 @@ static int aicwf_usb_submit_msg_rx_urb(struct aic_usb_dev *usb_dev,
     usb_fill_bulk_urb(usb_buf->urb,
         usb_dev->udev,
         usb_dev->msg_in_pipe,
-        skb->data, skb_tailroom(skb), aicwf_usb_msg_rx_complete, usb_buf);
+        skb->data, AICWF_USB_MSG_MAX_PKT_SIZE, aicwf_usb_msg_rx_complete, usb_buf);
 
     usb_buf->usbdev = usb_dev;
 
@@ -1006,7 +1248,7 @@ int usb_bustx_thread(void *data)
     int set_cpu_ret = 0;
 
 #ifdef CONFIG_THREAD_INFO_IN_TASK
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
 	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
 #else
     AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
@@ -1015,7 +1257,7 @@ int usb_bustx_thread(void *data)
     set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
 #ifdef CONFIG_THREAD_INFO_IN_TASK
     AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
 	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
 #else
     AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
@@ -1073,7 +1315,7 @@ int usb_busrx_thread(void *data)
     int set_cpu_ret = 0;
     
 #ifdef CONFIG_THREAD_INFO_IN_TASK
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
 	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
 #else
     AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
@@ -1082,7 +1324,7 @@ int usb_busrx_thread(void *data)
     set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
 #ifdef CONFIG_THREAD_INFO_IN_TASK
     AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
 	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
 #else
     AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
@@ -1092,11 +1334,11 @@ int usb_busrx_thread(void *data)
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (busrx_thread_prio > 0) {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
-            sched_set_fifo_low(current);
+        sched_set_fifo_low(current);
 #else
-			struct sched_param param;
-			param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
-			sched_setscheduler(current, SCHED_FIFO, &param);
+		struct sched_param param;
+		param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+		sched_setscheduler(current, SCHED_FIFO, &param);
 #endif
 	}
 #endif
@@ -1135,19 +1377,19 @@ int usb_msg_busrx_thread(void *data)
     struct aicwf_bus *bus_if = rx_priv->usbdev->bus_if;
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
-			if (busrx_thread_prio > 0) {
+	if (busrx_thread_prio > 0) {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
-                sched_set_fifo_low(current);
+        sched_set_fifo_low(current);
 #else
-                struct sched_param param;
-                param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
-                sched_setscheduler(current, SCHED_FIFO, &param);
+        struct sched_param param;
+        param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+        sched_setscheduler(current, SCHED_FIFO, &param);
 #endif
-			}
+	}
 #endif
-			AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
-			AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
-			AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
+	AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
+	AICWFDBG(LOGINFO, "%s the rt_priority of current thread is:%d\n", __func__, current->rt_priority);
+	AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
 
 
 
@@ -1266,7 +1508,7 @@ static void aicwf_usb_free_urb(struct list_head *q, spinlock_t *qlock)
 
     spin_lock_irqsave(qlock, flags);
     list_for_each_entry_safe(usb_buf, tmp, q, list) {
-    spin_unlock_irqrestore(qlock, flags);
+        spin_unlock_irqrestore(qlock, flags);
         if (!usb_buf->urb) {
             usb_err("bad usb_buf\n");
             spin_lock_irqsave(qlock, flags);
@@ -1367,7 +1609,7 @@ static int aicwf_usb_alloc_tx_urb(struct aic_usb_dev *usb_dev)
 static int aicwf_usb_alloc_msg_rx_urb(struct aic_usb_dev *usb_dev)
 {
     int i;
-    
+
     AICWFDBG(LOGINFO, "%s AICWF_USB_MSG_RX_URBS:%d \r\n", __func__, AICWF_USB_MSG_RX_URBS);
 
     for (i = 0; i < AICWF_USB_MSG_RX_URBS; i++) {
@@ -1490,7 +1732,8 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
     u16 index = 0;
     bool need_cfm = false;
 #ifdef CONFIG_USB_ALIGN_DATA//AIDEN
-	int align;
+    u8 *buf_align;
+    int align;
 #endif
 
     if (usb_dev->state != USB_UP_ST) {
@@ -1585,6 +1828,7 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
     #if defined CONFIG_USB_NO_TRANS_DMA_MAP
     #error "CONFIG_USB_NO_TRANS_DMA_MAP not supported"
     #endif
+#if 0
 	usb_buf->usb_align_data = (u8*)kmalloc(sizeof(u8) * buf_len + align_param, GFP_ATOMIC);
 
 	align = ((unsigned long)(usb_buf->usb_align_data)) & (align_param - 1);
@@ -1592,6 +1836,21 @@ static int aicwf_usb_bus_txdata(struct device *dev, struct sk_buff *skb)
 
     usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
                 usb_buf->usb_align_data + (align_param - align), buf_len, aicwf_usb_tx_complete, usb_buf);
+#else
+    if (!IS_ALIGNED((unsigned long)buf, align_param)) {
+        usb_buf->usb_align_data = (u8*)kmalloc(sizeof(u8) * buf_len + align_param, GFP_ATOMIC);
+        if (usb_buf->usb_align_data) {
+            align = ((unsigned long)(usb_buf->usb_align_data)) & (align_param - 1);
+            buf_align = usb_buf->usb_align_data + (align_param - align);
+            memcpy(buf_align, buf, buf_len);
+        }
+    } else {
+        buf_align = buf;
+    }
+
+    usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
+                buf_align, buf_len, aicwf_usb_tx_complete, usb_buf);
+#endif
 #else
 	usb_fill_bulk_urb(usb_buf->urb, usb_dev->udev, usb_dev->bulk_out_pipe,
 			buf, buf_len, aicwf_usb_tx_complete, usb_buf);
@@ -1643,8 +1902,7 @@ static int aicwf_usb_bus_start(struct device *dev)
     aicwf_usb_rx_prepare(usb_dev);
     aicwf_usb_tx_prepare(usb_dev);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		aicwf_usb_msg_rx_prepare(usb_dev);
 	}
 #endif
@@ -1695,9 +1953,8 @@ static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
 
     usb_kill_anchored_urbs(&usb_dev->rx_submitted);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
-   		usb_kill_anchored_urbs(&usb_dev->msg_rx_submitted);
+	if(usb_dev->msg_in_pipe){
+		usb_kill_anchored_urbs(&usb_dev->msg_rx_submitted);
 	}
 #endif
 }
@@ -1720,8 +1977,8 @@ static void aicwf_usb_bus_stop(struct device *dev)
         return;
 
     if(g_rwnx_plat && g_rwnx_plat->wait_disconnect_cb == true){
-            atomic_set(&aicwf_deinit_atomic, 1);
-            up(&aicwf_deinit_sem);
+        atomic_set(&aicwf_deinit_atomic, 1);
+        up(&aicwf_deinit_sem);
     }
     aicwf_usb_state_change(usb_dev, USB_DOWN_ST);
     //aicwf_usb_cancel_all_urbs(usb_dev);//AIDEN
@@ -1733,8 +1990,7 @@ static void aicwf_usb_deinit(struct aic_usb_dev *usbdev)
     aicwf_usb_free_urb(&usbdev->rx_free_list, &usbdev->rx_free_lock);
     aicwf_usb_free_urb(&usbdev->tx_free_list, &usbdev->tx_free_lock);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usbdev->msg_in_pipe){
 		cancel_work_sync(&usbdev->msg_rx_urb_work);
 		aicwf_usb_free_urb(&usbdev->msg_rx_free_list, &usbdev->msg_rx_free_lock);
 	}
@@ -1769,8 +2025,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     init_waitqueue_head(&usb_dev->msg_wait);
     init_usb_anchor(&usb_dev->rx_submitted);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		init_usb_anchor(&usb_dev->msg_rx_submitted);
 	}
 #endif
@@ -1780,8 +2035,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     spin_lock_init(&usb_dev->rx_free_lock);
     spin_lock_init(&usb_dev->tx_flow_lock);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		spin_lock_init(&usb_dev->msg_rx_free_lock);
 	}
 #endif
@@ -1790,8 +2044,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     INIT_LIST_HEAD(&usb_dev->tx_free_list);
     INIT_LIST_HEAD(&usb_dev->tx_post_list);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		INIT_LIST_HEAD(&usb_dev->msg_rx_free_list);
 	}
 #endif
@@ -1810,8 +2063,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
         goto error;
     }
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		ret =  aicwf_usb_alloc_msg_rx_urb(usb_dev);
 		if (ret) {
 			goto error;
@@ -1829,8 +2081,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 
     INIT_WORK(&usb_dev->rx_urb_work, aicwf_usb_rx_urb_work);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		INIT_WORK(&usb_dev->msg_rx_urb_work, aicwf_usb_msg_rx_urb_work);
 	}
 #endif
@@ -1887,16 +2138,20 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 
     /* Check interface number */
 #ifdef CONFIG_USB_BT
-    if (usb->actconfig->desc.bNumInterfaces != 3) {
+    if (usb->actconfig->desc.bNumInterfaces != 3)
 #else
-    if (usb->actconfig->desc.bNumInterfaces != 1) {
+    if (usb->actconfig->desc.bNumInterfaces != 1)
 #endif
+    {
 	   AICWFDBG(LOGERROR, "Number of interfaces: %d not supported\n",
             usb->actconfig->desc.bNumInterfaces);
 		if(usb_dev->chipid == PRODUCT_ID_AIC8800DC){
 			AICWFDBG(LOGERROR, "AIC8800DC change to AIC8800DW\n");
 			usb_dev->chipid = PRODUCT_ID_AIC8800DW;
-		}else{
+		}else if(usb_dev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+                usb_dev->chipid == PRODUCT_ID_AIC8800D89X2){
+            //TODO
+        }else{
 			ret = -ENODEV;
 			goto exit;
 		}
@@ -1923,8 +2178,7 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
             }
 #ifdef CONFIG_USB_MSG_IN_EP
             else if (!usb_dev->msg_in_pipe) {
-				if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-                    usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+				if(usb_dev->chipid != PRODUCT_ID_AIC8801){
                 	usb_dev->msg_in_pipe = usb_rcvbulkpipe(usb, endpoint_num);
 				}
             }
@@ -1962,18 +2216,33 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
     }
 #endif
 #ifdef CONFIG_USB_MSG_IN_EP
-		if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-            usb_dev->chipid != PRODUCT_ID_AIC8800D81){
-			if (usb_dev->msg_in_pipe == 0) {
-				usb_err("No RX Msg (in) Bulk EP found\n");
-			}
+	if(usb_dev->chipid != PRODUCT_ID_AIC8801){
+		if (usb_dev->msg_in_pipe == 0) {
+			AICWFDBG(LOGINFO, "No RX Msg (in) Bulk EP found\n");
 		}
+	}
 #endif
 
-    if (usb->speed == USB_SPEED_HIGH){
-		AICWFDBG(LOGINFO, "Aic high speed USB device detected\n");
-    }else{
-    	AICWFDBG(LOGINFO, "Aic full speed USB device detected\n");
+    switch (usb->speed) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+    case USB_SPEED_SUPER_PLUS:
+        AICWFDBG(LOGINFO, "Aic super plus speed USB device detected\n");
+        break;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+    case USB_SPEED_SUPER:
+        AICWFDBG(LOGINFO, "Aic super speed USB device detected\n");
+        break;
+#endif
+    case USB_SPEED_HIGH:
+        AICWFDBG(LOGINFO, "Aic high speed USB device detected\n");
+        break;
+    case USB_SPEED_FULL:
+        AICWFDBG(LOGINFO, "Aic full speed USB device detected\n");
+        break;
+    default:
+        AICWFDBG(LOGINFO, "Aic unknown speed(%d) USB device detected\n", usb->speed);
+        break;
     }
 
     exit:
@@ -2071,10 +2340,30 @@ static int aicwf_usb_chipmatch(struct aic_usb_dev *usb_dev, u16_l vid, u16_l pid
         usb_dev->chipid = PRODUCT_ID_AIC8800DW;
 		AICWFDBG(LOGINFO, "%s USE AIC8800DW\r\n", __func__);
         return 0;
-    }else if(pid == USB_PRODUCT_ID_AIC8800D81){
+    }else if(pid == USB_PRODUCT_ID_AIC8800D81 || pid == USB_PRODUCT_ID_AIC8800D41){
         usb_dev->chipid = PRODUCT_ID_AIC8800D81;
-	aicwf_usb_rx_aggr = true;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+        aicwf_usb_rx_aggr = true;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+        return 0;
+    }else if(pid == USB_PRODUCT_ID_AIC8800D81X2){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D81X2;
+        aicwf_usb_max_pkt_size = AICWF_USB_MAX_AMSDU_PKT_SIZE;
+        if (usb_dev->udev->speed <= USB_SPEED_HIGH) {
+            aicwf_usb_rx_aggr = true;
+        } else {
+            aicwf_usb_rx_aggr = false;
+        }
+        AICWFDBG(LOGINFO, "%s USE AIC8800D81X2\r\n", __func__);
+        return 0;
+    }else if(pid == USB_PRODUCT_ID_AIC8800D89X2){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D89X2;
+        aicwf_usb_max_pkt_size = AICWF_USB_MAX_AMSDU_PKT_SIZE;
+        if (usb_dev->udev->speed <= USB_SPEED_HIGH) {
+            aicwf_usb_rx_aggr = true;
+        } else {
+            aicwf_usb_rx_aggr = false;
+        }
+        AICWFDBG(LOGINFO, "%s USE AIC8800D89X2\r\n", __func__);
         return 0;
     }else{
 		return -1;
@@ -2095,7 +2384,7 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     #endif
 
     usb_dev = kzalloc(sizeof(struct aic_usb_dev), GFP_ATOMIC);
-    
+
     AICWFDBG(LOGDEBUG, "%s usb_dev:%d usb_tx_buf:%d usb_rx_buf:%d\r\n", 
         __func__, 
         (int)sizeof(struct aic_usb_dev),
@@ -2130,7 +2419,7 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     memset(usb_dev->usb_tx_buf, 
         0, 
         (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS));
-    
+
     memset(usb_dev->usb_rx_buf, 
         0, 
         (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS));
@@ -2139,9 +2428,9 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     usb_dev->udev = usb;
     usb_dev->dev = &usb->dev;
     usb_set_intfdata(intf, usb_dev);
-	
+
 	ret = aicwf_usb_chipmatch(usb_dev, id->idVendor, id->idProduct);
-	
+
 	if (ret < 0) {
         AICWFDBG(LOGERROR, "%s pid:0x%04X vid:0x%04X unsupport\n", 
 			__func__, id->idVendor, id->idProduct);
@@ -2237,7 +2526,7 @@ static void aicwf_usb_disconnect(struct usb_interface *intf)
 {
     struct aic_usb_dev *usb_dev =
             (struct aic_usb_dev *) usb_get_intfdata(intf);
-        AICWFDBG(LOGINFO, "%s Enter\r\n", __func__);
+    AICWFDBG(LOGINFO, "%s Enter\r\n", __func__);
 
 	if(g_rwnx_plat->wait_disconnect_cb == false){
 		atomic_set(&aicwf_deinit_atomic, 0);
@@ -2289,8 +2578,8 @@ static int aicwf_usb_suspend(struct usb_interface *intf, pm_message_t state)
     atomic_inc(&irq_count);
 
 	list_for_each_entry_safe(rwnx_vif, tmp, &usb_dev->rwnx_hw->vifs, list) {
-		if (rwnx_vif->ndev)
-			netif_device_detach(rwnx_vif->ndev);
+	if (rwnx_vif->ndev)
+		netif_device_detach(rwnx_vif->ndev);
 	}
 #endif
 
@@ -2318,8 +2607,8 @@ static int aicwf_usb_resume(struct usb_interface *intf)
 	atomic_dec(&irq_count);
 
 	list_for_each_entry_safe(rwnx_vif, tmp, &usb_dev->rwnx_hw->vifs, list) {
-		if (rwnx_vif->ndev)
-			netif_device_attach(rwnx_vif->ndev);
+	if (rwnx_vif->ndev)
+		netif_device_attach(rwnx_vif->ndev);
 	}
 #endif
 
@@ -2341,8 +2630,11 @@ static struct usb_device_id aicwf_usb_id_table[] = {
 #else
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8801, 0xff, 0xff, 0xff)},
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D81, 0xff, 0xff, 0xff)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D41, 0xff, 0xff, 0xff)},
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DC, 0xff, 0xff, 0xff)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DW)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D81X2, 0xff, 0xff, 0xff)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D89X2)},
 #endif
     {}
 };
@@ -2378,7 +2670,7 @@ void aicwf_usb_exit(void)
 {
     int retry = 5;
     AICWFDBG(LOGINFO, "%s Enter\r\n", __func__);
-        
+
     AICWFDBG(LOGDEBUG, "%s in_interrupt:%d in_softirq:%d in_atomic:%d\r\n", __func__, (int)in_interrupt(), (int)in_softirq(), (int)in_atomic());
 
     do{
@@ -2390,7 +2682,7 @@ void aicwf_usb_exit(void)
             break;
         }
     }while(atomic_read(&aicwf_deinit_atomic) == 0);
-    
+
 	atomic_set(&aicwf_deinit_atomic, 0);
 	if(down_timeout(&aicwf_deinit_sem, msecs_to_jiffies(SEM_TIMOUT)) != 0){
 		AICWFDBG(LOGERROR, "%s semaphore waiting timeout\r\n", __func__);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
index a551c7512..893a74ae2 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
@@ -16,22 +16,33 @@
 
 /* USB Device ID */
 #define USB_VENDOR_ID_AIC                0xA69C
+#define USB_VENDOR_ID_AIC_V2             0x368B
 
 #ifndef CONFIG_USB_BT
-#define USB_PRODUCT_ID_AIC8800               0x8800
+#define USB_PRODUCT_ID_AIC8800          0x8800
+#define USB_PRODUCT_ID_AIC8801          0x8801
+#define USB_PRODUCT_ID_AIC8800DC        0x88dc
+#define USB_PRODUCT_ID_AIC8800DW        0x88dd
+#define USB_PRODUCT_ID_AIC8800D81       0x8d81
+#define USB_PRODUCT_ID_AIC8800D81X2     0x8d91
+#define USB_PRODUCT_ID_AIC8800D89X2     0x8d99
 #else
-#define USB_PRODUCT_ID_AIC8801				0x8801
-#define USB_PRODUCT_ID_AIC8800DC			0x88dc
-#define USB_PRODUCT_ID_AIC8800DW            0x88dd
-#define USB_PRODUCT_ID_AIC8800D81           0x8d81
-
+#define USB_PRODUCT_ID_AIC8801          0x8801
+#define USB_PRODUCT_ID_AIC8800DC        0x88dc
+#define USB_PRODUCT_ID_AIC8800DW        0x88dd
+#define USB_PRODUCT_ID_AIC8800D81       0x8d81
+#define USB_PRODUCT_ID_AIC8800D41       0x8d41
+#define USB_PRODUCT_ID_AIC8800D81X2     0x8d91
+#define USB_PRODUCT_ID_AIC8800D89X2     0x8d99
 #endif
 
 enum AICWF_IC{
 	PRODUCT_ID_AIC8801	=	0,
 	PRODUCT_ID_AIC8800DC,
 	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D81
+	PRODUCT_ID_AIC8800D81,
+	PRODUCT_ID_AIC8800D81X2,
+	PRODUCT_ID_AIC8800D89X2
 };
 
 
@@ -47,8 +58,14 @@ enum AICWF_IC{
 #endif
 #define AICWF_USB_TX_LOW_WATER         (AICWF_USB_TX_URBS/4)//25%
 #define AICWF_USB_TX_HIGH_WATER        (AICWF_USB_TX_LOW_WATER*3)//75%
+#ifdef CONFIG_PLATFORM_HI
 #define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*1)
+#else
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*10)
+#endif
+#define AICWF_USB_MSG_MAX_PKT_SIZE      (2048)
 #define AICWF_USB_MAX_PKT_SIZE          (2048)
+#define AICWF_USB_MAX_AMSDU_PKT_SIZE    (2048*6)
 #define AICWF_USB_FC_PERSTA_HIGH_WATER		64
 #define AICWF_USB_FC_PERSTA_LOW_WATER		16
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
index fdfab4cfe..d97a82fe1 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
@@ -400,7 +400,7 @@ static char *aicwf_get_iwe_stream_mac_addr(struct rwnx_hw* rwnx_hw,
 	iwe->cmd = SIOCGIWAP;
 	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
 
-	if(scan_re->bss && scan_re->bss->bssid){
+	if(scan_re->bss && &scan_re->bss->bssid[0]){
 	memcpy(iwe->u.ap_addr.sa_data, scan_re->bss->bssid, ETH_ALEN);
 	}
 
@@ -894,7 +894,7 @@ static char *translate_scan(struct rwnx_hw* rwnx_hw,
 	    	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
 		return start;
 	} else{
-		return NULL;
+		return start;
 	}	
 }
 
@@ -925,7 +925,6 @@ static int aicwf_get_wap(struct net_device *dev,
 }
 
 
-extern uint8_t scanning;
 static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 			   union iwreq_data *wrqu, char *extra)
 {
@@ -944,7 +943,7 @@ static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 
 	}
 
-    if (rwnx_hw->wext_scan || scanning) {
+    if (rwnx_hw->wext_scan || rwnx_hw->scanning) {
         AICWFDBG(LOGINFO, "is scanning, abort\n");
 	ret =  rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
 	if (ret)
@@ -971,6 +970,26 @@ static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 		}
 	}
 
+#if WIRELESS_EXT >= 17
+		if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+			struct iw_scan_req *req = (struct iw_scan_req *)extra;
+
+			if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+				int len = min((int)req->essid_len, 32);
+				request->ssids = kmalloc(sizeof(struct cfg80211_ssid), GFP_KERNEL);
+				if(!request->ssids){
+					AICWFDBG(LOGERROR, "%s Failied to alloc memory for ssids", __func__);
+					return -ENOMEM;
+				}
+				memset(request->ssids, 0, sizeof(struct cfg80211_ssid));
+				memcpy(request->ssids[0].ssid, req->essid, len);
+				request->ssids[0].ssid_len = len;
+				request->n_ssids = 1;
+				AICWFDBG(LOGDEBUG,"IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
+			} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+				AICWFDBG(LOGDEBUG,"aic_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+#endif
 	if ((ret = rwnx_send_scanu_req(rwnx_hw, rwnx_vif, request))){
         return ret;
 	}
@@ -981,7 +1000,6 @@ static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 	if (!wait_for_completion_killable_timeout(&rwnx_hw->wext_scan_com, wext_scan_timeout)) {
 		AICWFDBG(LOGERROR, "%s WEXT scan timeout", __func__);
 	}
-
 	return 0;
 }
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
index 985121080..1d900072a 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_mac.h
@@ -472,6 +472,7 @@ enum mac_connection_flags
 #define IEEE80211_HE_PHY_CAP2_MIDAMBLE_RX_TX_MAX_NSTS					0x01
 #define IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US						0x02
 #define IEEE80211_HE_PHY_CAP2_DOPPLER_RX								0x20
+#define IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ						0x04
 #define IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ						0x08
 #define IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM					0x18
 #define IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1							0x00
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 2ca79521d..fc12ee2ee 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -399,6 +399,17 @@ enum mm_msg_tag
     MM_SET_VENDOR_SWCONFIG_REQ,
     MM_SET_VENDOR_SWCONFIG_CFM,
 
+    MM_SET_TXPWR_LVL_ADJ_REQ,
+    MM_SET_TXPWR_LVL_ADJ_CFM,
+
+	MM_RADAR_DETECT_IND,
+
+	MM_SET_APF_PROG_REQ,
+	MM_SET_APF_PROG_CFM,
+
+	MM_GET_APF_PROG_REQ,
+	MM_GET_APF_PROG_CFM,
+
     /// MAX number of messages
     MM_MAX,
 };
@@ -1226,6 +1237,7 @@ struct mm_set_agg_disable_req
 {
     u8_l disable;
     u8_l staidx;
+    u8_l disable_rx;
 };
 
 struct mm_set_coex_req
@@ -1336,19 +1348,48 @@ typedef struct
     s8_l pwrlvl_11ax_5g[12];
 } txpwr_lvl_conf_v3_t;
 
+typedef struct
+{
+    u8_l enable;
+    s8_l pwrlvl_11b_11ag_2g4[12];
+    s8_l pwrlvl_11n_11ac_2g4[10];
+    s8_l pwrlvl_11ax_2g4[12];
+    s8_l pwrlvl_11a_5g[8];
+    s8_l pwrlvl_11n_11ac_5g[10];
+    s8_l pwrlvl_11ax_5g[12];
+    s8_l pwrlvl_11a_6g[8];
+    s8_l pwrlvl_11n_11ac_6g[10];
+    s8_l pwrlvl_11ax_6g[12];
+} txpwr_lvl_conf_v4_t;
+
+typedef struct
+{
+    u8_l enable;
+    s8_l pwrlvl_adj_tbl_2g4[3];
+    s8_l pwrlvl_adj_tbl_5g[6];
+} txpwr_lvl_adj_conf_t;
+
 struct mm_set_txpwr_lvl_req
 {
   union {
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+    txpwr_lvl_conf_v4_t txpwr_lvl_v4;
   };
 };
 
+struct mm_set_txpwr_lvl_adj_req
+{
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj;
+};
+
 typedef struct
 {
-    u8_l loss_enable;
-    u8_l loss_value;
+	u8_l loss_enable_2g4;
+	s8_l loss_value_2g4;
+	u8_l loss_enable_5g;
+	s8_l loss_value_5g;
 } txpwr_loss_conf_t;
 
 typedef struct
@@ -1383,18 +1424,83 @@ typedef struct
     int8_t chan_142_165;
 } txpwr_ofst_conf_t;
 
+/*
+ * pwrofst2x_tbl_2g4[3][3]:
+ * +---------------+----------+----------+----------+
+ * | RateTyp\ChGrp |  CH_1_4  |  CH_5_9  | CH_10_13 |
+ * +---------------+----------+----------+----------+
+ * | DSSS          |  [0][0]  |  [0][1]  |  [0][2]  |
+ * +---------------+----------+----------+----------+
+ * | OFDM_HIGHRATE |  [1][0]  |  [1][1]  |  [1][2]  |
+ * +---------------+----------+----------+----------+
+ * | OFDM_LOWRATE  |  [2][0]  |  [2][1]  |  [2][2]  |
+ * +---------------+----------+----------+----------+
+ * pwrofst2x_tbl_5g[3][6]:
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | RateTyp\ChGrp | CH_42(36~50) | CH_58(51~64) | CH_106(98~114) | CH_122(115~130)| CH_138(131~146)| CH_155(147~166)|
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_LOWRATE  |    [0][0]    |    [0][1]    |     [0][2]     |     [0][3]     |     [0][4]     |     [0][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_HIGHRATE |    [1][0]    |    [1][1]    |     [1][2]     |     [1][3]     |     [1][4]     |     [1][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_MIDRATE  |    [2][0]    |    [2][1]    |     [2][2]     |     [2][3]     |     [2][4]     |     [2][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ */
+
 typedef struct
 {
-    int8_t enable;
-    int8_t pwrofst2x_tbl_2g4[3][3];
-    int8_t pwrofst2x_tbl_5g[3][6];
+    u8_l enable;
+    s8_l pwrofst2x_tbl_2g4[3][3];
+    s8_l pwrofst2x_tbl_5g[3][6];
 } txpwr_ofst2x_conf_t;
 
+/*
+ * pwrofst2x_v2_tbl_2g4_ant0/1[3][3]:
+ * +---------------+----------+---------------+--------------+
+ * | ChGrp\RateTyp |  DSSS    | OFDM_HIGHRATE | OFDM_LOWRATE |
+ * +---------------+----------+---------------+--------------+
+ * | CH_1_4        |  [0][0]  |  [0][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * | CH_5_9        |  [1][0]  |  [1][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * | CH_10_13      |  [2][0]  |  [2][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * pwrofst2x_v2_tbl_5g_ant0/1[6][3]:
+ * +-----------------+---------------+--------------+--------------+
+ * | ChGrp\RateTyp   | OFDM_HIGHRATE | OFDM_LOWRATE | OFDM_MIDRATE |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_42(36~50)    |  [0][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_58(51~64)    |  [1][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_106(98~114)  |  [2][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_122(115~130) |  [3][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_138(131~146) |  [4][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_155(147~166) |  [5][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ */
+
+typedef struct
+{
+    u8_l enable;
+    u8_l pwrofst_flags;
+    s8_l pwrofst2x_tbl_2g4_ant0[3][3];
+    s8_l pwrofst2x_tbl_2g4_ant1[3][3];
+    s8_l pwrofst2x_tbl_5g_ant0[6][3];
+    s8_l pwrofst2x_tbl_5g_ant1[6][3];
+    s8_l pwrofst2x_tbl_6g_ant0[15];
+    s8_l pwrofst2x_tbl_6g_ant1[15];
+} txpwr_ofst2x_conf_v2_t;
+
 struct mm_set_txpwr_ofst_req
 {
   union {
     txpwr_ofst_conf_t txpwr_ofst;
     txpwr_ofst2x_conf_t txpwr_ofst2x;
+    txpwr_ofst2x_conf_v2_t txpwr_ofst2x_v2;
   };
 };
 
@@ -1936,6 +2042,10 @@ enum vendor_hwconfig_tag{
 	CCA_THRESHOLD_REQ,
 	BWMODE_REQ,
 	CHIP_TEMP_GET_REQ,
+	AP_PS_LEVEL_SET_REQ,
+	CUSTOMIZED_FREQ_REQ,
+	WAKEUP_INFO_REQ,
+	KEEPALIVE_PKT_REQ,
 };
 
 enum {
@@ -1963,7 +2073,8 @@ struct mm_set_channel_access_req
 	u8_l  long_nav_en;
 	u8_l  cfe_en;
 	u8_l  rc_retry_cnt[3];
-	s8_l ccademod_th;
+	s8_l  ccademod_th;
+	u8_l  remove_1m2m;
 };
 
 struct mm_set_mac_timescale_req
@@ -2013,6 +2124,22 @@ struct mm_set_vendor_hwconfig_cfm
     };
 };
 
+struct mm_set_customized_freq_req
+{
+	u32_l hwconfig_id;
+	u16_l raw_freq[4];
+	u16_l map_freq[4];
+};
+
+struct mm_set_keepalive_req
+{
+	u32_l hwconfig_id;
+	u16_l code;
+	u16_l length;
+	u32_l intv;
+	u8_l payload[];
+};
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -2046,6 +2173,9 @@ enum vendor_swconfig_tag
     BCN_CFG_REQ = 0,
     TEMP_COMP_SET_REQ,
     TEMP_COMP_GET_REQ,
+    EXT_FLAGS_SET_REQ,
+    EXT_FLAGS_GET_REQ,
+    EXT_FLAGS_MASK_SET_REQ,
 };
 
 struct mm_set_bcn_cfg_req
@@ -2082,12 +2212,40 @@ struct mm_get_temp_comp_cfm
     s8_l degree;
 };
 
+struct mm_set_ext_flags_req
+{
+    u32_l user_flags;
+};
+
+struct mm_set_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
+struct mm_get_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
+struct mm_mask_set_ext_flags_req
+{
+    u32_l user_flags_mask;
+    u32_l user_flags_val;
+};
+
+struct mm_mask_set_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
 struct mm_set_vendor_swconfig_req
 {
     u32_l swconfig_id;
     union {
         struct mm_set_bcn_cfg_req bcn_cfg_req;
         struct mm_set_temp_comp_req temp_comp_set_req;
+        struct mm_set_ext_flags_req ext_flags_set_req;
+        struct mm_mask_set_ext_flags_req ext_flags_mask_set_req;
     };
 };
 
@@ -2098,6 +2256,9 @@ struct mm_set_vendor_swconfig_cfm
         struct mm_set_bcn_cfg_cfm bcn_cfg_cfm;
         struct mm_set_temp_comp_cfm temp_comp_set_cfm;
         struct mm_get_temp_comp_cfm temp_comp_get_cfm;
+        struct mm_set_ext_flags_cfm ext_flags_set_cfm;
+        struct mm_get_ext_flags_cfm ext_flags_get_cfm;
+        struct mm_mask_set_ext_flags_cfm ext_flags_mask_set_cfm;
     };
 };
 
@@ -2855,6 +3016,20 @@ enum dbg_msg_tag
     DBG_GPIO_INIT_REQ,
     DBG_GPIO_INIT_CFM,
 
+    /// EF usrdata read request
+    DBG_EF_USRDATA_READ_REQ,
+    /// EF usrdata read confirm
+    DBG_EF_USRDATA_READ_CFM,
+    /// Memory block read request
+    DBG_MEM_BLOCK_READ_REQ,
+    /// Memory block read confirm
+    DBG_MEM_BLOCK_READ_CFM,
+
+    DBG_PWM_INIT_REQ,
+    DBG_PWM_INIT_CFM,
+    DBG_PWM_DEINIT_REQ,
+    DBG_PWM_DEINIT_CFM,
+
     /// Max number of Debug messages
     DBG_MAX,
 };
@@ -2988,9 +3163,9 @@ struct dbg_start_app_cfm
 enum {
     HOST_START_APP_AUTO = 1,
     HOST_START_APP_CUSTOM,
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
     HOST_START_APP_REBOOT,
-#endif // (CONFIG_USB_BT)
+//#endif // (CONFIG_USB_BT)
 	HOST_START_APP_FNCALL = 4,
 	HOST_START_APP_DUMMY  = 5,
 };
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
index 83b112290..4481d7d28 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
@@ -1,62 +1,62 @@
-/**
- ****************************************************************************************
- *
- * @file co_types.h
- *
- * @brief This file replaces the need to include stdint or stdbool typical headers,
- *        which may not be available in all toolchains, and adds new types
- *
- * Copyright (C) RivieraWaves 2009-2019
- *
- * $Rev: $
- *
- ****************************************************************************************
- */
-
-#ifndef _LMAC_INT_H_
-#define _LMAC_INT_H_
-
-
-/**
- ****************************************************************************************
- * @addtogroup CO_INT
- * @ingroup COMMON
- * @brief Common integer standard types (removes use of stdint)
- *
- * @{
- ****************************************************************************************
- */
-
-
-/*
- * DEFINES
- ****************************************************************************************
- */
-
-#include <linux/version.h>
-#include <linux/types.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-#include <linux/bits.h>
-#else
-#include <linux/bitops.h>
-#endif
-
-#ifdef CONFIG_RWNX_TL4
-typedef uint16_t u8_l;
-typedef int16_t s8_l;
-typedef uint16_t bool_l;
-#else
-typedef uint8_t u8_l;
-typedef int8_t s8_l;
-typedef bool bool_l;
-#endif
-typedef uint16_t u16_l;
-typedef int16_t s16_l;
-typedef uint32_t u32_l;
-typedef int32_t s32_l;
-typedef uint64_t u64_l;
-
-
-
-/// @} CO_INT
-#endif // _LMAC_INT_H_
+/**
+ ****************************************************************************************
+ *
+ * @file co_types.h
+ *
+ * @brief This file replaces the need to include stdint or stdbool typical headers,
+ *        which may not be available in all toolchains, and adds new types
+ *
+ * Copyright (C) RivieraWaves 2009-2019
+ *
+ * $Rev: $
+ *
+ ****************************************************************************************
+ */
+
+#ifndef _LMAC_INT_H_
+#define _LMAC_INT_H_
+
+
+/**
+ ****************************************************************************************
+ * @addtogroup CO_INT
+ * @ingroup COMMON
+ * @brief Common integer standard types (removes use of stdint)
+ *
+ * @{
+ ****************************************************************************************
+ */
+
+
+/*
+ * DEFINES
+ ****************************************************************************************
+ */
+
+#include <linux/version.h>
+#include <linux/types.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+#include <linux/bits.h>
+#else
+#include <linux/bitops.h>
+#endif
+
+#ifdef CONFIG_RWNX_TL4
+typedef uint16_t u8_l;
+typedef int16_t s8_l;
+typedef uint16_t bool_l;
+#else
+typedef uint8_t u8_l;
+typedef int8_t s8_l;
+typedef bool bool_l;
+#endif
+typedef uint16_t u16_l;
+typedef int16_t s16_l;
+typedef uint32_t u32_l;
+typedef int32_t s32_l;
+typedef uint64_t u64_l;
+
+
+
+/// @} CO_INT
+#endif // _LMAC_INT_H_
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
index b1d9c014e..112ef034d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
@@ -21,7 +21,7 @@
 #define ROM_FMAC_FW_ADDR               0x00010000
 #define RAM_FMAC_FW_ADDR               0x00120000
 #define ROM_FMAC_PATCH_ADDR            0x00180000
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 #define ROM_FMAC_CALIB_ADDR            0x00130000
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
index ebc77a3e5..8d29c97b2 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
@@ -2866,6 +2866,7 @@ const struct ieee80211_regdomain *reg_regdb[] = {
 	&regdom_YT,
 	&regdom_ZA,
 	&regdom_ZW,
+	NULL,
 };
 
 int reg_regdb_size = ARRAY_SIZE(reg_regdb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
index 4cef4819d..6b569b53d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -19,6 +19,7 @@
 #include "rwnx_strs.h"
 #include "rwnx_events.h"
 #include "aicwf_txrxif.h"
+#include "rwnx_wakelock.h"
 #ifdef AICWF_SDIO_SUPPORT
 #include "aicwf_sdio.h"
 #else
@@ -46,8 +47,8 @@ static void cmd_complete(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
     //RWNX_DBG(RWNX_FN_ENTRY_STR);
     lockdep_assert_held(&cmd_mgr->lock);
 
-    list_del(&cmd->list);
-    cmd_mgr->queue_sz--;
+    //list_del(&cmd->list);
+    //cmd_mgr->queue_sz--;
 
     cmd->flags |= RWNX_CMD_FLAG_DONE;
     if (cmd->flags & RWNX_CMD_FLAG_NONBLOCK) {
@@ -58,6 +59,10 @@ static void cmd_complete(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
             complete(&cmd->complete);
         }
     }
+    
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_unlock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
 }
 
 int cmd_mgr_queue_force_defer(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
@@ -102,6 +107,9 @@ int cmd_mgr_queue_force_defer(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd
         init_completion(&cmd->complete);
 
     list_add_tail(&cmd->list, &cmd_mgr->cmds);
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_lock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
     cmd_mgr->queue_sz++;
     spin_unlock_bh(&cmd_mgr->lock);
 
@@ -123,12 +131,33 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
     struct aic_usb_dev *usbdev = container_of(cmd_mgr, struct aic_usb_dev, cmd_mgr);
 #endif
     bool defer_push = false;
+    u8_l empty = 0;
 
     //RWNX_DBG(RWNX_FN_ENTRY_STR);
 #ifdef CREATE_TRACE_POINTS
     trace_msg_send(cmd->id);
 #endif
-    spin_lock_bh(&cmd_mgr->lock);
+    if(cmd->e2a_msg != NULL) {
+        do {
+            if(cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED)
+                break;
+            spin_lock_bh(&cmd_mgr->lock);
+            empty = list_empty(&cmd_mgr->cmds);
+            if(!empty) {
+                spin_unlock_bh(&cmd_mgr->lock);
+                if(in_softirq()) {
+                    printk("in_softirq:check cmdqueue empty\n");
+                    mdelay(10);
+                } else {
+                    printk("check cmdqueue empty\n");
+                    msleep(50);
+                }
+            }
+        } while(!empty);//wait for cmd queue empty
+    } else {
+            spin_lock_bh(&cmd_mgr->lock);
+    }
+
 
     if (cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED) {
         printk(KERN_CRIT"cmd queue crashed\n");
@@ -177,6 +206,9 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
         init_completion(&cmd->complete);
 
     list_add_tail(&cmd->list, &cmd_mgr->cmds);
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_lock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
     cmd_mgr->queue_sz++;
 
 	if(cmd->a2e_msg->id == ME_TRAFFIC_IND_REQ
@@ -240,6 +272,10 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
             spin_unlock_bh(&cmd_mgr->lock);
         }
 		else{
+			spin_lock_bh(&cmd_mgr->lock);
+			list_del(&cmd->list);
+			cmd_mgr->queue_sz--;
+			spin_unlock_bh(&cmd_mgr->lock);
 			rwnx_cmd_free(cmd);//kfree(cmd);AIDEN
             if(!list_empty(&cmd_mgr->cmds) && usbdev->state == USB_UP_ST)
                 WAKE_CMD_WORK(cmd_mgr);
@@ -350,8 +386,13 @@ void cmd_mgr_task_process(struct work_struct *work)
                     cmd_complete(cmd_mgr, next);
                 }
                 spin_unlock_bh(&cmd_mgr->lock);
-            } else
-		rwnx_cmd_free(next);//kfree(next);AIDEN
+            } else {
+				spin_lock_bh(&cmd_mgr->lock);
+				list_del(&next->list);
+				cmd_mgr->queue_sz--;
+				spin_unlock_bh(&cmd_mgr->lock);
+				rwnx_cmd_free(next);//kfree(next);AIDEN
+			}
         }
     }
 
@@ -465,6 +506,11 @@ static void cmd_mgr_drain(struct rwnx_cmd_mgr *cmd_mgr)
             complete(&cur->complete);
     }
     spin_unlock_bh(&cmd_mgr->lock);
+    
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_unlock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
+
 }
 
 void rwnx_cmd_mgr_init(struct rwnx_cmd_mgr *cmd_mgr)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
index b85983532..204561b26 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
@@ -244,6 +244,11 @@ enum ieee80211_radiotap_he_mu_bits {
 #define REGULATORY_IGNORE_STALE_KICKOFF 0
 #else
 #define STA_TDLS_INITIATOR(sta) sta->tdls_initiator
+
+#ifndef REGULATORY_IGNORE_STALE_KICKOFF
+#define REGULATORY_IGNORE_STALE_KICKOFF 0
+#endif
+
 #endif
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
index fd5a92e7b..bbba48f67 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -200,11 +200,11 @@ DEBUGFS_READ_WRITE_FILE_OPS(stats);
 #endif /* CONFIG_RWNX_FULLMAC */
 
 #define STA_HDR "** STA %d (%pM)\n"
-#define STA_HDR_MAX_LEN sizeof("- STA xx (xx:xx:xx:xx:xx:xx)\n") + PS_HDR_MAX_LEN
+#define STA_HDR_MAX_LEN (sizeof("- STA xx (xx:xx:xx:xx:xx:xx)\n") + PS_HDR_MAX_LEN)
 
 #ifdef CONFIG_RWNX_FULLMAC
 #define VIF_HDR "* VIF [%d] %s\n"
-#define VIF_HDR_MAX_LEN sizeof(VIF_HDR) + IFNAMSIZ
+#define VIF_HDR_MAX_LEN (sizeof(VIF_HDR) + IFNAMSIZ)
 #else
 #define VIF_HDR "* VIF [%d]\n"
 #define VIF_HDR_MAX_LEN sizeof(VIF_HDR)
@@ -1261,6 +1261,12 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
     	if(oper== 0) {
 		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
         	printk("[0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+	} else if (oper == 1) {
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("before write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+		ret = rwnx_send_dbg_mem_block_write_req(priv, addr, 4, &val);
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("after write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
     	}
 
 	return count;
@@ -1274,7 +1280,7 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 {
 	struct rwnx_hw *priv = file->private_data;
 	char buf[64];
-	int32_t addr[13];
+	int32_t addr[14];
     int32_t addr_out[12];
 	u32_l hwconfig_id;
 	size_t len = min_t(size_t,count,sizeof(buf)-1);
@@ -1289,7 +1295,7 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 
 	buf[len] = '\0';
 	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x %x",
-                            &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11]);
+                            &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11], &addr[12]);
 	if(ret > 14) {
 		printk("param error > 14\n");
 	} else {
@@ -1303,12 +1309,12 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			printk("ACS_TXOP_REQ bk:0x%x be:0x%x vi:0x%x vo:0x%x\n",addr[0],  addr[1], addr[2], addr[3]);
 			break;
 		    case 1:
-			if(ret != 14) {
-			    printk("param error  != 14\n");
+			if(ret != 15) {
+			    printk("param error  != 15\n");
 			    break;}
 			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
-			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x\n",
-                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12]);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x, remove_1m2m %x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12], addr[13]);
 			break;
 		    case 2:
 			if(ret != 7) {
@@ -1358,7 +1364,7 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 	return count;
 }
 
-DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig)
+DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig);
 
 static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
             const char __user *user_buf,
@@ -1412,6 +1418,35 @@ static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
                 }
             break;
 
+            case 3: // EXT_FLAGS_SET_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_SET_REQ set ext_flags=0x%x, get ext_flags=0x%x\n",
+                        addr[0], addr_out[0]);
+                }
+            break;
+
+            case 4: // EXT_FLAGS_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_GET_REQ get ext_flags=0x%x\n", addr_out[0]);
+                }
+            break;
+
+            case 5: // EXT_FLAGS_MASK_SET_REQ
+                if (ret != 3) {
+                    printk("param error != 3\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_MASK_SET_REQ set ext_flags mask=0x%x, val=0x%x, get ext_flags=0x%x\n",
+                        addr[0], addr[1], addr_out[0]);
+                }
+            break;
+
             default:
                 printk("param error\n");
                 break;
@@ -1425,7 +1460,107 @@ static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
     return count;
 }
 
-DEBUGFS_WRITE_FILE_OPS(vendor_swconfig)
+DEBUGFS_WRITE_FILE_OPS(vendor_swconfig);
+
+static ssize_t rwnx_dbgfs_agg_disable_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    char buf[64];
+    int agg_disable, agg_disable_rx, sta_idx;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%d %d %d", &agg_disable, &agg_disable_rx, &sta_idx);
+    if ((ret > 3) || (ret < 2)) {
+        printk("param error: cnt=%d\n", ret);
+    } else {
+        if (ret < 3) {
+            sta_idx = RWNX_INVALID_STA;
+        }
+        printk("disable_agg: T=%d, R=%d, staidx=%d\n", agg_disable, agg_disable_rx, sta_idx);
+        ret = rwnx_send_disable_agg_req(priv, (u8_l)agg_disable, (u8_l)agg_disable_rx, (u8_l)sta_idx);
+        if (ret) {
+            printk("rwnx_send_disable_agg_req fail: %d\n", ret);
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(agg_disable);
+
+static ssize_t rwnx_dbgfs_set_roc_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    struct rwnx_vif *vif = NULL;
+    char buf[64];
+    int roc_start, chan_freq, duration;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    int if_type = NL80211_IFTYPE_STATION;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%d %d %d", &roc_start, &chan_freq, &duration);
+
+    list_for_each_entry(vif, &priv->vifs, list) {
+        if (RWNX_VIF_TYPE(vif) == if_type) {
+            break;
+        }
+    }
+    if ((ret > 3) || (ret < 1)) {
+        printk("param error: cnt=%d\n", ret);
+    } else if (vif) {
+        struct ieee80211_channel chan_entry = {0,};
+        struct ieee80211_channel *chan = &chan_entry;
+        struct mm_remain_on_channel_cfm roc_cfm;
+        if (ret < 3) {
+            duration = 2000;
+            if (ret < 2) {
+                chan_freq = 2412;
+            }
+        }
+        printk("set_roc: start=%d, freq=%d\n", roc_start, chan_freq);
+        if (roc_start) {
+            if (chan_freq <= 2484) {
+                chan->band = NL80211_BAND_2GHZ;
+            } else {
+                chan->band = NL80211_BAND_5GHZ;
+            }
+            chan->center_freq = chan_freq;
+            chan->max_power = 18;
+            ret = rwnx_send_roc(priv, vif, chan, duration, &roc_cfm);
+            if (ret) {
+                printk("rwnx_send_roc fail: %d\n", ret);
+            } else {
+                printk("roc_cfm: opcode=%x, st=%d, idx=%d\n", roc_cfm.op_code, roc_cfm.status, roc_cfm.chan_ctxt_index);
+            }
+        } else {
+            ret = rwnx_send_cancel_roc(priv);
+            if (ret) {
+                printk("rwnx_send_cancel_roc fail: %d\n", ret);
+            }
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(set_roc);
 
 extern int aicwf_dbg_level;
 static ssize_t rwnx_dbgfs_dbg_level_read(struct file *file,
@@ -2028,7 +2163,7 @@ static ssize_t rwnx_dbgfs_last_rx_read(struct file *file,
         nss = last_rx->ht.mcs / 8;;
         gi = last_rx->ht.short_gi;
     } else {
-        BUG_ON((mcs = legrates_lut[last_rx->leg_rate]) == -1);
+        BUG_ON((mcs = legrates_lut[last_rx->leg_rate].idx) == -1);
         nss = 0;
         gi = 0;
     }
@@ -2307,6 +2442,8 @@ int rwnx_dbgfs_register(struct rwnx_hw *rwnx_hw, const char *name)
     DEBUGFS_ADD_FILE(regdbg, dir_drv, S_IWUSR);
 	DEBUGFS_ADD_FILE(vendor_hwconfig, dir_drv,S_IWUSR);
 	DEBUGFS_ADD_FILE(vendor_swconfig, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(agg_disable, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(set_roc, dir_drv,S_IWUSR);
 	DEBUGFS_ADD_FILE(dbg_level, dir_drv, S_IWUSR | S_IRUSR);
 
 #ifdef CONFIG_RWNX_P2P_DEBUGFS
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index c5f7dc2d2..8d15e151c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -47,17 +47,17 @@
 #include "aic_br_ext.h"
 #endif /* CONFIG_BR_SUPPORT */
 
-#define WPI_HDR_LEN    18
-#define WPI_PN_LEN     16
-#define WPI_PN_OFST     2
-#define WPI_MIC_LEN    16
-#define WPI_KEY_LEN    32
+#define WPI_HDR_LEN 18
+#define WPI_PN_LEN 16
+#define WPI_PN_OFST 2
+#define WPI_MIC_LEN 16
+#define WPI_KEY_LEN 32
 #define WPI_SUBKEY_LEN 16 // WPI key is actually two 16bytes key
 
-#define LEGACY_PS_ID   0
-#define UAPSD_ID       1
+#define LEGACY_PS_ID 0
+#define UAPSD_ID 1
 
-#define PS_SP_INTERRUPTED  255
+#define PS_SP_INTERRUPTED 255
 #define MAC_ADDR_LEN 6
 
 //because android kernel 5.15 uses kernel 6.0 or 6.1 kernel api
@@ -67,38 +67,40 @@
 #define HIGH_KERNEL_VERSION3 KERNEL_VERSION(5, 15, 104)
 #define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 1, 0)
 #else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 5, 0)
 #define HIGH_KERNEL_VERSION2 KERNEL_VERSION(6, 1, 0)
 #define HIGH_KERNEL_VERSION3 KERNEL_VERSION(6, 3, 0)
 #define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 3, 0)
 #endif
 
-
-
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-#define IEEE80211_MAX_AMPDU_BUF                             IEEE80211_MAX_AMPDU_BUF_HE
-#define IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB         IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB
-#define IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB         IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB
-#define IEEE80211_HE_PHY_CAP3_RX_HE_MU_PPDU_FROM_NON_AP_STA IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU
+#define IEEE80211_MAX_AMPDU_BUF IEEE80211_MAX_AMPDU_BUF_HE
+#define IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMER_FB \
+	IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB
+#define IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMER_FB \
+	IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB
+#define IEEE80211_HE_PHY_CAP3_RX_HE_MU_PPDU_FROM_NON_AP_STA \
+	IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU
 #endif
 
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0) || defined(CONFIG_VHT_FOR_OLD_KERNEL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0) || \
+	defined(CONFIG_VHT_FOR_OLD_KERNEL)
 enum nl80211_ac {
-        NL80211_AC_VO,
-        NL80211_AC_VI,
-        NL80211_AC_BE,
-        NL80211_AC_BK,
-        NL80211_NUM_ACS
+	NL80211_AC_VO,
+	NL80211_AC_VI,
+	NL80211_AC_BE,
+	NL80211_AC_BK,
+	NL80211_NUM_ACS
 };
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0) || defined(CONFIG_VHT_FOR_OLD_KERNEL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0) || \
+	defined(CONFIG_VHT_FOR_OLD_KERNEL)
 struct ieee80211_vht_operation {
-        u8 vht_op_info_chwidth;
-        u8 vht_op_info_chan_center_freq_seg1_idx;
-        u8 vht_op_info_chan_center_freq_seg2_idx;
-        __le16 vht_basic_mcs_set;
+	u8 vht_op_info_chwidth;
+	u8 vht_op_info_chan_center_freq_seg1_idx;
+	u8 vht_op_info_chan_center_freq_seg2_idx;
+	__le16 vht_basic_mcs_set;
 } __packed;
 #endif
 
@@ -107,85 +109,86 @@ struct ieee80211_vht_operation {
 #define IEEE80211_RADIOTAP_AMPDU_STATUS 20
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0) || defined(CONFIG_VHT_FOR_OLD_KERNEL)
-#define IEEE80211_RADIOTAP_VHT                                  21
-#define IEEE80211_RADIOTAP_VHT_KNOWN_GI                         0x0004
-#define IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH                  0x0040
-
-#define IEEE80211_RADIOTAP_VHT_FLAG_STBC                        0x01
-#define IEEE80211_RADIOTAP_VHT_FLAG_SGI                         0x04
-
-#define NL80211_FEATURE_CELL_BASE_REG_HINTS              1 << 3
-#define NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL         1 << 4
-#define NL80211_FEATURE_SAE                              1 << 5
-#define NL80211_FEATURE_LOW_PRIORITY_SCAN                1 << 6
-#define NL80211_FEATURE_SCAN_FLUSH                       1 << 7
-#define NL80211_FEATURE_AP_SCAN                          1 << 8
-#define NL80211_FEATURE_VIF_TXPOWER                      1 << 9
-#define NL80211_FEATURE_NEED_OBSS_SCAN                   1 << 10
-#define NL80211_FEATURE_P2P_GO_CTWIN                     1 << 11
-#define NL80211_FEATURE_P2P_GO_OPPPS                     1 << 12
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0) || \
+	defined(CONFIG_VHT_FOR_OLD_KERNEL)
+#define IEEE80211_RADIOTAP_VHT 21
+#define IEEE80211_RADIOTAP_VHT_KNOWN_GI 0x0004
+#define IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH 0x0040
+
+#define IEEE80211_RADIOTAP_VHT_FLAG_STBC 0x01
+#define IEEE80211_RADIOTAP_VHT_FLAG_SGI 0x04
+
+#define NL80211_FEATURE_CELL_BASE_REG_HINTS 1 << 3
+#define NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL 1 << 4
+#define NL80211_FEATURE_SAE 1 << 5
+#define NL80211_FEATURE_LOW_PRIORITY_SCAN 1 << 6
+#define NL80211_FEATURE_SCAN_FLUSH 1 << 7
+#define NL80211_FEATURE_AP_SCAN 1 << 8
+#define NL80211_FEATURE_VIF_TXPOWER 1 << 9
+#define NL80211_FEATURE_NEED_OBSS_SCAN 1 << 10
+#define NL80211_FEATURE_P2P_GO_CTWIN 1 << 11
+#define NL80211_FEATURE_P2P_GO_OPPPS 1 << 12
 
 /* 802.11ac VHT Capabilities */
-#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895                  0x00000000
-#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991                  0x00000001
-#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454                 0x00000002
-#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ                0x00000004
-#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ       0x00000008
-#define IEEE80211_VHT_CAP_RXLDPC                                0x00000010
-#define IEEE80211_VHT_CAP_SHORT_GI_80                           0x00000020
-#define IEEE80211_VHT_CAP_SHORT_GI_160                          0x00000040
-#define IEEE80211_VHT_CAP_TXSTBC                                0x00000080
-#define IEEE80211_VHT_CAP_RXSTBC_1                              0x00000100
-#define IEEE80211_VHT_CAP_RXSTBC_2                              0x00000200
-#define IEEE80211_VHT_CAP_RXSTBC_3                              0x00000300
-#define IEEE80211_VHT_CAP_RXSTBC_4                              0x00000400
-#define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE                 0x00000800
-#define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE                 0x00001000
-#define IEEE80211_VHT_CAP_BEAMFORMER_ANTENNAS_MAX               0x00006000
-#define IEEE80211_VHT_CAP_SOUNDING_DIMENTION_MAX                0x00030000
-#define IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE                 0x00080000
-#define IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE                 0x00100000
-#define IEEE80211_VHT_CAP_VHT_TXOP_PS                           0x00200000
-#define IEEE80211_VHT_CAP_HTC_VHT                               0x00400000
-#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT      23
-#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK       \
-                (7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT)
-#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB     0x08000000
-#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB       0x0c000000
-#define IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN                    0x10000000
-#define IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN                    0x20000000
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895 0x00000000
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 0x00000001
+#define IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 0x00000002
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ 0x00000004
+#define IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ 0x00000008
+#define IEEE80211_VHT_CAP_RXLDPC 0x00000010
+#define IEEE80211_VHT_CAP_SHORT_GI_80 0x00000020
+#define IEEE80211_VHT_CAP_SHORT_GI_160 0x00000040
+#define IEEE80211_VHT_CAP_TXSTBC 0x00000080
+#define IEEE80211_VHT_CAP_RXSTBC_1 0x00000100
+#define IEEE80211_VHT_CAP_RXSTBC_2 0x00000200
+#define IEEE80211_VHT_CAP_RXSTBC_3 0x00000300
+#define IEEE80211_VHT_CAP_RXSTBC_4 0x00000400
+#define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE 0x00000800
+#define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE 0x00001000
+#define IEEE80211_VHT_CAP_BEAMFORMER_ANTENNAS_MAX 0x00006000
+#define IEEE80211_VHT_CAP_SOUNDING_DIMENTION_MAX 0x00030000
+#define IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE 0x00080000
+#define IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE 0x00100000
+#define IEEE80211_VHT_CAP_VHT_TXOP_PS 0x00200000
+#define IEEE80211_VHT_CAP_HTC_VHT 0x00400000
+#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT 23
+#define IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK \
+	(7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT)
+#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB 0x08000000
+#define IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB 0x0c000000
+#define IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN 0x10000000
+#define IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN 0x20000000
 
 enum ieee80211_vht_mcs_support {
-        IEEE80211_VHT_MCS_SUPPORT_0_7   = 0,
-        IEEE80211_VHT_MCS_SUPPORT_0_8   = 1,
-        IEEE80211_VHT_MCS_SUPPORT_0_9   = 2,
-        IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
+	IEEE80211_VHT_MCS_SUPPORT_0_7 = 0,
+	IEEE80211_VHT_MCS_SUPPORT_0_8 = 1,
+	IEEE80211_VHT_MCS_SUPPORT_0_9 = 2,
+	IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
 };
 
 enum nl80211_chan_width {
-        NL80211_CHAN_WIDTH_20_NOHT,
-        NL80211_CHAN_WIDTH_20,
-        NL80211_CHAN_WIDTH_40,
-        NL80211_CHAN_WIDTH_80,
-        NL80211_CHAN_WIDTH_80P80,
-        NL80211_CHAN_WIDTH_160,
+	NL80211_CHAN_WIDTH_20_NOHT,
+	NL80211_CHAN_WIDTH_20,
+	NL80211_CHAN_WIDTH_40,
+	NL80211_CHAN_WIDTH_80,
+	NL80211_CHAN_WIDTH_80P80,
+	NL80211_CHAN_WIDTH_160,
 };
 
 struct cfg80211_chan_def {
-        struct ieee80211_channel *chan;
-        enum nl80211_chan_width width;
-        u32 center_freq1;
-        u32 center_freq2;
+	struct ieee80211_channel *chan;
+	enum nl80211_chan_width width;
+	u32 center_freq1;
+	u32 center_freq2;
 };
 
 enum nl80211_mesh_power_mode {
-        NL80211_MESH_POWER_UNKNOWN,
-        NL80211_MESH_POWER_ACTIVE,
-        NL80211_MESH_POWER_LIGHT_SLEEP,
-        NL80211_MESH_POWER_DEEP_SLEEP,
-        __NL80211_MESH_POWER_AFTER_LAST,
-        NL80211_MESH_POWER_MAX = __NL80211_MESH_POWER_AFTER_LAST - 1
+	NL80211_MESH_POWER_UNKNOWN,
+	NL80211_MESH_POWER_ACTIVE,
+	NL80211_MESH_POWER_LIGHT_SLEEP,
+	NL80211_MESH_POWER_DEEP_SLEEP,
+	__NL80211_MESH_POWER_AFTER_LAST,
+	NL80211_MESH_POWER_MAX = __NL80211_MESH_POWER_AFTER_LAST - 1
 };
 #endif
 
@@ -196,13 +199,13 @@ enum nl80211_mesh_power_mode {
  * TDLS capabililites to be enabled in the 5th byte of the
  * @WLAN_EID_EXT_CAPABILITY information element
  */
-#define WLAN_EXT_CAPA5_TDLS_ENABLED	BIT(5)
-#define WLAN_EXT_CAPA5_TDLS_PROHIBITED	BIT(6)
+#define WLAN_EXT_CAPA5_TDLS_ENABLED BIT(5)
+#define WLAN_EXT_CAPA5_TDLS_PROHIBITED BIT(6)
 
-#define WLAN_EXT_CAPA8_OPMODE_NOTIF	BIT(6)
+#define WLAN_EXT_CAPA8_OPMODE_NOTIF BIT(6)
 
 /* TDLS specific payload type in the LLC/SNAP header */
-#define WLAN_TDLS_SNAP_RFTYPE	0x2
+#define WLAN_TDLS_SNAP_RFTYPE 0x2
 
 #endif
 
@@ -220,15 +223,15 @@ enum nl80211_mesh_power_mode {
  * @dtim: dtim period
  */
 struct rwnx_bcn {
-    u8 *head;
-    u8 *tail;
-    u8 *ies;
-    size_t head_len;
-    size_t tail_len;
-    size_t ies_len;
-    size_t tim_len;
-    size_t len;
-    u8 dtim;
+	u8 *head;
+	u8 *tail;
+	u8 *ies;
+	size_t head_len;
+	size_t tail_len;
+	size_t ies_len;
+	size_t tim_len;
+	size_t len;
+	u8 dtim;
 };
 
 /**
@@ -237,24 +240,24 @@ struct rwnx_bcn {
  * @hw_idx: Idx of the key from hardware point of view
  */
 struct rwnx_key {
-    u8 hw_idx;
+	u8 hw_idx;
 };
 
 /**
  * Structure containing information about a Mesh Path
  */
 struct rwnx_mesh_path {
-    struct list_head list;          /* For rwnx_vif.mesh_paths */
-    u8 path_idx;                    /* Path Index */
-    struct mac_addr tgt_mac_addr;   /* Target MAC Address */
-    struct rwnx_sta *p_nhop_sta;    /* Pointer to the Next Hop STA */
+	struct list_head list; /* For rwnx_vif.mesh_paths */
+	u8 path_idx; /* Path Index */
+	struct mac_addr tgt_mac_addr; /* Target MAC Address */
+	struct rwnx_sta *p_nhop_sta; /* Pointer to the Next Hop STA */
 };
 
 struct rwnx_mesh_proxy {
-    struct list_head list;          /* For rwnx_vif.mesh_proxy */
-    struct mac_addr ext_sta_addr;   /* Address of the External STA */
-    struct mac_addr proxy_addr;     /* Proxy MAC Address */
-    bool local;                     /* Indicate if interface is a proxy for the device */
+	struct list_head list; /* For rwnx_vif.mesh_proxy */
+	struct mac_addr ext_sta_addr; /* Address of the External STA */
+	struct mac_addr proxy_addr; /* Proxy MAC Address */
+	bool local; /* Indicate if interface is a proxy for the device */
 };
 
 /**
@@ -270,36 +273,36 @@ struct rwnx_mesh_proxy {
  * @work: work scheduled at the end of CSA
  */
 struct rwnx_csa {
-    struct rwnx_vif *vif;
-    struct rwnx_bcn bcn;
-    struct rwnx_ipc_elem_var elem;
-    struct cfg80211_chan_def chandef;
-    int count;
-    int status;
-    int ch_idx;
-    struct work_struct work;
+	struct rwnx_vif *vif;
+	struct rwnx_bcn bcn;
+	struct rwnx_ipc_elem_var elem;
+	struct cfg80211_chan_def chandef;
+	int count;
+	int status;
+	int ch_idx;
+	struct work_struct work;
 };
 
 struct apm_probe_sta {
-       u8 sta_mac_addr[6];
-       u8 vif_idx;
-       u64 probe_id;
-       struct work_struct apmprobestaWork;
-       struct workqueue_struct *apmprobesta_wq;
+	u8 sta_mac_addr[6];
+	u8 vif_idx;
+	u64 probe_id;
+	struct work_struct apmprobestaWork;
+	struct workqueue_struct *apmprobesta_wq;
 };
 
 /// Possible States of the TDLS link.
 enum tdls_status_tag {
-        /// TDLS link is not active (no TDLS peer connected)
-        TDLS_LINK_IDLE,
-        /// TDLS Setup Request transmitted
-        TDLS_SETUP_REQ_TX,
-        /// TDLS Setup Response transmitted
-        TDLS_SETUP_RSP_TX,
-        /// TDLS link is active (TDLS peer connected)
-        TDLS_LINK_ACTIVE,
-        /// TDLS Max Number of states.
-        TDLS_STATE_MAX
+	/// TDLS link is not active (no TDLS peer connected)
+	TDLS_LINK_IDLE,
+	/// TDLS Setup Request transmitted
+	TDLS_SETUP_REQ_TX,
+	/// TDLS Setup Response transmitted
+	TDLS_SETUP_RSP_TX,
+	/// TDLS link is active (TDLS peer connected)
+	TDLS_LINK_ACTIVE,
+	/// TDLS Max Number of states.
+	TDLS_STATE_MAX
 };
 
 /*
@@ -308,19 +311,18 @@ enum tdls_status_tag {
  *
  */
 struct rwnx_tdls {
-    bool active;                /* Indicate if TDLS link is active */
-    bool initiator;             /* Indicate if TDLS peer is the TDLS initiator */
-    bool chsw_en;               /* Indicate if channel switch is enabled */
-    u8 last_tid;                /* TID of the latest MPDU transmitted over the
+	bool active; /* Indicate if TDLS link is active */
+	bool initiator; /* Indicate if TDLS peer is the TDLS initiator */
+	bool chsw_en; /* Indicate if channel switch is enabled */
+	u8 last_tid; /* TID of the latest MPDU transmitted over the
                                    TDLS direct link to the TDLS STA */
-    u16 last_sn;                /* Sequence number of the latest MPDU transmitted
+	u16 last_sn; /* Sequence number of the latest MPDU transmitted
                                    over the TDLS direct link to the TDLS STA */
-    bool ps_on;                 /* Indicate if the power save is enabled on the
+	bool ps_on; /* Indicate if the power save is enabled on the
                                    TDLS STA */
-    bool chsw_allowed;          /* Indicate if TDLS channel switch is allowed */
+	bool chsw_allowed; /* Indicate if TDLS channel switch is allowed */
 };
 
-
 /**
  * enum rwnx_ap_flags - AP flags
  *
@@ -328,7 +330,7 @@ struct rwnx_tdls {
  *                                   one client for another one)
  */
 enum rwnx_ap_flags {
-    RWNX_AP_ISOLATE = BIT(0),
+	RWNX_AP_ISOLATE = BIT(0),
 };
 
 /*
@@ -337,93 +339,96 @@ enum rwnx_ap_flags {
  *
  */
 struct rwnx_vif {
-    struct list_head list;
-    struct rwnx_hw *rwnx_hw;
-    struct wireless_dev wdev;
-    struct net_device *ndev;
-    struct net_device_stats net_stats;
-    struct rwnx_key key[6];
-    unsigned long drv_flags;
-    atomic_t drv_conn_state;
-    u8 drv_vif_index;           /* Identifier of the VIF in driver */
-    u8 vif_index;               /* Identifier of the station in FW */
-    u8 ch_index;                /* Channel context identifier */
-    bool up;                    /* Indicate if associated netdev is up
+	struct list_head list;
+	struct rwnx_hw *rwnx_hw;
+	struct wireless_dev wdev;
+	struct net_device *ndev;
+	struct net_device_stats net_stats;
+	struct rwnx_key key[6];
+	unsigned long drv_flags;
+	atomic_t drv_conn_state;
+	u8 drv_vif_index; /* Identifier of the VIF in driver */
+	u8 vif_index; /* Identifier of the station in FW */
+	u8 ch_index; /* Channel context identifier */
+	bool up; /* Indicate if associated netdev is up
                                    (i.e. Interface is created at fw level) */
-    bool use_4addr;             /* Should we use 4addresses mode */
-    bool is_resending;          /* Indicate if a frame is being resent on this interface */
-    bool user_mpm;              /* In case of Mesh Point VIF, indicate if MPM is handled by userspace */
-    bool roc_tdls;              /* Indicate if the ROC has been called by a
+	bool use_4addr; /* Should we use 4addresses mode */
+	bool is_resending; /* Indicate if a frame is being resent on this interface */
+	bool user_mpm; /* In case of Mesh Point VIF, indicate if MPM is handled by userspace */
+	bool roc_tdls; /* Indicate if the ROC has been called by a
                                    TDLS station */
-    u8 tdls_status;             /* Status of the TDLS link */
-    bool tdls_chsw_prohibited;  /* Indicate if TDLS Channel Switch is prohibited */
-    bool wep_enabled;           /* 1 if WEP is enabled */
-    bool wep_auth_err;          /* 1 if auth status code is not supported auth alg when WEP enabled */
-    enum nl80211_auth_type last_auth_type; /* Authentication type (algorithm) sent in the last connection
+	u8 tdls_status; /* Status of the TDLS link */
+	bool tdls_chsw_prohibited; /* Indicate if TDLS Channel Switch is prohibited */
+	bool wep_enabled; /* 1 if WEP is enabled */
+	bool wep_auth_err; /* 1 if auth status code is not supported auth alg when WEP enabled */
+	enum nl80211_auth_type
+		last_auth_type; /* Authentication type (algorithm) sent in the last connection
                                               when WEP enabled */
-    union
-    {
-        struct
-        {
-            struct rwnx_sta *ap; /* Pointer to the peer STA entry allocated for
+	union {
+		struct {
+			struct rwnx_sta *
+				ap; /* Pointer to the peer STA entry allocated for
                                     the AP */
-            struct rwnx_sta *tdls_sta; /* Pointer to the TDLS station */
-            bool external_auth;  /* Indicate if external authentication is in progress */
-            u32 group_cipher_type;
-            u32 paired_cipher_type;
+			struct rwnx_sta
+				*tdls_sta; /* Pointer to the TDLS station */
+			bool external_auth; /* Indicate if external authentication is in progress */
+			u32 group_cipher_type;
+			u32 paired_cipher_type;
 			//connected network info start
-			char ssid[33];//ssid max is 32, but this has one spare for '\0'
+			char ssid[33]; //ssid max is 32, but this has one spare for '\0'
 			int ssid_len;
 			u8 bssid[ETH_ALEN];
 			u32 conn_owner_nlportid;
 			bool is_roam;
 			//connected network info end
-        } sta;
-        struct
-        {
-            u16 flags;                 /* see rwnx_ap_flags */
-            struct list_head sta_list; /* List of STA connected to the AP */
-            struct rwnx_bcn bcn;       /* beacon */
-            u8 bcmc_index;             /* Index of the BCMC sta to use */
-            #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
+		} sta;
+		struct {
+			u16 flags; /* see rwnx_ap_flags */
+			struct list_head
+				sta_list; /* List of STA connected to the AP */
+			struct rwnx_bcn bcn; /* beacon */
+			u8 bcmc_index; /* Index of the BCMC sta to use */
+#if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
 			u8 aic_index;
-            #endif
-            struct rwnx_csa *csa;
+#endif
+			struct rwnx_csa *csa;
 
-            struct list_head mpath_list; /* List of Mesh Paths used on this interface */
-            struct list_head proxy_list; /* List of Proxies Information used on this interface */
-            bool create_path;            /* Indicate if we are waiting for a MESH_CREATE_PATH_CFM
+			struct list_head
+				mpath_list; /* List of Mesh Paths used on this interface */
+			struct list_head
+				proxy_list; /* List of Proxies Information used on this interface */
+			bool create_path; /* Indicate if we are waiting for a MESH_CREATE_PATH_CFM
                                             message */
-            int generation;              /* Increased each time the list of Mesh Paths is updated */
-            enum nl80211_mesh_power_mode mesh_pm; /* mesh power save mode currently set in firmware */
-            enum nl80211_mesh_power_mode next_mesh_pm; /* mesh power save mode for next peer */
-        } ap;
-        struct
-        {
-            struct rwnx_vif *master;   /* pointer on master interface */
-            struct rwnx_sta *sta_4a;
-        } ap_vlan;
-    };
+			int generation; /* Increased each time the list of Mesh Paths is updated */
+			enum nl80211_mesh_power_mode
+				mesh_pm; /* mesh power save mode currently set in firmware */
+			enum nl80211_mesh_power_mode
+				next_mesh_pm; /* mesh power save mode for next peer */
+		} ap;
+		struct {
+			struct rwnx_vif *master; /* pointer on master interface */
+			struct rwnx_sta *sta_4a;
+		} ap_vlan;
+	};
 
 	u8_l key_has_add;
 	u8_l is_p2p_vif;
 	struct apm_probe_sta sta_probe;
 
-    #ifdef CONFIG_BR_SUPPORT
-	spinlock_t			    br_ext_lock;
+#ifdef CONFIG_BR_SUPPORT
+	spinlock_t br_ext_lock;
 	/* unsigned int			macclone_completed; */
-	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
-	int				pppoe_connection_in_progress;
-	unsigned char			pppoe_addr[MACADDRLEN];
-	unsigned char			scdb_mac[MACADDRLEN];
-	unsigned char			scdb_ip[4];
-	struct nat25_network_db_entry	*scdb_entry;
-	unsigned char			br_mac[MACADDRLEN];
-	unsigned char			br_ip[4];
-
-	struct br_ext_info		ethBrExtInfo;
-    #endif /* CONFIG_BR_SUPPORT */
-
+	struct nat25_network_db_entry *nethash[NAT25_HASH_SIZE];
+	int pppoe_connection_in_progress;
+	unsigned char pppoe_addr[MACADDRLEN];
+	unsigned char scdb_mac[MACADDRLEN];
+	unsigned char scdb_ip[4];
+	struct nat25_network_db_entry *scdb_entry;
+	unsigned char br_mac[MACADDRLEN];
+	unsigned char br_ip[4];
+
+	struct br_ext_info ethBrExtInfo;
+#endif /* CONFIG_BR_SUPPORT */
 };
 
 #define RWNX_VIF_TYPE(rwnx_vif) (rwnx_vif->wdev.iftype)
@@ -440,9 +445,9 @@ struct rwnx_vif {
  *          (1 counter for Legacy PS and 1 for U-APSD)
  */
 struct rwnx_sta_ps {
-    bool active;
-    u16 pkt_ready[2];
-    u16 sp_cnt[2];
+	bool active;
+	u16 pkt_ready[2];
+	u16 sp_cnt[2];
 };
 
 /**
@@ -454,10 +459,10 @@ struct rwnx_sta_ps {
  * @cpt: number of frames received
  */
 struct rwnx_rx_rate_stats {
-    int *table;
-    int size;
-    int cpt;
-    int rate_cnt;
+	int *table;
+	int size;
+	int cpt;
+	int rate_cnt;
 };
 
 /**
@@ -467,17 +472,17 @@ struct rwnx_rx_rate_stats {
  * @rx_rate: Statistics of the received rates
  */
 struct rwnx_sta_stats {
-//#ifdef CONFIG_RWNX_DEBUGFS
-    struct hw_vect last_rx;
-    struct rwnx_rx_rate_stats rx_rate;
-//#endif
+	//#ifdef CONFIG_RWNX_DEBUGFS
+	struct hw_vect last_rx;
+	struct rwnx_rx_rate_stats rx_rate;
+	//#endif
 };
 
 #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
 struct aic_sta {
-    u8 sta_idx;            /* Identifier of the station */
-	bool he;               /* Flag indicating if the station supports HE */
-    bool vht;               /* Flag indicating if the station supports VHT */
+	u8 sta_idx; /* Identifier of the station */
+	bool he; /* Flag indicating if the station supports HE */
+	bool vht; /* Flag indicating if the station supports VHT */
 };
 #endif
 
@@ -485,101 +490,104 @@ struct aic_sta {
  * Structure used to save information relative to the managed stations.
  */
 struct rwnx_sta {
-    struct list_head list;
-    u16 aid;                /* association ID */
-    u8 sta_idx;             /* Identifier of the station */
-    u8 vif_idx;             /* Identifier of the VIF (fw id) the station
+	struct list_head list;
+	u16 aid; /* association ID */
+	u8 sta_idx; /* Identifier of the station */
+	u8 vif_idx; /* Identifier of the VIF (fw id) the station
                                belongs to */
-    u8 vlan_idx;            /* Identifier of the VLAN VIF (fw id) the station
+	u8 vlan_idx; /* Identifier of the VLAN VIF (fw id) the station
                                belongs to (= vif_idx if no vlan in used) */
-    enum nl80211_band band; /* Band */
-    enum nl80211_chan_width width; /* Channel width */
-    u16 center_freq;        /* Center frequency */
-    u32 center_freq1;       /* Center frequency 1 */
-    u32 center_freq2;       /* Center frequency 2 */
-    u8 ch_idx;              /* Identifier of the channel
+	enum nl80211_band band; /* Band */
+	enum nl80211_chan_width width; /* Channel width */
+	u16 center_freq; /* Center frequency */
+	u32 center_freq1; /* Center frequency 1 */
+	u32 center_freq2; /* Center frequency 2 */
+	u8 ch_idx; /* Identifier of the channel
                                context the station belongs to */
-    bool qos;               /* Flag indicating if the station
+	bool qos; /* Flag indicating if the station
                                supports QoS */
-    u8 acm;                 /* Bitfield indicating which queues
+	u8 acm; /* Bitfield indicating which queues
                                have AC mandatory */
-    u16 uapsd_tids;         /* Bitfield indicating which tids are subject to
+	u16 uapsd_tids; /* Bitfield indicating which tids are subject to
                                UAPSD */
-    u8 mac_addr[ETH_ALEN];  /* MAC address of the station */
-    struct rwnx_key key;
-    bool valid;             /* Flag indicating if the entry is valid */
-    struct rwnx_sta_ps ps;  /* Information when STA is in PS (AP only) */
+	u8 mac_addr[ETH_ALEN]; /* MAC address of the station */
+	struct rwnx_key key;
+	bool valid; /* Flag indicating if the entry is valid */
+	struct rwnx_sta_ps ps; /* Information when STA is in PS (AP only) */
 #ifdef CONFIG_RWNX_BFMER
-    struct rwnx_bfmer_report *bfm_report;     /* Beamforming report to be used for
+	struct rwnx_bfmer_report *bfm_report; /* Beamforming report to be used for
                                                  VHT TX Beamforming */
 #ifdef CONFIG_RWNX_MUMIMO_TX
-    struct rwnx_sta_group_info group_info; /* MU grouping information for the STA */
+	struct rwnx_sta_group_info
+		group_info; /* MU grouping information for the STA */
 #endif /* CONFIG_RWNX_MUMIMO_TX */
 #endif /* CONFIG_RWNX_BFMER */
 
-    bool ht;               /* Flag indicating if the station
+	bool ht; /* Flag indicating if the station
                                supports HT */
-    bool vht;               /* Flag indicating if the station
+	bool vht; /* Flag indicating if the station
                                supports VHT */
-    u32 ac_param[AC_MAX];  /* EDCA parameters */
-    struct rwnx_tdls tdls; /* TDLS station information */
-    struct rwnx_sta_stats stats;
-    enum nl80211_mesh_power_mode mesh_pm; /*  link-specific mesh power save mode */
+	u32 ac_param[AC_MAX]; /* EDCA parameters */
+	struct rwnx_tdls tdls; /* TDLS station information */
+	struct rwnx_sta_stats stats;
+	enum nl80211_mesh_power_mode
+		mesh_pm; /*  link-specific mesh power save mode */
 };
 
-static inline const u8 *rwnx_sta_addr(struct rwnx_sta *rwnx_sta) {
-    return rwnx_sta->mac_addr;
+static inline const u8 *rwnx_sta_addr(struct rwnx_sta *rwnx_sta)
+{
+	return rwnx_sta->mac_addr;
 }
 
 #ifdef CONFIG_RWNX_SPLIT_TX_BUF
 struct rwnx_amsdu_stats {
-    int done;
-    int failed;
+	int done;
+	int failed;
 };
 #endif
 
 struct rwnx_stats {
-    int cfm_balance[NX_TXQ_CNT];
-    unsigned long last_rx, last_tx; /* jiffies */
-    int ampdus_tx[IEEE80211_MAX_AMPDU_BUF];
-    int ampdus_rx[IEEE80211_MAX_AMPDU_BUF];
-    int ampdus_rx_map[4];
-    int ampdus_rx_miss;
+	int cfm_balance[NX_TXQ_CNT];
+	unsigned long last_rx, last_tx; /* jiffies */
+	int ampdus_tx[IEEE80211_MAX_AMPDU_BUF];
+	int ampdus_rx[IEEE80211_MAX_AMPDU_BUF];
+	int ampdus_rx_map[4];
+	int ampdus_rx_miss;
 #ifdef CONFIG_RWNX_SPLIT_TX_BUF
-    struct rwnx_amsdu_stats amsdus[NX_TX_PAYLOAD_MAX];
+	struct rwnx_amsdu_stats amsdus[NX_TX_PAYLOAD_MAX];
 #endif
-    int amsdus_rx[64];
+	int amsdus_rx[64];
 };
 
 struct rwnx_sec_phy_chan {
-    u16 prim20_freq;
-    u16 center_freq1;
-    u16 center_freq2;
-    enum nl80211_band band;
-    u8 type;
+	u16 prim20_freq;
+	u16 center_freq1;
+	u16 center_freq2;
+	enum nl80211_band band;
+	u8 type;
 };
 
 /* Structure that will contains all RoC information received from cfg80211 */
 struct rwnx_roc_elem {
-    struct wireless_dev *wdev;
-    struct ieee80211_channel *chan;
-    unsigned int duration;
-    /* Used to avoid call of CFG80211 callback upon expiration of RoC */
-    bool mgmt_roc;
-    /* Indicate if we have switch on the RoC channel */
-    bool on_chan;
+	struct wireless_dev *wdev;
+	struct ieee80211_channel *chan;
+	unsigned int duration;
+	/* Used to avoid call of CFG80211 callback upon expiration of RoC */
+	bool mgmt_roc;
+	/* Indicate if we have switch on the RoC channel */
+	bool on_chan;
 };
 
 /* Structure containing channel survey information received from MAC */
 struct rwnx_survey_info {
-    // Filled
-    u32 filled;
-    // Amount of time in ms the radio spent on the channel
-    u32 chan_time_ms;
-    // Amount of time the primary channel was sensed busy
-    u32 chan_time_busy_ms;
-    // Noise in dbm
-    s8 noise_dbm;
+	// Filled
+	u32 filled;
+	// Amount of time in ms the radio spent on the channel
+	u32 chan_time_ms;
+	// Amount of time the primary channel was sensed busy
+	u32 chan_time_busy_ms;
+	// Noise in dbm
+	s8 noise_dbm;
 };
 
 #define RWNX_CH_NOT_SET 0xFF
@@ -588,8 +596,8 @@ struct rwnx_survey_info {
 
 /* Structure containing channel context information */
 struct rwnx_chanctx {
-    struct cfg80211_chan_def chan_def; /* channel description */
-    u8 count;                          /* number of vif using this ctxt */
+	struct cfg80211_chan_def chan_def; /* channel description */
+	u8 count; /* number of vif using this ctxt */
 };
 
 /**
@@ -602,151 +610,190 @@ struct rwnx_chanctx {
  * VHT with old radio that don't support 80MHz (deprecated)
  */
 struct rwnx_phy_info {
-    u8 cnt;
-    struct phy_cfg_tag cfg;
-    struct rwnx_sec_phy_chan sec_chan;
-    bool limit_bw;
+	u8 cnt;
+	struct phy_cfg_tag cfg;
+	struct rwnx_sec_phy_chan sec_chan;
+	bool limit_bw;
+};
+
+struct defrag_ctrl_info {
+	struct list_head list;
+	u8 sta_idx;
+	u8 tid;
+	u16 sn;
+	u8 next_fn;
+	u16 frm_len;
+	struct sk_buff *skb;
+	struct timer_list defrag_timer;
+	struct rwnx_hw *rwnx_hw;
+};
+
+struct amsdu_subframe_hdr {
+	u8 da[6];
+	u8 sa[6];
+	u16 sublen;
 };
 
 /* rwnx driver status */
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state);
 
-enum rwnx_drv_connect_status { 
+enum rwnx_drv_connect_status {
 	RWNX_DRV_STATUS_DISCONNECTED = 0,
-	RWNX_DRV_STATUS_DISCONNECTING, 
-	RWNX_DRV_STATUS_CONNECTING, 
-	RWNX_DRV_STATUS_CONNECTED, 
+	RWNX_DRV_STATUS_DISCONNECTING,
+	RWNX_DRV_STATUS_CONNECTING,
+	RWNX_DRV_STATUS_CONNECTED,
+	RWNX_DRV_STATUS_ROAMING,
 };
 
+static const char *const s_conn_state[] = {
+	"RWNX_DRV_STATUS_DISCONNECTED", "RWNX_DRV_STATUS_DISCONNECTING",
+	"RWNX_DRV_STATUS_CONNECTING",	"RWNX_DRV_STATUS_CONNECTED",
+	"RWNX_DRV_STATUS_ROAMING",
+};
 
 struct sta_tx_flowctrl {
 	atomic_t tx_pending_cnt;
-    u8 flowctrl;
+	u8 flowctrl;
 };
 
 struct rwnx_hw {
-    struct rwnx_mod_params *mod_params;
-    struct device *dev;
+	struct rwnx_mod_params *mod_params;
+	struct device *dev;
 #ifdef AICWF_SDIO_SUPPORT
-    struct aic_sdio_dev *sdiodev;
+	struct aic_sdio_dev *sdiodev;
 #endif
 #ifdef AICWF_USB_SUPPORT
-    struct aic_usb_dev *usbdev;
+	struct aic_usb_dev *usbdev;
 #endif
-    struct wiphy *wiphy;
-    struct list_head vifs;
-    struct rwnx_vif *vif_table[NX_VIRT_DEV_MAX + NX_REMOTE_STA_MAX]; /* indexed with fw id */
-    struct rwnx_sta sta_table[NX_REMOTE_STA_MAX + NX_VIRT_DEV_MAX];
-    #ifdef CONFIG_HE_FOR_OLD_KERNEL
+	struct wiphy *wiphy;
+	struct list_head vifs;
+	struct rwnx_vif *vif_table[NX_VIRT_DEV_MAX +
+				   NX_REMOTE_STA_MAX]; /* indexed with fw id */
+	struct rwnx_sta sta_table[NX_REMOTE_STA_MAX + NX_VIRT_DEV_MAX];
+#ifdef CONFIG_HE_FOR_OLD_KERNEL
 	struct aic_sta aic_table[NX_REMOTE_STA_MAX + NX_VIRT_DEV_MAX];
-    #endif
-    struct rwnx_survey_info survey[SCAN_CHANNEL_MAX];
-    struct cfg80211_scan_request *scan_request;
+#endif
+	struct rwnx_survey_info survey[SCAN_CHANNEL_MAX];
+	struct cfg80211_scan_request *scan_request;
 #ifdef CONFIG_SCHED_SCAN
-    struct cfg80211_sched_scan_request *sched_scan_req;
+	struct cfg80211_sched_scan_request *sched_scan_req;
 #endif
-    struct rwnx_chanctx chanctx_table[NX_CHAN_CTXT_CNT];
-    u8 cur_chanctx;
+	struct rwnx_chanctx chanctx_table[NX_CHAN_CTXT_CNT];
+	u8 cur_chanctx;
 
-    u8 monitor_vif; /* FW id of the monitor interface, RWNX_INVALID_VIF if no monitor vif at fw level */
+	u8 monitor_vif; /* FW id of the monitor interface, RWNX_INVALID_VIF if no monitor vif at fw level */
 #ifdef CONFIG_FILTER_TCP_ACK
-       /* tcp ack management */
-    struct tcp_ack_manage ack_m;
+	/* tcp ack management */
+	struct tcp_ack_manage ack_m;
 #endif
-    /* RoC Management */
-    struct rwnx_roc_elem *roc_elem;             /* Information provided by cfg80211 in its remain on channel request */
-    u32 roc_cookie_cnt;                         /* Counter used to identify RoC request sent by cfg80211 */
+	/* RoC Management */
+	struct rwnx_roc_elem *
+		roc_elem; /* Information provided by cfg80211 in its remain on channel request */
+	u32 roc_cookie_cnt; /* Counter used to identify RoC request sent by cfg80211 */
 
-    struct rwnx_cmd_mgr *cmd_mgr;
+	struct rwnx_cmd_mgr *cmd_mgr;
 
-    struct rwnx_plat *plat;
+	struct rwnx_plat *plat;
 
-    spinlock_t tx_lock;
-    spinlock_t cb_lock;
-    struct mutex mutex;                         /* per-device perimeter lock */
+	spinlock_t tx_lock;
+	spinlock_t cb_lock;
+	struct mutex mutex; /* per-device perimeter lock */
 
-    struct tasklet_struct task;
-    struct mm_version_cfm version_cfm;          /* Lower layers versions - obtained via MM_VERSION_REQ */
+	struct tasklet_struct task;
+	struct mm_version_cfm
+		version_cfm; /* Lower layers versions - obtained via MM_VERSION_REQ */
 
-    u32 tcp_pacing_shift;
+	u32 tcp_pacing_shift;
 
-    /* IPC */
-    struct ipc_host_env_tag *ipc_env;
+	/* IPC */
+	struct ipc_host_env_tag *ipc_env;
 #ifdef AICWF_SDIO_SUPPORT
-    struct sdio_host_env_tag sdio_env;
+	struct sdio_host_env_tag sdio_env;
 #endif
 #ifdef AICWF_USB_SUPPORT
-    struct usb_host_env_tag usb_env;
+	struct usb_host_env_tag usb_env;
 #endif
 
-    struct rwnx_ipc_elem_pool e2amsgs_pool;
-    struct rwnx_ipc_elem_pool dbgmsgs_pool;
-    struct rwnx_ipc_elem_pool e2aradars_pool;
-    struct rwnx_ipc_elem_var pattern_elem;
-    struct rwnx_ipc_dbgdump_elem dbgdump_elem;
-    struct rwnx_ipc_elem_pool e2arxdesc_pool;
-    struct rwnx_ipc_skb_elem *e2aunsuprxvec_elems;
-    //struct rwnx_ipc_rxbuf_elems rxbuf_elems;
-    struct rwnx_ipc_elem_var scan_ie;
+	struct rwnx_ipc_elem_pool e2amsgs_pool;
+	struct rwnx_ipc_elem_pool dbgmsgs_pool;
+	struct rwnx_ipc_elem_pool e2aradars_pool;
+	struct rwnx_ipc_elem_var pattern_elem;
+	struct rwnx_ipc_dbgdump_elem dbgdump_elem;
+	struct rwnx_ipc_elem_pool e2arxdesc_pool;
+	struct rwnx_ipc_skb_elem *e2aunsuprxvec_elems;
+	//struct rwnx_ipc_rxbuf_elems rxbuf_elems;
+	struct rwnx_ipc_elem_var scan_ie;
 
-    struct kmem_cache      *sw_txhdr_cache;
+	struct kmem_cache *sw_txhdr_cache;
 
-    struct rwnx_debugfs     debugfs;
-    struct rwnx_stats       stats;
+	struct rwnx_debugfs debugfs;
+	struct rwnx_stats stats;
 
 #ifdef CONFIG_PREALLOC_TXQ
-    struct rwnx_txq *txq;
+	struct rwnx_txq *txq;
 #else
-    struct rwnx_txq txq[NX_NB_TXQ];
+	struct rwnx_txq txq[NX_NB_TXQ];
 #endif
-    struct rwnx_hwq hwq[NX_TXQ_CNT];
+	struct rwnx_hwq hwq[NX_TXQ_CNT];
 
-    u64 avail_idx_map;
-    u8 vif_started;
-    bool adding_sta;
-    struct rwnx_phy_info phy;
+	u64 avail_idx_map;
+	u8 vif_started;
+	bool adding_sta;
+	struct rwnx_phy_info phy;
 
-    struct rwnx_radar radar;
+	struct rwnx_radar radar;
 
-    /* extended capabilities supported */
-    u8 ext_capa[8];
+	/* extended capabilities supported */
+	u8 ext_capa[8];
 
 #ifdef CONFIG_RWNX_MUMIMO_TX
-    struct rwnx_mu_info mu;
+	struct rwnx_mu_info mu;
 #endif
-    u8 is_p2p_alive;
-    u8 is_p2p_connected;
-    struct timer_list p2p_alive_timer;
-    struct rwnx_vif *p2p_dev_vif;
-    atomic_t p2p_alive_timer_count;
-    bool band_5g_support;
-    bool fwlog_en;
+	u8 is_p2p_alive;
+	u8 is_p2p_connected;
+	struct timer_list p2p_alive_timer;
+	struct rwnx_vif *p2p_dev_vif;
+	atomic_t p2p_alive_timer_count;
+	bool band_5g_support;
+	bool fwlog_en;
+	bool scanning;
+	bool p2p_working;
+
+	struct list_head defrag_list;
+	spinlock_t defrag_lock;
 
 	struct work_struct apmStalossWork;
-    struct workqueue_struct *apmStaloss_wq;
-    u8 apm_vif_idx;
-    u8 sta_mac_addr[6];
+	struct workqueue_struct *apmStaloss_wq;
+	u8 apm_vif_idx;
+	u8 sta_mac_addr[6];
+
+	struct wakeup_source *ws_rx;
+	struct wakeup_source *ws_irqrx;
+	struct wakeup_source *ws_tx;
+	struct wakeup_source *ws_pwrctrl;
+
 #ifdef CONFIG_SCHED_SCAN
-        bool is_sched_scan;
-#endif//CONFIG_SCHED_SCAN 
+	bool is_sched_scan;
+#endif //CONFIG_SCHED_SCAN
 
 	struct sta_tx_flowctrl sta_flowctrl[NX_REMOTE_STA_MAX];
 #if 0
 	bool he_flag;
 #endif
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-    struct mac_chan_op ap_chan;
-    struct ieee80211_channel set_chan;
+	struct mac_chan_op ap_chan;
+	struct ieee80211_channel set_chan;
 #endif
 #ifdef CONFIG_VHT_FOR_OLD_KERNEL
-    struct ieee80211_sta_vht_cap vht_cap_2G;
-    struct ieee80211_sta_vht_cap vht_cap_5G;
+	struct ieee80211_sta_vht_cap vht_cap_2G;
+	struct ieee80211_sta_vht_cap vht_cap_5G;
 #endif
 
 #ifdef CONFIG_USE_WIRELESS_EXT
 	bool wext_scan;
 	struct completion wext_scan_com;
 	struct list_head wext_scanre_list;
-	char wext_essid[32];
+	char wext_essid[33];
 	int support_freqs[SCAN_CHANNEL_MAX];
 	int support_freqs_number;
 #endif
@@ -755,32 +802,31 @@ struct rwnx_hw {
 u8 *rwnx_build_bcn(struct rwnx_bcn *bcn, struct cfg80211_beacon_data *new);
 
 void rwnx_chanctx_link(struct rwnx_vif *vif, u8 idx,
-                        struct cfg80211_chan_def *chandef);
+		       struct cfg80211_chan_def *chandef);
 void rwnx_chanctx_unlink(struct rwnx_vif *vif);
-int  rwnx_chanctx_valid(struct rwnx_hw *rwnx_hw, u8 idx);
+int rwnx_chanctx_valid(struct rwnx_hw *rwnx_hw, u8 idx);
 
 extern u8 chip_id;
 static inline bool is_multicast_sta(int sta_idx)
 {
-
-	if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) || 
-		((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
+	if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
+	    ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) &&
+	     chip_id < 3)) {
 		return (sta_idx >= NX_REMOTE_STA_MAX_FOR_OLD_IC);
-	}else{
+	} else {
 		return (sta_idx >= NX_REMOTE_STA_MAX);
 	}
-
 }
 struct rwnx_sta *rwnx_get_sta(struct rwnx_hw *rwnx_hw, const u8 *mac_addr);
 
 static inline uint8_t master_vif_idx(struct rwnx_vif *vif)
 {
-    if (unlikely(vif->wdev.iftype == NL80211_IFTYPE_AP_VLAN)) {
-        return vif->ap_vlan.master->vif_index;
-    } else {
-        return vif->vif_index;
-    }
+	if (unlikely(vif->wdev.iftype == NL80211_IFTYPE_AP_VLAN)) {
+		return vif->ap_vlan.master->vif_index;
+	} else {
+		return vif->vif_index;
+	}
 }
 
 void rwnx_external_auth_enable(struct rwnx_vif *vif);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index 6d7b85df3..2e15169ac 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -43,7 +43,9 @@
 #include "aicwf_txrxif.h"
 #include "aicwf_compat_8800dc.h"
 #include "aicwf_compat_8800d80.h"
-
+#include "aicwf_compat_8800d80x2.h"
+#include "aic_priv_cmd.h"
+#include "rwnx_wakelock.h"
 
 #ifdef CONFIG_USE_WIRELESS_EXT
 #include "aicwf_wext_linux.h"
@@ -57,15 +59,15 @@
 #endif
 #include <linux/semaphore.h>
 
-#define RW_DRV_DESCRIPTION  "RivieraWaves 11nac driver for Linux cfg80211"
-#define RW_DRV_COPYRIGHT    "Copyright(c) 2015-2017 RivieraWaves"
-#define RW_DRV_AUTHOR       "RivieraWaves S.A.S"
+#define RW_DRV_DESCRIPTION "RivieraWaves 11nac driver for Linux cfg80211"
+#define RW_DRV_COPYRIGHT "Copyright(c) 2015-2017 RivieraWaves"
+#define RW_DRV_AUTHOR "RivieraWaves S.A.S"
 
 #define RWNX_PRINT_CFM_ERR(req) \
-        printk(KERN_CRIT "%s: Status Error(%d)\n", #req, (&req##_cfm)->status)
+	printk(KERN_CRIT "%s: Status Error(%d)\n", #req, (&req##_cfm)->status)
 
-#define RWNX_HT_CAPABILITIES                                    \
-{                                                               \
+#define RWNX_HT_CAPABILITIES \
+	{                                                               \
     .ht_supported   = true,                                     \
     .cap            = 0,                                        \
     .ampdu_factor   = IEEE80211_HT_MAX_AMPDU_64K,               \
@@ -77,36 +79,37 @@
     },                                                          \
 }
 
-#define RWNX_VHT_CAPABILITIES                                   \
-{                                                               \
-    .vht_supported = false,                                     \
-    .cap       =                                                \
-      (7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT),\
-    .vht_mcs       = {                                          \
-        .rx_mcs_map = cpu_to_le16(                              \
-                      IEEE80211_VHT_MCS_SUPPORT_0_9    << 0  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 2  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 4  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 6  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 8  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 10 |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 12 |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 14),  \
-        .tx_mcs_map = cpu_to_le16(                              \
-                      IEEE80211_VHT_MCS_SUPPORT_0_9    << 0  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 2  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 4  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 6  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 8  |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 10 |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 12 |  \
-                      IEEE80211_VHT_MCS_NOT_SUPPORTED  << 14),  \
-    }                                                           \
-}
+#define RWNX_VHT_CAPABILITIES                                                   \
+	{                                                                       \
+		.vht_supported = false,                                         \
+		.cap = (7                                                       \
+			<< IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT), \
+		.vht_mcs = {                                                    \
+			.rx_mcs_map = cpu_to_le16(                              \
+				IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |            \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 2 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |         \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |         \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 14),         \
+			.tx_mcs_map = cpu_to_le16(                              \
+				IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |            \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 2 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |          \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |         \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |         \
+				IEEE80211_VHT_MCS_NOT_SUPPORTED << 14),         \
+		}                                                               \
+	}
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0) || defined(CONFIG_HE_FOR_OLD_KERNEL)
-#define RWNX_HE_CAPABILITIES                                    \
-{                                                               \
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0) || \
+	defined(CONFIG_HE_FOR_OLD_KERNEL)
+#define RWNX_HE_CAPABILITIES \
+	{                                                               \
     .has_he = false,                                            \
     .he_cap_elem = {                                            \
         .mac_cap_info[0] = 0,                                   \
@@ -139,8 +142,8 @@
 }
 #else
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-#define RWNX_HE_CAPABILITIES                                    \
-{                                                               \
+#define RWNX_HE_CAPABILITIES \
+	{                                                               \
     .has_he = false,                                            \
     .he_cap_elem = {                                            \
         .mac_cap_info[0] = 0,                                   \
@@ -171,237 +174,245 @@
 #endif
 #endif
 
-#define RATE(_bitrate, _hw_rate, _flags) {      \
-    .bitrate    = (_bitrate),                   \
-    .flags      = (_flags),                     \
-    .hw_value   = (_hw_rate),                   \
-}
+#define RATE(_bitrate, _hw_rate, _flags) \
+	{                                \
+		.bitrate = (_bitrate),   \
+		.flags = (_flags),       \
+		.hw_value = (_hw_rate),  \
+	}
 
-#define CHAN(_freq) {                           \
-    .center_freq    = (_freq),                  \
-    .max_power  = 30, /* FIXME */               \
-}
+#define CHAN(_freq)                                                  \
+	{                                                            \
+		.center_freq = (_freq), .max_power = 30, /* FIXME */ \
+	}
 
 static struct ieee80211_rate rwnx_ratetable[] = {
-    RATE(10,  0x00, 0),
-    RATE(20,  0x01, IEEE80211_RATE_SHORT_PREAMBLE),
-    RATE(55,  0x02, IEEE80211_RATE_SHORT_PREAMBLE),
-    RATE(110, 0x03, IEEE80211_RATE_SHORT_PREAMBLE),
-    RATE(60,  0x04, 0),
-    RATE(90,  0x05, 0),
-    RATE(120, 0x06, 0),
-    RATE(180, 0x07, 0),
-    RATE(240, 0x08, 0),
-    RATE(360, 0x09, 0),
-    RATE(480, 0x0A, 0),
-    RATE(540, 0x0B, 0),
+	RATE(10, 0x00, 0),
+	RATE(20, 0x01, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(55, 0x02, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(110, 0x03, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(60, 0x04, 0),
+	RATE(90, 0x05, 0),
+	RATE(120, 0x06, 0),
+	RATE(180, 0x07, 0),
+	RATE(240, 0x08, 0),
+	RATE(360, 0x09, 0),
+	RATE(480, 0x0A, 0),
+	RATE(540, 0x0B, 0),
 };
 
 /* The channels indexes here are not used anymore */
 static struct ieee80211_channel rwnx_2ghz_channels[] = {
-    CHAN(2412),
-    CHAN(2417),
-    CHAN(2422),
-    CHAN(2427),
-    CHAN(2432),
-    CHAN(2437),
-    CHAN(2442),
-    CHAN(2447),
-    CHAN(2452),
-    CHAN(2457),
-    CHAN(2462),
-    CHAN(2467),
-    CHAN(2472),
-    CHAN(2484),
-    // Extra channels defined only to be used for PHY measures.
-    // Enabled only if custregd and custchan parameters are set
-    CHAN(2390),
-    CHAN(2400),
-    CHAN(2410),
-    CHAN(2420),
-    CHAN(2430),
-    CHAN(2440),
-    CHAN(2450),
-    CHAN(2460),
-    CHAN(2470),
-    CHAN(2480),
-    CHAN(2490),
-    CHAN(2500),
-    CHAN(2510),
+	CHAN(2412),
+	CHAN(2417),
+	CHAN(2422),
+	CHAN(2427),
+	CHAN(2432),
+	CHAN(2437),
+	CHAN(2442),
+	CHAN(2447),
+	CHAN(2452),
+	CHAN(2457),
+	CHAN(2462),
+	CHAN(2467),
+	CHAN(2472),
+	CHAN(2484),
+	// Extra channels defined only to be used for PHY measures.
+	// Enabled only if custregd and custchan parameters are set
+	CHAN(2390),
+	CHAN(2400),
+	CHAN(2410),
+	CHAN(2420),
+	CHAN(2430),
+	CHAN(2440),
+	CHAN(2450),
+	CHAN(2460),
+	CHAN(2470),
+	CHAN(2480),
+	CHAN(2490),
+	CHAN(2500),
+	CHAN(2510),
 };
 
 //#ifdef USE_5G
 static struct ieee80211_channel rwnx_5ghz_channels[] = {
-    CHAN(5180),             // 36 -   20MHz
-    CHAN(5200),             // 40 -   20MHz
-    CHAN(5220),             // 44 -   20MHz
-    CHAN(5240),             // 48 -   20MHz
-    CHAN(5260),             // 52 -   20MHz
-    CHAN(5280),             // 56 -   20MHz
-    CHAN(5300),             // 60 -   20MHz
-    CHAN(5320),             // 64 -   20MHz
-    CHAN(5500),             // 100 -  20MHz
-    CHAN(5520),             // 104 -  20MHz
-    CHAN(5540),             // 108 -  20MHz
-    CHAN(5560),             // 112 -  20MHz
-    CHAN(5580),             // 116 -  20MHz
-    CHAN(5600),             // 120 -  20MHz
-    CHAN(5620),             // 124 -  20MHz
-    CHAN(5640),             // 128 -  20MHz
-    CHAN(5660),             // 132 -  20MHz
-    CHAN(5680),             // 136 -  20MHz
-    CHAN(5700),             // 140 -  20MHz
-    CHAN(5720),             // 144 -  20MHz
-    CHAN(5745),             // 149 -  20MHz
-    CHAN(5765),             // 153 -  20MHz
-    CHAN(5785),             // 157 -  20MHz
-    CHAN(5805),             // 161 -  20MHz
-    CHAN(5825),             // 165 -  20MHz
-    // Extra channels defined only to be used for PHY measures.
-    // Enabled only if custregd and custchan parameters are set
-    CHAN(5190),
-    CHAN(5210),
-    CHAN(5230),
-    CHAN(5250),
-    CHAN(5270),
-    CHAN(5290),
-    CHAN(5310),
-    CHAN(5330),
-    CHAN(5340),
-    CHAN(5350),
-    CHAN(5360),
-    CHAN(5370),
-    CHAN(5380),
-    CHAN(5390),
-    CHAN(5400),
-    CHAN(5410),
-    CHAN(5420),
-    CHAN(5430),
-    CHAN(5440),
-    CHAN(5450),
-    CHAN(5460),
-    CHAN(5470),
-    CHAN(5480),
-    CHAN(5490),
-    CHAN(5510),
-    CHAN(5530),
-    CHAN(5550),
-    CHAN(5570),
-    CHAN(5590),
-    CHAN(5610),
-    CHAN(5630),
-    CHAN(5650),
-    CHAN(5670),
-    CHAN(5690),
-    CHAN(5710),
-    CHAN(5730),
-    CHAN(5750),
-    CHAN(5760),
-    CHAN(5770),
-    CHAN(5780),
-    CHAN(5790),
-    CHAN(5800),
-    CHAN(5810),
-    CHAN(5820),
-    CHAN(5830),
-    CHAN(5840),
-    CHAN(5850),
-    CHAN(5860),
-    CHAN(5870),
-    CHAN(5880),
-    CHAN(5890),
-    CHAN(5900),
-    CHAN(5910),
-    CHAN(5920),
-    CHAN(5930),
-    CHAN(5940),
-    CHAN(5950),
-    CHAN(5960),
-    CHAN(5970),
+	CHAN(5180), // 36 -   20MHz
+	CHAN(5200), // 40 -   20MHz
+	CHAN(5220), // 44 -   20MHz
+	CHAN(5240), // 48 -   20MHz
+	CHAN(5260), // 52 -   20MHz
+	CHAN(5280), // 56 -   20MHz
+	CHAN(5300), // 60 -   20MHz
+	CHAN(5320), // 64 -   20MHz
+	CHAN(5500), // 100 -  20MHz
+	CHAN(5520), // 104 -  20MHz
+	CHAN(5540), // 108 -  20MHz
+	CHAN(5560), // 112 -  20MHz
+	CHAN(5580), // 116 -  20MHz
+	CHAN(5600), // 120 -  20MHz
+	CHAN(5620), // 124 -  20MHz
+	CHAN(5640), // 128 -  20MHz
+	CHAN(5660), // 132 -  20MHz
+	CHAN(5680), // 136 -  20MHz
+	CHAN(5700), // 140 -  20MHz
+	CHAN(5720), // 144 -  20MHz
+	CHAN(5745), // 149 -  20MHz
+	CHAN(5765), // 153 -  20MHz
+	CHAN(5785), // 157 -  20MHz
+	CHAN(5805), // 161 -  20MHz
+	CHAN(5825), // 165 -  20MHz
+	// Extra channels defined only to be used for PHY measures.
+	// Enabled only if custregd and custchan parameters are set
+	CHAN(5190),
+	CHAN(5210),
+	CHAN(5230),
+	CHAN(5250),
+	CHAN(5270),
+	CHAN(5290),
+	CHAN(5310),
+	CHAN(5330),
+	CHAN(5340),
+	CHAN(5350),
+	CHAN(5360),
+	CHAN(5370),
+	CHAN(5380),
+	CHAN(5390),
+	CHAN(5400),
+	CHAN(5410),
+	CHAN(5420),
+	CHAN(5430),
+	CHAN(5440),
+	CHAN(5450),
+	CHAN(5460),
+	CHAN(5470),
+	CHAN(5480),
+	CHAN(5490),
+	CHAN(5510),
+	CHAN(5530),
+	CHAN(5550),
+	CHAN(5570),
+	CHAN(5590),
+	CHAN(5610),
+	CHAN(5630),
+	CHAN(5650),
+	CHAN(5670),
+	CHAN(5690),
+	CHAN(5710),
+	CHAN(5730),
+	CHAN(5750),
+	CHAN(5760),
+	CHAN(5770),
+	CHAN(5780),
+	CHAN(5790),
+	CHAN(5800),
+	CHAN(5810),
+	CHAN(5820),
+	CHAN(5830),
+	CHAN(5840),
+	CHAN(5850),
+	CHAN(5860),
+	CHAN(5870),
+	CHAN(5880),
+	CHAN(5890),
+	CHAN(5900),
+	CHAN(5910),
+	CHAN(5920),
+	CHAN(5930),
+	CHAN(5940),
+	CHAN(5950),
+	CHAN(5960),
+	CHAN(5970),
 };
 //#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)) || defined(CONFIG_HE_FOR_OLD_KERNEL)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)) || \
+	defined(CONFIG_HE_FOR_OLD_KERNEL)
 struct ieee80211_sband_iftype_data rwnx_he_capa = {
-    .types_mask = BIT(NL80211_IFTYPE_STATION)|BIT(NL80211_IFTYPE_AP),
-    .he_cap = RWNX_HE_CAPABILITIES,
+	.types_mask = BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP),
+	.he_cap = RWNX_HE_CAPABILITIES,
 };
 #endif
 
 static struct ieee80211_supported_band rwnx_band_2GHz = {
-    .channels   = rwnx_2ghz_channels,
-    .n_channels = ARRAY_SIZE(rwnx_2ghz_channels) - 13, // -13 to exclude extra channels
-    .bitrates   = rwnx_ratetable,
-    .n_bitrates = ARRAY_SIZE(rwnx_ratetable),
-    .ht_cap     = RWNX_HT_CAPABILITIES,
+	.channels = rwnx_2ghz_channels,
+	.n_channels = ARRAY_SIZE(rwnx_2ghz_channels) -
+		      13, // -13 to exclude extra channels
+	.bitrates = rwnx_ratetable,
+	.n_bitrates = ARRAY_SIZE(rwnx_ratetable),
+	.ht_cap = RWNX_HT_CAPABILITIES,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-    .vht_cap    = RWNX_VHT_CAPABILITIES,
+	.vht_cap = RWNX_VHT_CAPABILITIES,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-    .iftype_data = &rwnx_he_capa,
-    .n_iftype_data = 1,
+	.iftype_data = &rwnx_he_capa,
+	.n_iftype_data = 1,
 #endif
 };
 
 //#ifdef USE_5G
 static struct ieee80211_supported_band rwnx_band_5GHz = {
-    .channels   = rwnx_5ghz_channels,
-    .n_channels = ARRAY_SIZE(rwnx_5ghz_channels) - 59, // -59 to exclude extra channels
-    .bitrates   = &rwnx_ratetable[4],
-    .n_bitrates = ARRAY_SIZE(rwnx_ratetable) - 4,
-    .ht_cap     = RWNX_HT_CAPABILITIES,
+	.channels = rwnx_5ghz_channels,
+	.n_channels = ARRAY_SIZE(rwnx_5ghz_channels) -
+		      59, // -59 to exclude extra channels
+	.bitrates = &rwnx_ratetable[4],
+	.n_bitrates = ARRAY_SIZE(rwnx_ratetable) - 4,
+	.ht_cap = RWNX_HT_CAPABILITIES,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-    .vht_cap    = RWNX_VHT_CAPABILITIES,
+	.vht_cap = RWNX_VHT_CAPABILITIES,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-    .iftype_data = &rwnx_he_capa,
-    .n_iftype_data = 1,
+	.iftype_data = &rwnx_he_capa,
+	.n_iftype_data = 1,
 #endif
 };
 //#endif
 
 static struct ieee80211_iface_limit rwnx_limits[] = {
-    { .max = 1,
-      .types = BIT(NL80211_IFTYPE_STATION)},
-    { .max = 1,
-      .types = BIT(NL80211_IFTYPE_AP)},
+	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION) },
+	{ .max = 1, .types = BIT(NL80211_IFTYPE_AP) },
 #ifdef CONFIG_USE_P2P0
-    { .max = 2,
+	{ .max = 2,
 #else
-    { .max = 1,
+	{ .max = 1,
 #endif
-      .types = BIT(NL80211_IFTYPE_P2P_CLIENT) | BIT(NL80211_IFTYPE_P2P_GO)},
+	  .types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+		   BIT(NL80211_IFTYPE_P2P_GO) },
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
 #ifndef CONFIG_USE_P2P0
-    { .max = 1,
-      .types = BIT(NL80211_IFTYPE_P2P_DEVICE),
-    }
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE),
+	}
 #endif
 #endif
 };
 
 static struct ieee80211_iface_limit rwnx_limits_dfs[] = {
-    { .max = NX_VIRT_DEV_MAX, .types = BIT(NL80211_IFTYPE_AP)}
+	{ .max = NX_VIRT_DEV_MAX, .types = BIT(NL80211_IFTYPE_AP) }
 };
 
 static const struct ieee80211_iface_combination rwnx_combinations[] = {
-    {
-        .limits                 = rwnx_limits,
-        .n_limits               = ARRAY_SIZE(rwnx_limits),
-        .num_different_channels = NX_CHAN_CTXT_CNT,
-        .max_interfaces         = NX_VIRT_DEV_MAX,
-    },
-    /* Keep this combination as the last one */
-    {
-        .limits                 = rwnx_limits_dfs,
-        .n_limits               = ARRAY_SIZE(rwnx_limits_dfs),
-        .num_different_channels = 1,
-        .max_interfaces         = NX_VIRT_DEV_MAX,
-        .radar_detect_widths = (BIT(NL80211_CHAN_WIDTH_20_NOHT) |
-                                BIT(NL80211_CHAN_WIDTH_20) |
-                                BIT(NL80211_CHAN_WIDTH_40) |
-                                BIT(NL80211_CHAN_WIDTH_80)),
-    }
+	{
+		.limits = rwnx_limits,
+		.n_limits = ARRAY_SIZE(rwnx_limits),
+#ifdef CONFIG_MCC
+		.num_different_channels = NX_CHAN_CTXT_CNT,
+#else
+		.num_different_channels = 1,
+#endif
+		.max_interfaces = NX_VIRT_DEV_MAX,
+	},
+	/* Keep this combination as the last one */
+	{
+		.limits = rwnx_limits_dfs,
+		.n_limits = ARRAY_SIZE(rwnx_limits_dfs),
+		.num_different_channels = 1,
+		.max_interfaces = NX_VIRT_DEV_MAX,
+		.radar_detect_widths = (BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+					BIT(NL80211_CHAN_WIDTH_20) |
+					BIT(NL80211_CHAN_WIDTH_40) |
+					BIT(NL80211_CHAN_WIDTH_80)),
+	}
 };
 
 /* There isn't a lot of sense in it, but you can transmit anything you like */
@@ -464,73 +475,63 @@ rwnx_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
     },
 };
 
-
 static u32 cipher_suites[] = {
-    WLAN_CIPHER_SUITE_WEP40,
-    WLAN_CIPHER_SUITE_WEP104,
-    WLAN_CIPHER_SUITE_TKIP,
-    WLAN_CIPHER_SUITE_CCMP,
-    WLAN_CIPHER_SUITE_AES_CMAC, // reserved entries to enable AES-CMAC and/or SMS4
-    WLAN_CIPHER_SUITE_SMS4,
-    0,
+	WLAN_CIPHER_SUITE_WEP40,    WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,	    WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_AES_CMAC, // reserved entries to enable AES-CMAC and/or SMS4
+	WLAN_CIPHER_SUITE_SMS4,	    0,
 };
 #define NB_RESERVED_CIPHER 1;
 
 static const int rwnx_ac2hwq[1][NL80211_NUM_ACS] = {
-    {
-        [NL80211_TXQ_Q_VO] = RWNX_HWQ_VO,
-        [NL80211_TXQ_Q_VI] = RWNX_HWQ_VI,
-        [NL80211_TXQ_Q_BE] = RWNX_HWQ_BE,
-        [NL80211_TXQ_Q_BK] = RWNX_HWQ_BK
-    }
+	{ [NL80211_TXQ_Q_VO] = RWNX_HWQ_VO,
+	  [NL80211_TXQ_Q_VI] = RWNX_HWQ_VI,
+	  [NL80211_TXQ_Q_BE] = RWNX_HWQ_BE,
+	  [NL80211_TXQ_Q_BK] = RWNX_HWQ_BK }
 };
 
 const int rwnx_tid2hwq[IEEE80211_NUM_TIDS] = {
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BK,
-    RWNX_HWQ_BK,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_VI,
-    RWNX_HWQ_VI,
-    RWNX_HWQ_VO,
-    RWNX_HWQ_VO,
-    /* TID_8 is used for management frames */
-    RWNX_HWQ_VO,
-    /* At the moment, all others TID are mapped to BE */
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
-    RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BK,
+	RWNX_HWQ_BK,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_VI,
+	RWNX_HWQ_VI,
+	RWNX_HWQ_VO,
+	RWNX_HWQ_VO,
+	/* TID_8 is used for management frames */
+	RWNX_HWQ_VO,
+	/* At the moment, all others TID are mapped to BE */
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
+	RWNX_HWQ_BE,
 };
 
 static const int rwnx_hwq2uapsd[NL80211_NUM_ACS] = {
-    [RWNX_HWQ_VO] = IEEE80211_WMM_IE_STA_QOSINFO_AC_VO,
-    [RWNX_HWQ_VI] = IEEE80211_WMM_IE_STA_QOSINFO_AC_VI,
-    [RWNX_HWQ_BE] = IEEE80211_WMM_IE_STA_QOSINFO_AC_BE,
-    [RWNX_HWQ_BK] = IEEE80211_WMM_IE_STA_QOSINFO_AC_BK,
+	[RWNX_HWQ_VO] = IEEE80211_WMM_IE_STA_QOSINFO_AC_VO,
+	[RWNX_HWQ_VI] = IEEE80211_WMM_IE_STA_QOSINFO_AC_VI,
+	[RWNX_HWQ_BE] = IEEE80211_WMM_IE_STA_QOSINFO_AC_BE,
+	[RWNX_HWQ_BK] = IEEE80211_WMM_IE_STA_QOSINFO_AC_BK,
 };
 
-#define P2P_ALIVE_TIME_MS       (1*1000)
-#define P2P_ALIVE_TIME_COUNT    200
+#define P2P_ALIVE_TIME_MS (1 * 1000)
+#define P2P_ALIVE_TIME_COUNT 200
 
-extern uint8_t scanning;
-extern uint8_t p2p_working;
 struct semaphore aicwf_deinit_sem;
 atomic_t aicwf_deinit_atomic;
 
-int aicwf_dbg_level = LOGERROR|LOGINFO;
+int aicwf_dbg_level = LOGERROR | LOGINFO;
 module_param(aicwf_dbg_level, int, 0660);
 
 int testmode = 0;
 char aic_fw_path[200];
 
-extern void set_testmode(int);
-
-
-void rwnx_skb_align_8bytes(struct sk_buff *skb){
+void rwnx_skb_align_8bytes(struct sk_buff *skb)
+{
 #ifdef CONFIG_ALIGN_8BYTES
 	int align __maybe_unused;
 	u8 *data;
@@ -557,32 +558,23 @@ void rwnx_skb_align_8bytes(struct sk_buff *skb){
 int rwnx_init_cmd_array(void);
 void rwnx_free_cmd_array(void);
 
-void rwnx_data_dump(char* tag, void* data, unsigned long len){
+void rwnx_data_dump(char *tag, void *data, unsigned long len)
+{
 	unsigned long i = 0;
-	char* data_ = (char* )data;
+	char *data_ = (char *)data;
 
 	AICWFDBG(LOGDATA, "%s %s len:(%lu)\r\n", __func__, tag, len);
 
-	for (i = 0; i < len; i += 16){
-	AICWFDBG(LOGDATA, "%02X %02X %02X %02X %02X %02X %02X %02X  %02X %02X %02X %02X %02X %02X %02X %02X\r\n",
-		data_[0 + i],
-		data_[1 + i],
-		data_[2 + i],
-		data_[3 + i],
-		data_[4 + i],
-		data_[5 + i],
-		data_[6 + i],
-		data_[7 + i],
-		data_[8 + i],
-		data_[9 + i],
-		data_[10 + i],
-		data_[11 + i],
-		data_[12 + i],
-		data_[13 + i],
-		data_[14 + i],
-		data_[15 + i]);
-		}
-
+	for (i = 0; i < len; i += 16) {
+		AICWFDBG(
+			LOGDATA,
+			"%02X %02X %02X %02X %02X %02X %02X %02X  %02X %02X %02X %02X %02X %02X %02X %02X\r\n",
+			data_[0 + i], data_[1 + i], data_[2 + i], data_[3 + i],
+			data_[4 + i], data_[5 + i], data_[6 + i], data_[7 + i],
+			data_[8 + i], data_[9 + i], data_[10 + i],
+			data_[11 + i], data_[12 + i], data_[13 + i],
+			data_[14 + i], data_[15 + i]);
+	}
 }
 
 #define ASSOC_REQ 0x00
@@ -597,81 +589,105 @@ void rwnx_data_dump(char* tag, void* data, unsigned long len){
 #define ACTION_MAC_HDR_LEN 24
 #define QOS_MAC_HDR_LEN 26
 
-void rwnx_frame_parser(char* tag, char* data, unsigned long len){
+void rwnx_frame_parser(char *tag, char *data, unsigned long len)
+{
 	char print_data[100];
 	int print_index = 0;
 
 	memset(print_data, 0, 100);
 
-	if(data[0] == ASSOC_REQ){
+	if (data[0] == ASSOC_REQ) {
 		sprintf(&print_data[print_index], "%s", "ASSOC_REQ \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == ASSOC_RSP){
+	} else if (data[0] == ASSOC_RSP) {
 		sprintf(&print_data[print_index], "%s", "ASSOC_RSP \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == PROBE_REQ){
+	} else if (data[0] == PROBE_REQ) {
 		sprintf(&print_data[print_index], "%s", "PROBE_REQ \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == PROBE_RSP){
+	} else if (data[0] == PROBE_RSP) {
 		sprintf(&print_data[print_index], "%s", "PROBE_RSP \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == ACTION){
+	} else if (data[0] == ACTION) {
 		sprintf(&print_data[print_index], "%s", "ACTION ");
 		print_index = strlen(print_data);
-		if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x00){
-			sprintf(&print_data[print_index], "%s", "GO_NEG_REQ \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x01){
-			sprintf(&print_data[print_index], "%s", "GO_NEG_RSP \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x02){
-			sprintf(&print_data[print_index], "%s", "GO_NEG_CFM \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x03){
-			sprintf(&print_data[print_index], "%s", "P2P_INV_REQ \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x04){
-			sprintf(&print_data[print_index], "%s", "P2P_INV_RSP \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x05){
+		if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+		    data[ACTION_MAC_HDR_LEN + 6] == 0x00) {
+			sprintf(&print_data[print_index], "%s",
+				"GO_NEG_REQ \r\n");
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x01) {
+			sprintf(&print_data[print_index], "%s",
+				"GO_NEG_RSP \r\n");
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x02) {
+			sprintf(&print_data[print_index], "%s",
+				"GO_NEG_CFM \r\n");
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x03) {
+			sprintf(&print_data[print_index], "%s",
+				"P2P_INV_REQ \r\n");
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x04) {
+			sprintf(&print_data[print_index], "%s",
+				"P2P_INV_RSP \r\n");
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x05) {
 			sprintf(&print_data[print_index], "%s", "DD_REQ \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x06){
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x06) {
 			sprintf(&print_data[print_index], "%s", "DD_RSP \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x07){
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x07) {
 			sprintf(&print_data[print_index], "%s", "PD_REQ \r\n");
-		}else if(data[ACTION_MAC_HDR_LEN] == 0x04 && data[ACTION_MAC_HDR_LEN + 6] == 0x08){
+		} else if (data[ACTION_MAC_HDR_LEN] == 0x04 &&
+			   data[ACTION_MAC_HDR_LEN + 6] == 0x08) {
 			sprintf(&print_data[print_index], "%s", "PD_RSP \r\n");
-		}else{
-			sprintf(&print_data[print_index], "%s(0x%x 0x%x) \r\n", "UNKNOW",
-				data[ACTION_MAC_HDR_LEN], data[ACTION_MAC_HDR_LEN + 6]);
+		} else {
+			sprintf(&print_data[print_index], "%s(0x%x 0x%x) \r\n",
+				"UNKNOW", data[ACTION_MAC_HDR_LEN],
+				data[ACTION_MAC_HDR_LEN + 6]);
 		}
 		print_index = strlen(print_data);
-	}else if(data[0] == AUTH){
+	} else if (data[0] == AUTH) {
 		sprintf(&print_data[print_index], "%s", "AUTH \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == DEAUTH){
+	} else if (data[0] == DEAUTH) {
 		sprintf(&print_data[print_index], "%s", "DEAUTH \r\n");
 		print_index = strlen(print_data);
-	}else if(data[0] == QOS){
-		if(data[QOS_MAC_HDR_LEN + 6] == 0x88 && data[QOS_MAC_HDR_LEN + 7] == 0x8E){
+	} else if (data[0] == QOS) {
+		if (data[QOS_MAC_HDR_LEN + 6] == 0x88 &&
+		    data[QOS_MAC_HDR_LEN + 7] == 0x8E) {
 			sprintf(&print_data[print_index], "%s", "QOS_802.1X ");
-			if(data[QOS_MAC_HDR_LEN + 9] == 0x03){
-				sprintf(&print_data[print_index], "%s", "EAPOL \r\n");
-			}else if(data[QOS_MAC_HDR_LEN + 9] == 0x00){
-				sprintf(&print_data[print_index], "%s", "EAP_PACKAGE ");
+			if (data[QOS_MAC_HDR_LEN + 9] == 0x03) {
+				sprintf(&print_data[print_index], "%s",
+					"EAPOL \r\n");
+			} else if (data[QOS_MAC_HDR_LEN + 9] == 0x00) {
+				sprintf(&print_data[print_index], "%s",
+					"EAP_PACKAGE ");
 				print_index = strlen(print_data);
-				if(data[QOS_MAC_HDR_LEN + 12] == 0x01){
-					sprintf(&print_data[print_index], "%s", "EAP_REQ \r\n");
-				}else if(data[QOS_MAC_HDR_LEN + 12] == 0x02){
-					sprintf(&print_data[print_index], "%s", "EAP_RSP \r\n");
-				}else if(data[QOS_MAC_HDR_LEN + 12] == 0x04){
-					sprintf(&print_data[print_index], "%s", "EAP_FAIL \r\n");
-				}else{
-					sprintf(&print_data[print_index], "%s", "UNKNOW \r\n");
+				if (data[QOS_MAC_HDR_LEN + 12] == 0x01) {
+					sprintf(&print_data[print_index], "%s",
+						"EAP_REQ \r\n");
+				} else if (data[QOS_MAC_HDR_LEN + 12] == 0x02) {
+					sprintf(&print_data[print_index], "%s",
+						"EAP_RSP \r\n");
+				} else if (data[QOS_MAC_HDR_LEN + 12] == 0x04) {
+					sprintf(&print_data[print_index], "%s",
+						"EAP_FAIL \r\n");
+				} else {
+					sprintf(&print_data[print_index], "%s",
+						"UNKNOW \r\n");
 				}
-			}else if(data[QOS_MAC_HDR_LEN + 9] == 0x01){
-				sprintf(&print_data[print_index], "%s","EAP_START \r\n");
+			} else if (data[QOS_MAC_HDR_LEN + 9] == 0x01) {
+				sprintf(&print_data[print_index], "%s",
+					"EAP_START \r\n");
 			}
 			print_index = strlen(print_data);
 		}
 	}
 
-	if(print_index > 0){
+	if (print_index > 0) {
 		AICWFDBG(LOGDATA, "%s %s", tag, print_data);
 	}
 
@@ -742,39 +758,41 @@ void rwnx_frame_parser(char* tag, char* data, unsigned long len){
  *********************************************************************/
 struct rwnx_sta *rwnx_get_sta(struct rwnx_hw *rwnx_hw, const u8 *mac_addr)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < NX_REMOTE_STA_MAX; i++) {
-        struct rwnx_sta *sta = &rwnx_hw->sta_table[i];
-        if (sta->valid && (memcmp(mac_addr, &sta->mac_addr, 6) == 0))
-            return sta;
-    }
+	for (i = 0; i < NX_REMOTE_STA_MAX; i++) {
+		struct rwnx_sta *sta = &rwnx_hw->sta_table[i];
+		if (sta->valid && (memcmp(mac_addr, &sta->mac_addr, 6) == 0))
+			return sta;
+	}
 
-    return NULL;
+	return NULL;
 }
 
 void rwnx_enable_wapi(struct rwnx_hw *rwnx_hw)
 {
-    //cipher_suites[rwnx_hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_SMS4;
-    rwnx_hw->wiphy->n_cipher_suites ++;
-    rwnx_hw->wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;
+	//cipher_suites[rwnx_hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_SMS4;
+	rwnx_hw->wiphy->n_cipher_suites++;
+	rwnx_hw->wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;
 }
 
 void rwnx_enable_mfp(struct rwnx_hw *rwnx_hw)
 {
-    cipher_suites[rwnx_hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_AES_CMAC;
-    rwnx_hw->wiphy->n_cipher_suites ++;
+	cipher_suites[rwnx_hw->wiphy->n_cipher_suites] =
+		WLAN_CIPHER_SUITE_AES_CMAC;
+	rwnx_hw->wiphy->n_cipher_suites++;
 }
 
 #ifdef CONFIG_SET_VENDOR_EXTENSION_IE
 extern u8_l vendor_extension_data[256];
 extern u8_l vendor_extension_len;
 
-void rwnx_insert_vendor_extension_in_bcn(struct rwnx_bcn *bcn){
+void rwnx_insert_vendor_extension_in_bcn(struct rwnx_bcn *bcn)
+{
 	u8_l temp_ie[256];
-	u8_l vendor_extension_subelement[3] = {0x00,0x37,0x2A};
-	u8_l vendor_extension_id[2] = {0x10,0x49};
-	u8_l wps_ie[1] = {0xDD};
+	u8_l vendor_extension_subelement[3] = { 0x00, 0x37, 0x2A };
+	u8_l vendor_extension_id[2] = { 0x10, 0x49 };
+	u8_l wps_ie[1] = { 0xDD };
 	u8_l wps_len_index = 0;
 	int index = 0;
 	int vendor_extension_subelement_len = 0;
@@ -783,34 +801,38 @@ void rwnx_insert_vendor_extension_in_bcn(struct rwnx_bcn *bcn){
 	memset(temp_ie, 0, 256);
 
 	//find wps_ie
-	for(index = 0; index < bcn->tail_len; index++){
-		if(bcn->tail[index] == wps_ie[0]){
+	for (index = 0; index < bcn->tail_len; index++) {
+		if (bcn->tail[index] == wps_ie[0]) {
 			find_wps_ie = 1;
 			wps_len_index = index + 1;
 		}
 
-		if(find_wps_ie && bcn->tail[index] == vendor_extension_id[0]){
-			if(bcn->tail[index + 1] == vendor_extension_id[1]){
+		if (find_wps_ie && bcn->tail[index] == vendor_extension_id[0]) {
+			if (bcn->tail[index + 1] == vendor_extension_id[1]) {
 				break;
 			}
 		}
 	}
 
-
 	//find vendor_extension_subelement
-	for(index = 0; index < bcn->tail_len; index++){
-		if(bcn->tail[index] == vendor_extension_id[0]){
+	for (index = 0; index < bcn->tail_len; index++) {
+		if (bcn->tail[index] == vendor_extension_id[0]) {
 			index++;
-			if(index == bcn->tail_len){
+			if (index == bcn->tail_len) {
 				return;
 			}
-			if(bcn->tail[index] == vendor_extension_id[1] &&
-				bcn->tail[index + 3] == vendor_extension_subelement[0]&&
-				bcn->tail[index + 4] == vendor_extension_subelement[1]&&
-				bcn->tail[index + 5] == vendor_extension_subelement[2]){
+			if (bcn->tail[index] == vendor_extension_id[1] &&
+			    bcn->tail[index + 3] ==
+				    vendor_extension_subelement[0] &&
+			    bcn->tail[index + 4] ==
+				    vendor_extension_subelement[1] &&
+			    bcn->tail[index + 5] ==
+				    vendor_extension_subelement[2]) {
 				index = index + 2;
-				vendor_extension_subelement_len = bcn->tail[index];
-				printk("%s find vendor_extension_subelement,index:%d len:%d\r\n", __func__, index, bcn->tail[index]);
+				vendor_extension_subelement_len =
+					bcn->tail[index];
+				printk("%s find vendor_extension_subelement,index:%d len:%d\r\n",
+				       __func__, index, bcn->tail[index]);
 				break;
 			}
 		}
@@ -819,136 +841,142 @@ void rwnx_insert_vendor_extension_in_bcn(struct rwnx_bcn *bcn){
 
 	//insert vendor extension
 	memcpy(&temp_ie[0], bcn->tail, index + 1);
-	memcpy(&temp_ie[index + 1], vendor_extension_data, vendor_extension_len/*sizeof(vendor_extension_data)*/);//insert vendor extension data
-	memcpy(&temp_ie[index + 1 + vendor_extension_len/*sizeof(vendor_extension_data)*/], &bcn->tail[index + 1], bcn->tail_len - index);
-
-	memcpy(bcn->tail, temp_ie, bcn->tail_len + vendor_extension_len/*sizeof(vendor_extension_data)*/);
-	bcn->tail_len = bcn->tail_len + vendor_extension_len/*sizeof(vendor_extension_data)*/;
-
-	bcn->tail[wps_len_index] = bcn->tail[wps_len_index] + vendor_extension_len;
+	memcpy(&temp_ie[index + 1], vendor_extension_data,
+	       vendor_extension_len /*sizeof(vendor_extension_data)*/); //insert vendor extension data
+	memcpy(&temp_ie[index + 1 +
+			vendor_extension_len /*sizeof(vendor_extension_data)*/],
+	       &bcn->tail[index + 1], bcn->tail_len - index);
+
+	memcpy(bcn->tail, temp_ie,
+	       bcn->tail_len +
+		       vendor_extension_len /*sizeof(vendor_extension_data)*/);
+	bcn->tail_len = bcn->tail_len +
+			vendor_extension_len /*sizeof(vendor_extension_data)*/;
+
+	bcn->tail[wps_len_index] =
+		bcn->tail[wps_len_index] + vendor_extension_len;
 	//rwnx_data_dump((char*)__func__, (void*)ie_req->ie, ie_req->add_ie_len);
 }
 #endif
 
 u8 *rwnx_build_bcn(struct rwnx_bcn *bcn, struct cfg80211_beacon_data *new)
 {
-    u8 *buf, *pos;
+	u8 *buf, *pos;
 
-    if (new->head) {
-        u8 *head = kmalloc(new->head_len, GFP_KERNEL);
+	if (new->head) {
+		u8 *head = kmalloc(new->head_len, GFP_KERNEL);
 
-        if (!head)
-            return NULL;
+		if (!head)
+			return NULL;
 
-        if (bcn->head)
-            kfree(bcn->head);
+		if (bcn->head)
+			kfree(bcn->head);
 
-        bcn->head = head;
-        bcn->head_len = new->head_len;
-        memcpy(bcn->head, new->head, new->head_len);
-    }
-    if (new->tail) {
-        u8 *tail = kmalloc(new->tail_len, GFP_KERNEL);
+		bcn->head = head;
+		bcn->head_len = new->head_len;
+		memcpy(bcn->head, new->head, new->head_len);
+	}
+	if (new->tail) {
+		u8 *tail = kmalloc(new->tail_len, GFP_KERNEL);
 
-        if (!tail)
-            return NULL;
+		if (!tail)
+			return NULL;
 
-        if (bcn->tail)
-            kfree(bcn->tail);
+		if (bcn->tail)
+			kfree(bcn->tail);
 
-        bcn->tail = tail;
-        bcn->tail_len = new->tail_len;
-        memcpy(bcn->tail, new->tail, new->tail_len);
-    }
+		bcn->tail = tail;
+		bcn->tail_len = new->tail_len;
+		memcpy(bcn->tail, new->tail, new->tail_len);
+	}
 
-    if (!bcn->head)
-        return NULL;
+	if (!bcn->head)
+		return NULL;
 
-    bcn->tim_len = 6;
-    bcn->len = bcn->head_len + bcn->tail_len + bcn->ies_len + bcn->tim_len;
+	bcn->tim_len = 6;
+	bcn->len = bcn->head_len + bcn->tail_len + bcn->ies_len + bcn->tim_len;
 #ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-    buf = kmalloc(bcn->len + vendor_extension_len, GFP_KERNEL);
+	buf = kmalloc(bcn->len + vendor_extension_len, GFP_KERNEL);
 #else
 	buf = kmalloc(bcn->len, GFP_KERNEL);
 #endif
-    if (!buf)
-        return NULL;
-
-    // Build the beacon buffer
-    pos = buf;
-    memcpy(pos, bcn->head, bcn->head_len);
-    pos += bcn->head_len;
-    *pos++ = WLAN_EID_TIM;
-    *pos++ = 4;
-    *pos++ = 0;
-    *pos++ = bcn->dtim;
-    *pos++ = 0;
-    *pos++ = 0;
-    if (bcn->tail) {
+	if (!buf)
+		return NULL;
+
+	// Build the beacon buffer
+	pos = buf;
+	memcpy(pos, bcn->head, bcn->head_len);
+	pos += bcn->head_len;
+	*pos++ = WLAN_EID_TIM;
+	*pos++ = 4;
+	*pos++ = 0;
+	*pos++ = bcn->dtim;
+	*pos++ = 0;
+	*pos++ = 0;
+	if (bcn->tail) {
 #ifdef CONFIG_SET_VENDOR_EXTENSION_IE
 		rwnx_insert_vendor_extension_in_bcn(bcn);
 #endif
-        memcpy(pos, bcn->tail, bcn->tail_len);
-        pos += bcn->tail_len;
-    }
-    if (bcn->ies) {
-        memcpy(pos, bcn->ies, bcn->ies_len);
-    }
+		memcpy(pos, bcn->tail, bcn->tail_len);
+		pos += bcn->tail_len;
+	}
+	if (bcn->ies) {
+		memcpy(pos, bcn->ies, bcn->ies_len);
+	}
 
-    return buf;
+	return buf;
 }
 
-
 static void rwnx_del_bcn(struct rwnx_bcn *bcn)
 {
-    if (bcn->head) {
-        kfree(bcn->head);
-        bcn->head = NULL;
-    }
-    bcn->head_len = 0;
+	if (bcn->head) {
+		kfree(bcn->head);
+		bcn->head = NULL;
+	}
+	bcn->head_len = 0;
 
-    if (bcn->tail) {
-        kfree(bcn->tail);
-        bcn->tail = NULL;
-    }
-    bcn->tail_len = 0;
+	if (bcn->tail) {
+		kfree(bcn->tail);
+		bcn->tail = NULL;
+	}
+	bcn->tail_len = 0;
 
-    if (bcn->ies) {
-        kfree(bcn->ies);
-        bcn->ies = NULL;
-    }
-    bcn->ies_len = 0;
-    bcn->tim_len = 0;
-    bcn->dtim = 0;
-    bcn->len = 0;
+	if (bcn->ies) {
+		kfree(bcn->ies);
+		bcn->ies = NULL;
+	}
+	bcn->ies_len = 0;
+	bcn->tim_len = 0;
+	bcn->dtim = 0;
+	bcn->len = 0;
 }
 
 /**
  * Link channel ctxt to a vif and thus increments count for this context.
  */
 void rwnx_chanctx_link(struct rwnx_vif *vif, u8 ch_idx,
-                       struct cfg80211_chan_def *chandef)
+		       struct cfg80211_chan_def *chandef)
 {
-    struct rwnx_chanctx *ctxt;
+	struct rwnx_chanctx *ctxt;
 
-    if (ch_idx >= NX_CHAN_CTXT_CNT) {
-        WARN(1, "Invalid channel ctxt id %d", ch_idx);
-        return;
-    }
+	if (ch_idx >= NX_CHAN_CTXT_CNT) {
+		WARN(1, "Invalid channel ctxt id %d", ch_idx);
+		return;
+	}
 
-    vif->ch_index = ch_idx;
-    ctxt = &vif->rwnx_hw->chanctx_table[ch_idx];
-    ctxt->count++;
-
-    // For now chandef is NULL for STATION interface
-    if (chandef) {
-        if (!ctxt->chan_def.chan)
-            ctxt->chan_def = *chandef;
-        else {
-            // TODO. check that chandef is the same as the one already
-            // set for this ctxt
-        }
-    }
+	vif->ch_index = ch_idx;
+	ctxt = &vif->rwnx_hw->chanctx_table[ch_idx];
+	ctxt->count++;
+
+	// For now chandef is NULL for STATION interface
+	if (chandef) {
+		if (!ctxt->chan_def.chan)
+			ctxt->chan_def = *chandef;
+		else {
+			// TODO. check that chandef is the same as the one already
+			// set for this ctxt
+		}
+	}
 }
 
 /**
@@ -956,134 +984,138 @@ void rwnx_chanctx_link(struct rwnx_vif *vif, u8 ch_idx,
  */
 void rwnx_chanctx_unlink(struct rwnx_vif *vif)
 {
-    struct rwnx_chanctx *ctxt;
+	struct rwnx_chanctx *ctxt;
 
-    if (vif->ch_index == RWNX_CH_NOT_SET)
-        return;
+	if (vif->ch_index == RWNX_CH_NOT_SET)
+		return;
 
-    ctxt = &vif->rwnx_hw->chanctx_table[vif->ch_index];
+	ctxt = &vif->rwnx_hw->chanctx_table[vif->ch_index];
 
-    if (ctxt->count == 0) {
-        WARN(1, "Chan ctxt ref count is already 0");
-    } else {
-        ctxt->count--;
-    }
+	if (ctxt->count == 0) {
+		WARN(1, "Chan ctxt ref count is already 0");
+	} else {
+		ctxt->count--;
+	}
 
-    if (ctxt->count == 0) {
-        if (vif->ch_index == vif->rwnx_hw->cur_chanctx) {
-            /* If current chan ctxt is no longer linked to a vif
+	if (ctxt->count == 0) {
+		if (vif->ch_index == vif->rwnx_hw->cur_chanctx) {
+			/* If current chan ctxt is no longer linked to a vif
                disable radar detection (no need to check if it was activated) */
-            rwnx_radar_detection_enable(&vif->rwnx_hw->radar,
-                                        RWNX_RADAR_DETECT_DISABLE,
-                                        RWNX_RADAR_RIU);
-        }
-        /* set chan to null, so that if this ctxt is relinked to a vif that
+			rwnx_radar_detection_enable(&vif->rwnx_hw->radar,
+						    RWNX_RADAR_DETECT_DISABLE,
+						    RWNX_RADAR_RIU);
+		}
+		/* set chan to null, so that if this ctxt is relinked to a vif that
            don't have channel information, don't use wrong information */
-        ctxt->chan_def.chan = NULL;
-    }
-    vif->ch_index = RWNX_CH_NOT_SET;
+		ctxt->chan_def.chan = NULL;
+	}
+	vif->ch_index = RWNX_CH_NOT_SET;
 }
 
 int rwnx_chanctx_valid(struct rwnx_hw *rwnx_hw, u8 ch_idx)
 {
-    if (ch_idx >= NX_CHAN_CTXT_CNT ||
-        rwnx_hw->chanctx_table[ch_idx].chan_def.chan == NULL) {
-        return 0;
-    }
+	if (ch_idx >= NX_CHAN_CTXT_CNT ||
+	    rwnx_hw->chanctx_table[ch_idx].chan_def.chan == NULL) {
+		return 0;
+	}
 
-    return 1;
+	return 1;
 }
 
 static void rwnx_del_csa(struct rwnx_vif *vif)
 {
-    //struct rwnx_hw *rwnx_hw = vif->rwnx_hw;
-    struct rwnx_csa *csa = vif->ap.csa;
+	//struct rwnx_hw *rwnx_hw = vif->rwnx_hw;
+	struct rwnx_csa *csa = vif->ap.csa;
 
-    if (!csa)
-        return;
+	if (!csa)
+		return;
 
-    rwnx_del_bcn(&csa->bcn);
-    kfree(csa);
-    vif->ap.csa = NULL;
+	rwnx_del_bcn(&csa->bcn);
+	kfree(csa);
+	vif->ap.csa = NULL;
 }
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
 static void rwnx_csa_finish(struct work_struct *ws)
 {
-
-    struct rwnx_csa *csa = container_of(ws, struct rwnx_csa, work);
-    struct rwnx_vif *vif = csa->vif;
-    struct rwnx_hw *rwnx_hw = vif->rwnx_hw;
-    int error = csa->status;
-    u8 *buf, *pos;
+	struct rwnx_csa *csa = container_of(ws, struct rwnx_csa, work);
+	struct rwnx_vif *vif = csa->vif;
+	struct rwnx_hw *rwnx_hw = vif->rwnx_hw;
+	int error = csa->status;
+	u8 *buf, *pos;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    buf = kmalloc(csa->bcn.len, GFP_KERNEL);
-    if (!buf) {
-        printk ("%s buf fail\n", __func__);
-        return;
-    }
-    pos = buf;
-
-    memcpy(pos, csa->bcn.head, csa->bcn.head_len);
-    pos += csa->bcn.head_len;
-    *pos++ = WLAN_EID_TIM;
-    *pos++ = 4;
-    *pos++ = 0;
-    *pos++ = csa->bcn.dtim;
-    *pos++ = 0;
-    *pos++ = 0;
-    if (csa->bcn.tail) {
-        memcpy(pos, csa->bcn.tail, csa->bcn.tail_len);
-        pos += csa->bcn.tail_len;
-    }
-    if (csa->bcn.ies) {
-        memcpy(pos, csa->bcn.ies, csa->bcn.ies_len);
-    }
+	buf = kmalloc(csa->bcn.len, GFP_KERNEL);
+	if (!buf) {
+		printk("%s buf fail\n", __func__);
+		return;
+	}
+	pos = buf;
+
+	memcpy(pos, csa->bcn.head, csa->bcn.head_len);
+	pos += csa->bcn.head_len;
+	*pos++ = WLAN_EID_TIM;
+	*pos++ = 4;
+	*pos++ = 0;
+	*pos++ = csa->bcn.dtim;
+	*pos++ = 0;
+	*pos++ = 0;
+	if (csa->bcn.tail) {
+		memcpy(pos, csa->bcn.tail, csa->bcn.tail_len);
+		pos += csa->bcn.tail_len;
+	}
+	if (csa->bcn.ies) {
+		memcpy(pos, csa->bcn.ies, csa->bcn.ies_len);
+	}
 
-    if (!error) {
-        error = rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, csa->bcn.len);
-        if (error)
-            return;
-        error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index, csa->elem.dma_addr,
-                                     csa->bcn.len, csa->bcn.head_len,
-                                     csa->bcn.tim_len, NULL);
-    }
+	if (!error) {
+		error = rwnx_send_bcn(rwnx_hw, buf, vif->vif_index,
+				      csa->bcn.len);
+		if (error)
+			return;
+		error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index,
+					     csa->elem.dma_addr, csa->bcn.len,
+					     csa->bcn.head_len,
+					     csa->bcn.tim_len, NULL);
+	}
 
-    if (error) {
-        #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
-        cfg80211_stop_iface(rwnx_hw->wiphy, &vif->wdev, GFP_KERNEL);
-        #else
-        cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
-        #endif
-    } else {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-	    wiphy_lock(vif->wdev.wiphy);
+	if (error) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0))
+		cfg80211_stop_iface(rwnx_hw->wiphy, &vif->wdev, GFP_KERNEL);
 #else
-        mutex_lock(&vif->wdev.mtx);
+		cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
 #endif
-        __acquire(&vif->wdev.mtx);
-        spin_lock_bh(&rwnx_hw->cb_lock);
-        rwnx_chanctx_unlink(vif);
-        rwnx_chanctx_link(vif, csa->ch_idx, &csa->chandef);
-        if (rwnx_hw->cur_chanctx == csa->ch_idx) {
-            rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
-            rwnx_txq_vif_start(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
-        } else
-            rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
-        spin_unlock_bh(&rwnx_hw->cb_lock);
+	} else {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+		wiphy_lock(rwnx_hw->wiphy);
+#else
+		mutex_lock(&vif->wdev.mtx);
+		__acquire(&vif->wdev.mtx);
+#endif
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_chanctx_unlink(vif);
+		rwnx_chanctx_link(vif, csa->ch_idx, &csa->chandef);
+		if (rwnx_hw->cur_chanctx == csa->ch_idx) {
+			rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
+			rwnx_txq_vif_start(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
+		} else
+			rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION3)
 		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
-        wiphy_unlock(vif->wdev.wiphy);
 #elif (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
 		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
 #else
 		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
-        mutex_unlock(&vif->wdev.mtx);
-        __release(&vif->wdev.mtx);
 #endif
-    }
-    rwnx_del_csa(vif);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+		wiphy_unlock(rwnx_hw->wiphy);
+#else
+		mutex_unlock(&vif->wdev.mtx);
+		__release(&vif->wdev.mtx);
+#endif
+	}
+	rwnx_del_csa(vif);
 }
 #endif
 
@@ -1098,9 +1130,9 @@ static void rwnx_csa_finish(struct work_struct *ws)
  */
 void rwnx_external_auth_enable(struct rwnx_vif *vif)
 {
-    vif->sta.external_auth = true;
-    rwnx_txq_unk_vif_init(vif);
-    rwnx_txq_start(rwnx_txq_vif_get(vif, NX_UNK_TXQ_TYPE), 0);
+	vif->sta.external_auth = true;
+	rwnx_txq_unk_vif_init(vif);
+	rwnx_txq_start(rwnx_txq_vif_get(vif, NX_UNK_TXQ_TYPE), 0);
 }
 
 /**
@@ -1110,11 +1142,11 @@ void rwnx_external_auth_enable(struct rwnx_vif *vif)
  */
 void rwnx_external_auth_disable(struct rwnx_vif *vif)
 {
-    if (!vif->sta.external_auth)
-        return;
+	if (!vif->sta.external_auth)
+		return;
 
-    vif->sta.external_auth = false;
-    rwnx_txq_unk_vif_deinit(vif);
+	vif->sta.external_auth = false;
+	rwnx_txq_unk_vif_deinit(vif);
 }
 
 /**
@@ -1132,36 +1164,37 @@ void rwnx_external_auth_disable(struct rwnx_vif *vif)
  */
 void rwnx_update_mesh_power_mode(struct rwnx_vif *vif)
 {
-    enum nl80211_mesh_power_mode mesh_pm;
-    struct rwnx_sta *sta;
-    struct mesh_config mesh_conf;
-    struct mesh_update_cfm cfm;
-    u32 mask;
+	enum nl80211_mesh_power_mode mesh_pm;
+	struct rwnx_sta *sta;
+	struct mesh_config mesh_conf;
+	struct mesh_update_cfm cfm;
+	u32 mask;
 
-    if (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MESH_POINT)
-        return;
+	if (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MESH_POINT)
+		return;
 
-    if (list_empty(&vif->ap.sta_list)) {
-        mesh_pm = vif->ap.next_mesh_pm;
-    } else {
-        mesh_pm = NL80211_MESH_POWER_DEEP_SLEEP;
-        list_for_each_entry(sta, &vif->ap.sta_list, list) {
-            if (sta->valid && (sta->mesh_pm < mesh_pm)) {
-                mesh_pm = sta->mesh_pm;
-            }
-        }
-    }
+	if (list_empty(&vif->ap.sta_list)) {
+		mesh_pm = vif->ap.next_mesh_pm;
+	} else {
+		mesh_pm = NL80211_MESH_POWER_DEEP_SLEEP;
+		list_for_each_entry(sta, &vif->ap.sta_list, list) {
+			if (sta->valid && (sta->mesh_pm < mesh_pm)) {
+				mesh_pm = sta->mesh_pm;
+			}
+		}
+	}
 
-    if (mesh_pm == vif->ap.mesh_pm)
-        return;
+	if (mesh_pm == vif->ap.mesh_pm)
+		return;
 
-    mask = BIT(NL80211_MESHCONF_POWER_MODE - 1);
-    mesh_conf.power_mode = mesh_pm;
-    if (rwnx_send_mesh_update_req(vif->rwnx_hw, vif, mask, &mesh_conf, &cfm) ||
-        cfm.status)
-        return;
+	mask = BIT(NL80211_MESHCONF_POWER_MODE - 1);
+	mesh_conf.power_mode = mesh_pm;
+	if (rwnx_send_mesh_update_req(vif->rwnx_hw, vif, mask, &mesh_conf,
+				      &cfm) ||
+	    cfm.status)
+		return;
 
-    vif->ap.mesh_pm = mesh_pm;
+	vif->ap.mesh_pm = mesh_pm;
 }
 
 #ifdef CONFIG_BR_SUPPORT
@@ -1175,24 +1208,35 @@ void netdev_br_init(struct net_device *netdev)
 
 	/* if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) */
 	{
-		/* struct net_bridge	*br = netdev->br_port->br; */ /* ->dev->dev_addr; */
-		#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+/* struct net_bridge	*br = netdev->br_port->br; */ /* ->dev->dev_addr; */
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 		if (netdev->br_port)
-		#else
+#else
 		if (rcu_dereference(rwnx_vif->ndev->rx_handler_data))
-		#endif
+#endif
 		{
 			struct net_device *br_netdev;
 
-			br_netdev = dev_get_by_name(&init_net, CONFIG_BR_SUPPORT_BRNAME);
+			br_netdev = dev_get_by_name(&init_net,
+						    CONFIG_BR_SUPPORT_BRNAME);
 			if (br_netdev) {
-				memcpy(rwnx_vif->br_mac, br_netdev->dev_addr, ETH_ALEN);
+				memcpy(rwnx_vif->br_mac, br_netdev->dev_addr,
+				       ETH_ALEN);
 				dev_put(br_netdev);
-				AICWFDBG(LOGINFO, FUNC_NDEV_FMT" bind bridge dev "NDEV_FMT"("MAC_FMT")\n"
-					, FUNC_NDEV_ARG(netdev), NDEV_ARG(br_netdev), MAC_ARG(br_netdev->dev_addr));
+				AICWFDBG(LOGINFO,
+					 FUNC_NDEV_FMT
+					 " bind bridge dev " NDEV_FMT
+					 "(" MAC_FMT ")\n",
+					 FUNC_NDEV_ARG(netdev),
+					 NDEV_ARG(br_netdev),
+					 MAC_ARG(br_netdev->dev_addr));
 			} else {
-				AICWFDBG(LOGINFO, FUNC_NDEV_FMT" can't get bridge dev by name \"%s\"\n"
-					, FUNC_NDEV_ARG(netdev), CONFIG_BR_SUPPORT_BRNAME);
+				AICWFDBG(
+					LOGINFO,
+					FUNC_NDEV_FMT
+					" can't get bridge dev by name \"%s\"\n",
+					FUNC_NDEV_ARG(netdev),
+					CONFIG_BR_SUPPORT_BRNAME);
 			}
 		}
 
@@ -1205,6 +1249,17 @@ void netdev_br_init(struct net_device *netdev)
 }
 #endif /* CONFIG_BR_SUPPORT */
 
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state)
+{
+	if ((int)atomic_read(drv_conn_state) != state) {
+		AICWFDBG(LOGDEBUG, "%s drv_conn_state:%p %s --> %s \r\n",
+			 __func__, drv_conn_state,
+			 s_conn_state[(int)atomic_read(drv_conn_state)],
+			 s_conn_state[state]);
+
+		atomic_set(drv_conn_state, state);
+	}
+}
 
 /*********************************************************************
  * netdev callbacks
@@ -1219,57 +1274,67 @@ void netdev_br_init(struct net_device *netdev)
  */
 static int rwnx_open(struct net_device *dev)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
-    struct mm_add_if_cfm add_if_cfm;
-    int error = 0;
-    int err = 0;
-    u8 rwnx_rx_gain = 0x0E;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	struct mm_add_if_cfm add_if_cfm;
+	int error = 0;
+	int err = 0;
+	u8 rwnx_rx_gain = 0x0E;
 	int waiting_counter = 10;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-	while(test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+	while (test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)) {
 		msleep(100);
 		AICWFDBG(LOGDEBUG, "%s waiting for rwnx_close \r\n", __func__);
 		waiting_counter--;
-		if(waiting_counter == 0){
-			AICWFDBG(LOGERROR, "%s error waiting for close time out \r\n", __func__);
+		if (waiting_counter == 0) {
+			AICWFDBG(LOGERROR,
+				 "%s error waiting for close time out \r\n",
+				 __func__);
 			break;
 		}
 	}
+	// Check if it is the first opened VIF
+	if (rwnx_hw->vif_started == 0) {
+		// Start the FW
+		if ((error = rwnx_send_start(rwnx_hw)))
+			return error;
 
-    // Check if it is the first opened VIF
-    if (rwnx_hw->vif_started == 0)
-    {
-        // Start the FW
-       if ((error = rwnx_send_start(rwnx_hw)))
-           return error;
+		if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+		    rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
+			error = rwnx_send_dbg_mem_mask_write_req(
+				rwnx_hw, 0x4033b300, 0xFF, rwnx_rx_gain);
+			if (error) {
+				return error;
+			}
+		}
 
-       if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
-            error = rwnx_send_dbg_mem_mask_write_req(rwnx_hw, 0x4033b300, 0xFF, rwnx_rx_gain);
-            if(error){
-                return error;
-            }
-       }
+		/* Device is now started */
+	}
 
-       /* Device is now started */
-       set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
-	   atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
-    }
+	set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
+	rwnx_set_conn_state(&rwnx_vif->drv_conn_state,
+			    RWNX_DRV_STATUS_DISCONNECTED);
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__,
+		 (int)rwnx_vif->drv_flags);
 
-	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
-    {
-        #ifdef CONFIG_COEX
-        rwnx_send_coex_req(rwnx_hw, 1, 0);
-        #endif
-    }
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP ||
+	    RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+#ifdef CONFIG_COEX
+		rwnx_send_coex_req(rwnx_hw, 1, 0);
+#endif
+	}
 
-	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT ||
+	    RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
 		if (!rwnx_hw->is_p2p_alive) {
 			if (rwnx_hw->p2p_dev_vif && !rwnx_hw->p2p_dev_vif->up) {
-				err = rwnx_send_add_if (rwnx_hw, rwnx_hw->p2p_dev_vif->wdev.address,
-											  RWNX_VIF_TYPE(rwnx_hw->p2p_dev_vif), false, &add_if_cfm);
+				err = rwnx_send_add_if(
+					rwnx_hw,
+					rwnx_hw->p2p_dev_vif->wdev.address,
+					RWNX_VIF_TYPE(rwnx_hw->p2p_dev_vif),
+					false, &add_if_cfm);
 				if (err) {
 					return -EIO;
 				}
@@ -1280,94 +1345,106 @@ static int rwnx_open(struct net_device *dev)
 
 				/* Save the index retrieved from LMAC */
 				spin_lock_bh(&rwnx_hw->cb_lock);
-				rwnx_hw->p2p_dev_vif->vif_index = add_if_cfm.inst_nbr;
+				rwnx_hw->p2p_dev_vif->vif_index =
+					add_if_cfm.inst_nbr;
 				rwnx_hw->p2p_dev_vif->up = true;
 				rwnx_hw->vif_started++;
-				rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_hw->p2p_dev_vif;
+				rwnx_hw->vif_table[add_if_cfm.inst_nbr] =
+					rwnx_hw->p2p_dev_vif;
 				spin_unlock_bh(&rwnx_hw->cb_lock);
 			}
 			rwnx_hw->is_p2p_alive = 1;
-			mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
+#ifndef CONFIG_USE_P2P0
+			mod_timer(&rwnx_hw->p2p_alive_timer,
+				  jiffies + msecs_to_jiffies(1000));
 			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
 		}
 	}
 
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
-        /* For AP_vlan use same fw and drv indexes. We ensure that this index
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
+		/* For AP_vlan use same fw and drv indexes. We ensure that this index
            will not be used by fw for another vif by taking index >= NX_VIRT_DEV_MAX */
-        add_if_cfm.inst_nbr = rwnx_vif->drv_vif_index;
-        netif_tx_stop_all_queues(dev);
+		add_if_cfm.inst_nbr = rwnx_vif->drv_vif_index;
+		netif_tx_stop_all_queues(dev);
 
-        /* Save the index retrieved from LMAC */
-        spin_lock_bh(&rwnx_hw->cb_lock);
-        rwnx_vif->vif_index = add_if_cfm.inst_nbr;
-        rwnx_vif->up = true;
-        rwnx_hw->vif_started++;
-        rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
-        AICWFDBG(LOGDEBUG, "%s ap create vif in rwnx_hw->vif_table[%d] \r\n", 
-            __func__, rwnx_vif->vif_index);
-        spin_unlock_bh(&rwnx_hw->cb_lock);
-    } else {
-        /* Forward the information to the LMAC,
+		/* Save the index retrieved from LMAC */
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_vif->vif_index = add_if_cfm.inst_nbr;
+		rwnx_vif->up = true;
+		rwnx_hw->vif_started++;
+		rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+		AICWFDBG(LOGDEBUG,
+			 "%s ap create vif in rwnx_hw->vif_table[%d] \r\n",
+			 __func__, rwnx_vif->vif_index);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+	} else {
+		/* Forward the information to the LMAC,
          *     p2p value not used in FMAC configuration, iftype is sufficient */
+		if ((error = rwnx_send_add_if(rwnx_hw, rwnx_vif->wdev.address,
+					      RWNX_VIF_TYPE(rwnx_vif), false,
+					      &add_if_cfm))) {
+			AICWFDBG(LOGERROR, "add if fail\n");
+			return error;
+		}
 
-        if ((error = rwnx_send_add_if(rwnx_hw, rwnx_vif->wdev.address,
-                                      RWNX_VIF_TYPE(rwnx_vif), false, &add_if_cfm))) {
-            AICWFDBG(LOGERROR, "add if fail\n");
-            return error;
-        }
-
-        if (add_if_cfm.status != 0) {
-            RWNX_PRINT_CFM_ERR(add_if);
-            return -EIO;
-        }
+		if (add_if_cfm.status != 0) {
+			RWNX_PRINT_CFM_ERR(add_if);
+			return -EIO;
+		}
 
-        /* Save the index retrieved from LMAC */
-        spin_lock_bh(&rwnx_hw->cb_lock);
-        rwnx_vif->vif_index = add_if_cfm.inst_nbr;
-        rwnx_vif->up = true;
-        rwnx_hw->vif_started++;
-        rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
-        AICWFDBG(LOGDEBUG, "%s sta create vif in rwnx_hw->vif_table[%d] \r\n", 
-            __func__, rwnx_vif->vif_index);
-        spin_unlock_bh(&rwnx_hw->cb_lock);
+		/* Save the index retrieved from LMAC */
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_vif->vif_index = add_if_cfm.inst_nbr;
+		rwnx_vif->up = true;
+		rwnx_hw->vif_started++;
+		rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+		AICWFDBG(LOGDEBUG,
+			 "%s sta create vif in rwnx_hw->vif_table[%d] \r\n",
+			 __func__, rwnx_vif->vif_index);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
 #ifdef CONFIG_USE_P2P0
-        if(rwnx_vif->is_p2p_vif){
-            rwnx_hw->p2p_dev_vif = rwnx_vif;
-            rwnx_hw->is_p2p_alive = 1;
-        }
+		if (rwnx_vif->is_p2p_vif) {
+			rwnx_hw->p2p_dev_vif = rwnx_vif;
+			rwnx_hw->is_p2p_alive = 1;
+		}
 #endif
+	}
 
-    }
-
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR){
-        rwnx_hw->monitor_vif = rwnx_vif->vif_index;
-        if (rwnx_vif->ch_index != RWNX_CH_NOT_SET){
-            //Configure the monitor channel
-            error = rwnx_send_config_monitor_req(rwnx_hw, &rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def, NULL);
-        }
-        #if defined(CONFIG_RWNX_MON_XMIT)
-        rwnx_txq_unk_vif_init(rwnx_vif);
-        #endif
-        #if defined(CONFIG_RWNX_MON_RXFILTER)
-        rwnx_send_set_filter(rwnx_hw, (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS | FIF_PSPOLL | FIF_PROBE_REQ));
-        #endif
-    }
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR) {
+		rwnx_hw->monitor_vif = rwnx_vif->vif_index;
+		if (rwnx_vif->ch_index != RWNX_CH_NOT_SET) {
+			//Configure the monitor channel
+			error = rwnx_send_config_monitor_req(
+				rwnx_hw,
+				&rwnx_hw->chanctx_table[rwnx_vif->ch_index]
+					 .chan_def,
+				NULL);
+		}
+#if defined(CONFIG_RWNX_MON_XMIT)
+		rwnx_txq_unk_vif_init(rwnx_vif);
+#endif
+#if defined(CONFIG_RWNX_MON_RXFILTER)
+		rwnx_send_set_filter(rwnx_hw,
+				     (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS |
+				      FIF_PSPOLL | FIF_PROBE_REQ));
+#endif
+	}
 
-    //netif_carrier_off(dev);
-    #if defined(CONFIG_RWNX_MON_XMIT)
-    netif_carrier_on(dev);
+//netif_carrier_off(dev);
+#if defined(CONFIG_RWNX_MON_XMIT)
+	netif_carrier_on(dev);
 	AICWFDBG(LOGINFO, "monitor xmit: netif_carrier_on\n");
-    #endif
+#endif
 
 #ifdef CONFIG_BR_SUPPORT
-    netdev_br_init(dev);
+	netdev_br_init(dev);
 #endif /* CONFIG_BR_SUPPORT */
 
-    //netif_carrier_off(dev);
-    netif_start_queue(dev);
+	//netif_carrier_off(dev);
+	netif_start_queue(dev);
 
-    return error;
+	return error;
 }
 
 /**
@@ -1380,47 +1457,55 @@ static int rwnx_open(struct net_device *dev)
  */
 static int rwnx_close(struct net_device *dev)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
-    struct aicwf_bus *bus_if = NULL;
-    int ret = 0;
-    int waiting_counter = 20;
-    int test_counter = 0;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	struct aicwf_bus *bus_if = NULL;
+	int ret = 0;
+	int waiting_counter = 20;
+	int test_counter = 0;
 #if defined(AICWF_USB_SUPPORT)
-    struct aic_usb_dev *usbdev = NULL;
-    bus_if = dev_get_drvdata(rwnx_hw->dev);
-    if (bus_if)
-        usbdev = bus_if->bus_priv.usb;
+	struct aic_usb_dev *usbdev = NULL;
+	bus_if = dev_get_drvdata(rwnx_hw->dev);
+	if (bus_if)
+		usbdev = bus_if->bus_priv.usb;
 #endif
 #if defined(AICWF_SDIO_SUPPORT)
-    struct aic_sdio_dev *sdiodev = NULL;
-    bus_if = dev_get_drvdata(rwnx_hw->dev);
-    if (bus_if)
-        sdiodev = bus_if->bus_priv.sdio;
+	struct aic_sdio_dev *sdiodev = NULL;
+	bus_if = dev_get_drvdata(rwnx_hw->dev);
+	if (bus_if)
+		sdiodev = bus_if->bus_priv.sdio;
 #endif
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 	test_counter = waiting_counter;
-	while(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
-		atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGDEBUG, "%s wifi is connecting or disconnecting, waiting 200ms for state to stable\r\n", __func__);
+	while (atomic_read(&rwnx_vif->drv_conn_state) ==
+		       (int)RWNX_DRV_STATUS_DISCONNECTING ||
+	       atomic_read(&rwnx_vif->drv_conn_state) ==
+		       (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(
+			LOGDEBUG,
+			"%s wifi is connecting or disconnecting, waiting 200ms for state to stable\r\n",
+			__func__);
 		msleep(200);
 		test_counter--;
-		if(test_counter == 0){
-			AICWFDBG(LOGERROR, "%s connecting or disconnecting, not finish\r\n", __func__);
+		if (test_counter == 0) {
+			AICWFDBG(
+				LOGERROR,
+				"%s connecting or disconnecting, not finish\r\n",
+				__func__);
 			WARN_ON(1);
 			break;
 		}
 	}
 
 #if defined(AICWF_USB_SUPPORT) || defined(AICWF_SDIO_SUPPORT)
-    if (scanning){
-        scanning = false;
-    }
+	if (rwnx_hw->scanning) {
+		rwnx_hw->scanning = false;
+	}
 
-	if(p2p_working){
-		p2p_working = false;
+	if (rwnx_hw->p2p_working) {
+		rwnx_hw->p2p_working = false;
 	}
 #endif
 #if 0
@@ -1428,1479 +1513,211 @@ static int rwnx_close(struct net_device *dev)
 #endif
 	AICWFDBG(LOGINFO, "%s %s Enter\n", __func__, dev->name);
 
+#if 0
 #ifdef CONFIG_USE_P2P0
     if(rwnx_hw->p2p_dev_vif){
         atomic_set(&rwnx_hw->p2p_alive_timer_count, P2P_ALIVE_TIME_MS);
         rwnx_hw->is_p2p_alive = 0;
     }
+#endif
 #endif
 
-    rwnx_radar_cancel_cac(&rwnx_hw->radar);
+	rwnx_radar_cancel_cac(&rwnx_hw->radar);
 
-    /* Abort scan request on the vif */
-    if (rwnx_hw->scan_request &&
-        rwnx_hw->scan_request->wdev == &rwnx_vif->wdev) {
+	/* Abort scan request on the vif */
+	if (rwnx_hw->scan_request &&
+	    rwnx_hw->scan_request->wdev == &rwnx_vif->wdev) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-        struct cfg80211_scan_info info = {
-            .aborted = true,
-        };
+		struct cfg80211_scan_info info = {
+			.aborted = true,
+		};
 
-        cfg80211_scan_done(rwnx_hw->scan_request, &info);
+		cfg80211_scan_done(rwnx_hw->scan_request, &info);
 #else
-        cfg80211_scan_done(rwnx_hw->scan_request, true);
+		cfg80211_scan_done(rwnx_hw->scan_request, true);
 #endif
-        rwnx_hw->scan_request = NULL;
+		rwnx_hw->scan_request = NULL;
 		ret = rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
-		mdelay(35);//make sure firmware take affect
+		mdelay(35); //make sure firmware take affect
 		if (ret) {
 			AICWFDBG(LOGERROR, "scanu_cancel fail\n");
 			return ret;
 		}
-    }
+	}
 
 #if defined(AICWF_USB_SUPPORT)
-    if (usbdev != NULL) {
-        if (usbdev->bus_if->state != BUS_DOWN_ST && usbdev->state != USB_DOWN_ST)
-			AICWFDBG(LOGINFO, "state: %d %d \r\n", (int)usbdev->bus_if->state, (int)usbdev->state);
-
-		if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
-			RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT){
+	if (usbdev != NULL) {
+		if (usbdev->bus_if->state != BUS_DOWN_ST &&
+		    usbdev->state != USB_DOWN_ST)
+			AICWFDBG(LOGINFO, "state: %d %d \r\n",
+				 (int)usbdev->bus_if->state,
+				 (int)usbdev->state);
+
+		if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
+		    RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
 			test_counter = waiting_counter;
-			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
-				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
-				rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
-				while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
-					AICWFDBG(LOGDEBUG, "%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
+			if (atomic_read(&rwnx_vif->drv_conn_state) ==
+			    (int)RWNX_DRV_STATUS_CONNECTED) {
+				rwnx_set_conn_state(
+					&rwnx_vif->drv_conn_state,
+					RWNX_DRV_STATUS_DISCONNECTING);
+				rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif,
+							    3);
+				while (atomic_read(&rwnx_vif->drv_conn_state) ==
+				       (int)RWNX_DRV_STATUS_DISCONNECTING) {
+					AICWFDBG(
+						LOGDEBUG,
+						"%s wifi is disconnecting, waiting 100ms for state to stable\r\n",
+						__func__);
 					msleep(100);
 					test_counter--;
-					if (test_counter ==0)
+					if (test_counter == 0)
 						break;
 				}
 			}
 		}
 #ifdef CONFIG_USE_P2P0
-        if(!rwnx_vif->is_p2p_vif || ( rwnx_vif->is_p2p_vif && rwnx_hw->is_p2p_alive)){
+		if (!rwnx_vif->is_p2p_vif ||
+		    (rwnx_vif->is_p2p_vif && rwnx_hw->is_p2p_alive)) {
+			if (rwnx_vif->is_p2p_vif)
+				rwnx_hw->is_p2p_alive = 0;
 #endif
-    		rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index, false);
+			rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index,
+					    false);
 #ifdef CONFIG_USE_P2P0
-        }
+		}
 #endif
-
-    }
+	}
 #endif
 #if defined(AICWF_SDIO_SUPPORT)
-    if (sdiodev != NULL ) {
-        if (sdiodev->bus_if->state != BUS_DOWN_ST)
-            rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index, false);
-    }
+	if (sdiodev != NULL) {
+		if (sdiodev->bus_if->state != BUS_DOWN_ST)
+			rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index,
+					    false);
+	}
 #endif
 
-    if (rwnx_hw->roc_elem && (rwnx_hw->roc_elem->wdev == &rwnx_vif->wdev)) {
+	if (rwnx_hw->roc_elem && (rwnx_hw->roc_elem->wdev == &rwnx_vif->wdev)) {
 		AICWFDBG(LOGINFO, "%s clear roc\n", __func__);
-        /* Initialize RoC element pointer to NULL, indicate that RoC can be started */
-        rwnx_hw->roc_elem = NULL;
-    }
+		/* Initialize RoC element pointer to NULL, indicate that RoC can be started */
+		rwnx_hw->roc_elem = NULL;
+	}
 
-    /* Ensure that we won't process disconnect ind */
-    spin_lock_bh(&rwnx_hw->cb_lock);
-
-    rwnx_vif->up = false;
-    AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
-    
-    if (netif_carrier_ok(dev)) {
-        if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
-            RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
-            cfg80211_disconnected(dev, WLAN_REASON_DEAUTH_LEAVING,
-                                  NULL, 0, true, GFP_ATOMIC);
-            netif_tx_stop_all_queues(dev);
-            netif_carrier_off(dev);
-        } else if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
-            netif_carrier_off(dev);
-        } else {
-            netdev_warn(dev, "AP not stopped when disabling interface");
+	/* Ensure that we won't process disconnect ind */
+	spin_lock_bh(&rwnx_hw->cb_lock);
+
+	rwnx_vif->up = false;
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__,
+		 rwnx_vif->vif_index);
+
+	if (netif_carrier_ok(dev)) {
+		if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
+		    RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
+			cfg80211_disconnected(dev, WLAN_REASON_DEAUTH_LEAVING,
+					      NULL, 0, true, GFP_ATOMIC);
+			netif_tx_stop_all_queues(dev);
+			netif_carrier_off(dev);
+		} else if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
+			netif_carrier_off(dev);
+		} else {
+			netdev_warn(dev,
+				    "AP not stopped when disabling interface");
 		}
 #ifdef CONFIG_BR_SUPPORT
-        /* if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE)) */
-        {
-            /* void nat25_db_cleanup(_adapter *priv); */
-            nat25_db_cleanup(rwnx_vif);
-        }
+		/* if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE)) */
+		{
+			/* void nat25_db_cleanup(_adapter *priv); */
+			nat25_db_cleanup(rwnx_vif);
+		}
 #endif /* CONFIG_BR_SUPPORT */
 	}
 
+	rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+	spin_unlock_bh(&rwnx_hw->cb_lock);
 
-    rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
-    spin_unlock_bh(&rwnx_hw->cb_lock);
-
-    rwnx_chanctx_unlink(rwnx_vif);
+	rwnx_chanctx_unlink(rwnx_vif);
 
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR)
-        rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR)
+		rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
-    {
-    #ifdef CONFIG_COEX
-        rwnx_send_coex_req(rwnx_hw, 0, 1);
-    #endif
-    }
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP ||
+	    RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+#ifdef CONFIG_COEX
+		rwnx_send_coex_req(rwnx_hw, 0, 1);
+#endif
+	}
 
-    rwnx_hw->vif_started--;
-    if (rwnx_hw->vif_started == 0) {
-        /* This also lets both ipc sides remain in sync before resetting */
-        #if 0
+	rwnx_hw->vif_started--;
+	if (rwnx_hw->vif_started == 0) {
+/* This also lets both ipc sides remain in sync before resetting */
+#if 0
         rwnx_ipc_tx_drain(rwnx_hw);
-        #else
-        #if defined(AICWF_USB_SUPPORT)
-        if (usbdev->bus_if->state != BUS_DOWN_ST && usbdev->state != USB_DOWN_ST) {
-        #else
-        if (sdiodev->bus_if->state != BUS_DOWN_ST) {
-        #endif
-            rwnx_send_reset(rwnx_hw);
-            #if defined(AICWF_USB_SUPPORT)
-            if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
-                    ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81)&& testmode == 0)) {
-            #endif
-                // Set parameters to firmware
-                rwnx_send_me_config_req(rwnx_hw);
-                // Set channel parameters to firmware
-                rwnx_send_me_chan_config_req(rwnx_hw);
-            #if defined(AICWF_USB_SUPPORT)
-            }
-            #endif
-        }
-        #endif
-        clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
-    }
+#else
+#if defined(AICWF_USB_SUPPORT)
+		if (usbdev->bus_if->state != BUS_DOWN_ST &&
+		    usbdev->state != USB_DOWN_ST)
+#else
+		if (sdiodev->bus_if->state != BUS_DOWN_ST)
+#endif
+		{
+			rwnx_send_reset(rwnx_hw);
+#if defined(AICWF_USB_SUPPORT)
+			if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
+			    ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+			      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+			      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+			      rwnx_hw->usbdev->chipid ==
+				      PRODUCT_ID_AIC8800D81X2 ||
+			      rwnx_hw->usbdev->chipid ==
+				      PRODUCT_ID_AIC8800D89X2) &&
+			     testmode == 0)) {
+#endif
+				// Set parameters to firmware
+				rwnx_send_me_config_req(rwnx_hw);
+				// Set channel parameters to firmware
+				rwnx_send_me_chan_config_req(rwnx_hw);
+#if defined(AICWF_USB_SUPPORT)
+			}
+#endif
+		}
+#endif
+	}
 
-    return 0;
+	clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__,
+		 (int)rwnx_vif->drv_flags);
+	return 0;
 }
 
-#ifdef CONFIG_RFTEST
-enum {
-    SET_TX,
-    SET_TXSTOP,
-    SET_TXTONE,
-    SET_RX,
-    GET_RX_RESULT,
-    SET_RXSTOP,
-    SET_RX_METER,
-    SET_POWER,
-    SET_XTAL_CAP,
-    SET_XTAL_CAP_FINE,
-    GET_EFUSE_BLOCK,
-    SET_FREQ_CAL,
-    SET_FREQ_CAL_FINE,
-    GET_FREQ_CAL,
-    SET_MAC_ADDR,
-    GET_MAC_ADDR,
-    SET_BT_MAC_ADDR,
-    GET_BT_MAC_ADDR,
-    SET_VENDOR_INFO,
-    GET_VENDOR_INFO,
-    RDWR_PWRMM,
-    RDWR_PWRIDX,
-    RDWR_PWRLVL = RDWR_PWRIDX,
-    RDWR_PWROFST,
-    RDWR_DRVIBIT,
-    RDWR_EFUSE_PWROFST,
-    RDWR_EFUSE_DRVIBIT,
-    SET_PAPR,
-    SET_CAL_XTAL,
-    GET_CAL_XTAL_RES,
-    SET_COB_CAL,
-    GET_COB_CAL_RES,
-    RDWR_EFUSE_USRDATA,
-    SET_NOTCH,
-    RDWR_PWROFSTFINE,
-    RDWR_EFUSE_PWROFSTFINE,
-    RDWR_EFUSE_SDIOCFG,
-    RDWR_EFUSE_USBVIDPID,
-
-    #ifdef CONFIG_USB_BT
-    BT_CMD_BASE = 0x100,
-    BT_RESET,
-    BT_TXDH,
-    BT_RXDH,
-    BT_STOP,
-    GET_BT_RX_RESULT,
-    #endif
-};
-
-typedef struct
-{
-    u8_l chan;
-    u8_l bw;
-    u8_l mode;
-    u8_l rate;
-    u16_l length;
-    u16_l tx_intv_us;
-}cmd_rf_settx_t;
-
-typedef struct
-{
-    u8_l val;
-}cmd_rf_setfreq_t;
-
-typedef struct
-{
-    u8_l chan;
-    u8_l bw;
-}cmd_rf_rx_t;
-
-typedef struct
-{
-    u8_l block;
-}cmd_rf_getefuse_t;
-typedef struct
-{
-    u8_l dutid;
-    u8_l chip_num;
-    u8_l dis_xtal;
-}cmd_rf_setcobcal_t;
-typedef struct
-{
-    u16_l dut_rcv_golden_num;
-    u8_l golden_rcv_dut_num;
-    s8_l rssi_static;
-    s8_l snr_static;
-    s8_l dut_rssi_static;
-    u16_l reserved;
-}cob_result_ptr_t;
-
-typedef struct
-{
-    u8_l func;
-    u8_l cnt;
-    u8_l reserved[2];
-    u32_l usrdata[3]; // 3 words totally
-} cmd_ef_usrdata_t;
-
-#endif
-
-#define CMD_MAXARGS 30
-
-#if 0
-#define isblank(c)      ((c) == ' ' || (c) == '\t')
-#define isascii(c)      (((unsigned char)(c)) <= 0x7F)
-
-static int isdigit(unsigned char c)
-{
-    return ((c >= '0') && (c <='9'));
-}
-
-static int isxdigit(unsigned char c)
-{
-    if ((c >= '0') && (c <='9'))
-        return 1;
-    if ((c >= 'a') && (c <='f'))
-        return 1;
-    if ((c >= 'A') && (c <='F'))
-        return 1;
-    return 0;
-}
-
-static int islower(unsigned char c)
-{
-    return ((c >= 'a') && (c <='z'));
-}
-
-static unsigned char toupper(unsigned char c)
-{
-    if (islower(c))
-        c -= 'a'-'A';
-    return c;
-}
-#endif
-
-
-static int parse_line (char *line, char *argv[])
-{
-    int nargs = 0;
-
-    while (nargs < CMD_MAXARGS) {
-        /* skip any white space */
-        while ((*line == ' ') || (*line == '\t')) {
-            ++line;
-        }
-
-        if (*line == '\0') {    /* end of line, no more args    */
-            argv[nargs] = 0;
-            return (nargs);
-        }
-
-        /* Argument include space should be bracketed by quotation mark */
-        if (*line == '\"') {
-            /* Skip quotation mark */
-            line++;
-
-            /* Begin of argument string */
-            argv[nargs++] = line;
-
-            /* Until end of argument */
-            while(*line && (*line != '\"')) {
-                ++line;
-            }
-        } else {
-            argv[nargs++] = line;    /* begin of argument string    */
-
-            /* find end of string */
-            while(*line && (*line != ' ') && (*line != '\t')) {
-                ++line;
-            }
-        }
-
-        if (*line == '\0') {    /* end of line, no more args    */
-            argv[nargs] = 0;
-            return (nargs);
-        }
-
-        *line++ = '\0';         /* terminate current arg     */
-    }
-
-    printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
-
-    return (nargs);
-}
-
-unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
-{
-    unsigned int result = 0, value, is_neg=0;
-
-    if (*cp == '0') {
-        cp++;
-        if ((*cp == 'x') && isxdigit(cp[1])) {
-            base = 16;
-            cp++;
-        }
-        if (!base) {
-            base = 8;
-        }
-    }
-    if (!base) {
-        base = 10;
-    }
-    if (*cp == '-') {
-        is_neg = 1;
-        cp++;
-    }
-    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
-        result = result * base + value;
-        cp++;
-    }
-    if (is_neg)
-        result = (unsigned int)((int)result * (-1));
-
-    if (endp)
-        *endp = (char *)cp;
-    return result;
-}
-
-
-int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
-{
-    int bytes_written = 0;
-    char* para = NULL;
-    char* cmd = NULL;
-    char *argv[CMD_MAXARGS + 1];
-    int argc;
-    #ifdef CONFIG_RFTEST
-    struct dbg_rftest_cmd_cfm cfm = {{0,}};
-    u8_l mac_addr[6];
-    cmd_rf_settx_t settx_param;
-    cmd_rf_rx_t setrx_param;
-    int freq;
-    cmd_rf_getefuse_t getefuse_param;
-    cmd_rf_setfreq_t cmd_setfreq;
-    cmd_rf_setcobcal_t setcob_cal;
-    cob_result_ptr_t *cob_result_ptr;
-    cmd_ef_usrdata_t cmd_ef_usrdata;
-    u8_l ana_pwr;
-    u8_l dig_pwr;
-    u8_l pwr;
-    u8_l papr;
-    u8_l xtal_cap;
-    u8_l xtal_cap_fine;
-    u8_l vendor_info;
-    #ifdef CONFIG_USB_BT
-    int bt_index;
-    u8_l dh_cmd_reset[4];
-    u8_l dh_cmd_txdh[18];
-    u8_l dh_cmd_rxdh[17];
-    u8_l dh_cmd_stop[5];
-    #endif
-    #endif
-	u8_l buf[2];
-	s8_l freq_ = 0;
-	u8_l func = 0;
-	u8_l state = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    if ((argc = parse_line(command, argv)) == 0) {
-        return -1;
-    }
-
-    do {
-        #ifdef AICWF_SDIO_SUPPORT
-        struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->sdiodev->rwnx_hw;
-        #endif
-        #ifdef AICWF_USB_SUPPORT
-	#ifdef CONFIG_RFTEST
-        struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->usbdev->rwnx_hw;
-	#endif
-        #endif
-        #ifdef CONFIG_RFTEST
-        if (strcasecmp(argv[0], "GET_RX_RESULT") ==0) {
-            AICWFDBG(LOGINFO, "get_rx_result\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-        } else if (strcasecmp(argv[0], "SET_TX") == 0) {
-            AICWFDBG(LOGINFO, "set_tx\n");
-            if (argc < 6) {
-                printk("wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            settx_param.chan = command_strtoul(argv[1], NULL, 10);
-            settx_param.bw = command_strtoul(argv[2], NULL, 10);
-            settx_param.mode = command_strtoul(argv[3], NULL, 10);
-            settx_param.rate = command_strtoul(argv[4], NULL, 10);
-            settx_param.length = command_strtoul(argv[5], NULL, 10);
-            if (argc > 6) {
-                settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
-            } else {
-                settx_param.tx_intv_us = 0;
-            }
-            AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
-                settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
-        } else if (strcasecmp(argv[0], "SET_TXSTOP") == 0) {
-            AICWFDBG(LOGINFO, "settx_stop\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "SET_TXTONE") == 0) {
-            AICWFDBG(LOGINFO, "set_tx_tone,argc:%d\n",argc);
-            if ((argc == 2) || (argc == 3)) {
-                AICWFDBG(LOGINFO, "argv 1:%s\n",argv[1]);
-                //u8_l func = (u8_l)command_strtoul(argv[1], NULL, 16);
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-                //s8_l freq;
-                if (argc == 3) {
-                    AICWFDBG(LOGINFO, "argv 2:%s\n",argv[2]);
-                    freq_ = (u8_l)command_strtoul(argv[2], NULL, 10);
-                } else {
-                    freq_ = 0;
-                };
-                //u8_l buf[2] = {func, (u8_l)freq};
-                buf[0] = func;
-				buf[1] = (u8_l)freq_;
-                rwnx_send_rftest_req(p_rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
-            } else {
-                AICWFDBG(LOGINFO, "wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_RX") == 0) {
-            AICWFDBG(LOGINFO, "set_rx\n");
-            if (argc < 3) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            setrx_param.chan = command_strtoul(argv[1], NULL, 10);
-            setrx_param.bw = command_strtoul(argv[2], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
-        } else if (strcasecmp(argv[0], "SET_RXSTOP") == 0) {
-            AICWFDBG(LOGINFO, "set_rxstop\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "SET_RX_METER") == 0) {
-            AICWFDBG(LOGINFO, "set_rx_meter\n");
-            freq = (int)command_strtoul(argv[1], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RX_METER, sizeof(freq), (u8_l *)&freq, NULL);
-        } else if (strcasecmp(argv[0], "SET_FREQ_CAL") == 0) {
-            AICWFDBG(LOGINFO, "set_freq_cal\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_FREQ_CAL_FINE") == 0) {
-            AICWFDBG(LOGINFO, "set_freq_cal_fine\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "GET_EFUSE_BLOCK") == 0) {
-            AICWFDBG(LOGINFO, "get_efuse_block\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            getefuse_param.block = command_strtoul(argv[1], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, GET_EFUSE_BLOCK, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
-            AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_POWER") == 0) {
-            AICWFDBG(LOGINFO, "set_power\n");
-            if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) {
-                ana_pwr = command_strtoul(argv[1], NULL, 16);
-                dig_pwr = command_strtoul(argv[2], NULL, 16);
-                pwr = (ana_pwr << 4 | dig_pwr);
-                if (ana_pwr > 0xf || dig_pwr > 0xf) {
-                    AICWFDBG(LOGERROR, "invalid param\r\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                ana_pwr = command_strtoul(argv[1], NULL, 10);
-                pwr = ana_pwr;
-                if (ana_pwr > 0x1e) {
-                    AICWFDBG(LOGERROR, "invalid param\r\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            }
-            AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
-        } else if (strcasecmp(argv[0], "SET_PAPR") == 0) {
-            printk("set papr\n");
-            if (argc > 1) {
-                papr = command_strtoul(argv[1], NULL, 10);
-                printk("papr %d\r\n", papr);
-                rwnx_send_rftest_req(p_rwnx_hw, SET_PAPR, sizeof(papr), (u8_l *)&papr, NULL);
-            } else {
-                printk("wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_NOTCH") == 0) {
-            if (argc > 1) {
-                func = command_strtoul(argv[1], NULL, 10);
-                printk("set notch: %d\n", func);
-                rwnx_send_rftest_req(p_rwnx_hw, SET_NOTCH, sizeof(func), (u8_l *)&func, NULL);
-            } else {
-                printk("wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_XTAL_CAP")==0) {
-            AICWFDBG(LOGINFO, "set_xtal_cap\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            xtal_cap = command_strtoul(argv[1], NULL, 10);
-            AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_XTAL_CAP_FINE")==0) {
-            AICWFDBG(LOGINFO, "set_xtal_cap_fine\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
-            AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_MAC_ADDR")==0) {
-            AICWFDBG(LOGINFO, "set_mac_addr\n");
-            if (argc < 7) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-            mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-            mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-            mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-            mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-            mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-            AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-        } else if (strcasecmp(argv[0], "GET_MAC_ADDR")==0) {
-            u32_l addr0, addr1;
-            AICWFDBG(LOGINFO, "get mac addr\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-            addr0 = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-                addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-                AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-            } else {
-                addr1 = cfm.rftest_result[1];
-                AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-            }
-        } else if (strcasecmp(argv[0], "SET_BT_MAC_ADDR") == 0) {
-            AICWFDBG(LOGINFO, "set_bt_mac_addr\n");
-            if (argc < 7) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-            mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-            mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-            mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-            mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-            mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-            AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-        } else if (strcasecmp(argv[0], "GET_BT_MAC_ADDR")==0) {
-            u32_l addr0, addr1;
-            AICWFDBG(LOGINFO, "get bt mac addr\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-            addr0 = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-                addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-                AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-            } else {
-                addr1 = cfm.rftest_result[1];
-                AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-            }
-        } else if (strcasecmp(argv[0], "SET_VENDOR_INFO")==0) {
-            vendor_info = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                memcpy(command, &cfm.rftest_result[0], 2);
-                bytes_written = 2;
-            } else {
-                memcpy(command, &cfm.rftest_result[0], 1);
-                bytes_written = 1;
-            }
-            AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-        } else if (strcasecmp(argv[0], "GET_VENDOR_INFO")==0) {
-            AICWFDBG(LOGINFO, "get vendor info\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                memcpy(command, &cfm.rftest_result[0], 2);
-                bytes_written = 2;
-            } else {
-                memcpy(command, &cfm.rftest_result[0], 1);
-                bytes_written = 1;
-            }
-            AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-        } else if (strcasecmp(argv[0], "GET_FREQ_CAL") == 0) {
-            unsigned int val;
-            AICWFDBG(LOGINFO, "get freq cal\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-            val = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
-                        val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
-            } else {
-                AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
-            }
-        } else if (strcasecmp(argv[0], "RDWR_PWRMM") == 0) {
-            AICWFDBG(LOGINFO, "read/write txpwr manul mode\n");
-            if (argc <= 1) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
-            } else { // write
-                u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
-                pwrmm = (pwrmm) ? 1 : 0;
-                AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_PWRIDX") == 0) {
-            u8_l func = 0;
-            #ifdef AICWF_USB_SUPPORT
-            if (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8801) {
-                    AICWFDBG(LOGERROR, "unsupported cmd\n");
-                    bytes_written = -EINVAL;
-                    break;
-            }
-            #endif
-            AICWFDBG(LOGINFO, "read/write txpwr index\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr idx
-                if (argc > 3) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, type, pwridx};
-                    AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 9);
-            bytes_written = 9;
-        } else if (strcasecmp(argv[0], "RDWR_PWRLVL") == 0) {
-            u8_l func = 0;
-            #ifdef AICWF_USB_SUPPORT
-            if ((g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800DC)
-                && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800DW)
-                && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800D81)) {
-                    AICWFDBG(LOGERROR, "unsupported cmd\n");
-                    bytes_written = -EINVAL;
-                    break;
-            }
-            #endif
-            printk("read/write txpwr level\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr lvl
-                if (argc > 4) {
-                    u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l idx, size;
-                    u8_l buf[14] = {func, grp,};
-                    if (argc > 12) { // set all grp
-                        printk("set pwrlvl %s:\n"
-                               "  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
-                        if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
-                            size = 10;
-                        } else {
-                            size = 12;
-                        }
-                        for (idx = 0; idx < size; idx++) {
-                            s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
-                            buf[2 + idx] = (u8_l)pwrlvl;
-                            if (idx && !(idx & 0x3)) {
-                                printk(" ");
-                            }
-                            printk(" %2d", pwrlvl);
-                        }
-                        printk("\n");
-                        size += 2;
-                    } else { // set grp[idx]
-                        u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
-                        s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
-                        buf[2] = idx;
-                        buf[3] = (u8_l)pwrlvl;
-                        size = 4;
-                        printk("set pwrlvl %s:\n"
-                               "  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
-                    }
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
-                } else {
-                    printk("wrong args\n");
-                }
-            } else {
-                printk("wrong func: %x\n", func);
-            }
-	    if(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81){
-		memcpy(command, &cfm.rftest_result[0], 6 * 12);
-		bytes_written = 6 * 12;
-	    } else {
-		memcpy(command, &cfm.rftest_result[0], 3 * 12);
-		bytes_written = 3 * 12;
-	    }
-        } else if (strcasecmp(argv[0], "RDWR_PWROFST") == 0) {
-            u8_l func = 0;
-            int res_len = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if ((argc > 4) && (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81)) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
-                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
-                } else if ((argc > 3) && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800D81)) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
-                res_len = 3;
-            } else if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81) { // 3 * 2 (2.4g) + 3 * 6 (5g)
-                res_len = 3 * 3 + 3 * 6;
-            } else {
-                res_len = 3 + 4;
-            }
-            memcpy(command, &cfm.rftest_result[0], res_len);
-            bytes_written = res_len;
-        } else if (strcasecmp(argv[0], "RDWR_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 7);
-            bytes_written = 7;
-        } else if (strcasecmp(argv[0], "RDWR_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                    u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l buf[2] = {func, ibit};
-                    AICWFDBG(LOGINFO, "set drvibit:[%x]=%x\r\n", func, ibit);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 16);
-            bytes_written = 16;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFST") == 0) {
-            u8_l func = 0;
-            int res_len = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if ((argc > 4) && (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81)) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
-                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
-                } else if ((argc > 3) && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800D81)) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                res_len = 3 * 2;
-            } else if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81) { // 3 * 2 (2.4g) + 3 * 6 (5g)
-                res_len = 3 * 3 + 3 * 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                res_len = 3 + 4;
-            }
-            memcpy(command, &cfm.rftest_result[0], res_len);
-            bytes_written = res_len;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                memcpy(command, &cfm.rftest_result[0], 6);
-                bytes_written = 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                memcpy(command, &cfm.rftest_result[0], 7);
-                bytes_written = 7;
-            }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_CAL_XTAL") == 0) {
-            AICWFDBG(LOGINFO, "set_cal_xtal\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_CAL_XTAL, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "GET_CAL_XTAL_RES") == 0) {
-            AICWFDBG(LOGINFO, "get_cal_xtal_res\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_CAL_XTAL_RES, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-            AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
-	} else if (strcasecmp(argv[0], "SET_COB_CAL") == 0) {
-	    AICWFDBG(LOGINFO, "set_cob_cal\n");
-	    if (argc < 3) {
-	    	AICWFDBG(LOGERROR, "wrong param\n");
-	    	bytes_written = -EINVAL;
-		break;
-	    }
-	    setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
-	    setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
-	    setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
-	    rwnx_send_rftest_req(p_rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-	} else if (strcasecmp(argv[0], "GET_COB_CAL_RES")==0) {
-            AICWFDBG(LOGINFO, "get_cob_cal_res\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-            state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
-            if (!state){
-            	AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
-            	cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
-                cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
-                AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
-                cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
-		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
-                memcpy(command, &cfm.rftest_result, 16);
-                bytes_written = 16;
-            } else {
-                AICWFDBG(LOGERROR, "cob not idle\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "DO_COB_TEST") == 0) {
-            AICWFDBG(LOGINFO, "do_cob_test\n");
-            setcob_cal.dutid = 1;
-            setcob_cal.chip_num = 1;
-	    setcob_cal.dis_xtal = 0;
-            if (argc > 1 ) {
-	        setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
-	    }
-	    rwnx_send_rftest_req(p_rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-            msleep(2000);
-            rwnx_send_rftest_req(p_rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-            state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
-            if (!state){
-                AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
-                cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
-                cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
-                AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
-                cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
-                cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
-                memcpy(command, &cfm.rftest_result, 16);
-                bytes_written = 16;
-            } else {
-                AICWFDBG(LOGERROR, "cob not idle\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_USRDATA") == 0) {
-            AICWFDBG(LOGINFO, "read/write efuse usrdata\n");
-            if (argc <= 1) { // read all
-                cmd_ef_usrdata.func = 0;
-                cmd_ef_usrdata.cnt = 3;
-            } else if (argc >= 2) { // read/write
-                cmd_ef_usrdata.func = (u8_l)command_strtoul(argv[1], NULL, 10);
-                cmd_ef_usrdata.cnt = (u8_l)command_strtoul(argv[2], NULL, 10);
-                if (cmd_ef_usrdata.func == 1) {
-                    int idx;
-                    for (idx = 0; idx < cmd_ef_usrdata.cnt; idx++) {
-                        cmd_ef_usrdata.usrdata[idx] = (u32_l)command_strtoul(argv[3 + idx], NULL, 16);
-                    }
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong argc: %x\n", argc);
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_USRDATA, sizeof(cmd_ef_usrdata), (u8_l *)&cmd_ef_usrdata, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 12);
-            bytes_written = 12;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_SDIOCFG") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write sdiocfg_bit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
-            } else if (func == 1) { // write sdiocfg
-                if (argc > 2) {
-                    u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l buf[2] = {func, ibit};
-                    AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_USBVIDPID") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write usb vid/pid into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_USBVIDPID, 0, NULL, &cfm);
-            } else if (func == 1) { // write USB vid+pid
-                if (argc > 2) {
-                    u32_l usb_id = (u32_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l buf[5] = {func, (u8_l)usb_id, (u8_l)(usb_id >> 8), (u8_l)(usb_id >> 16), (u8_l)(usb_id >> 24)};
-                    AICWFDBG(LOGINFO, "set efuse usb vid/pid:[%x]=%x\r\n", func, usb_id);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_USBVIDPID, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        }
-        #ifdef CONFIG_USB_BT
-        else if (strcasecmp(argv[0], "BT_RESET") == 0) {
-            if (argc == 5) {
-                AICWFDBG(LOGINFO, "btrf reset\n");
-                for (bt_index = 0; bt_index < 4; bt_index++) {
-                    dh_cmd_reset[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ",dh_cmd_reset[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_RESET, sizeof(dh_cmd_reset), (u8_l *)&dh_cmd_reset, NULL);
-        } else if (strcasecmp(argv[0], "BT_TXDH") == 0) {
-            if (argc == 19) {
-                AICWFDBG(LOGINFO, "btrf txdh\n");
-                for (bt_index = 0; bt_index < 18; bt_index++) {
-                    dh_cmd_txdh[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_txdh[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_TXDH, sizeof(dh_cmd_txdh), (u8_l *)&dh_cmd_txdh, NULL);
-        } else if (strcasecmp(argv[0], "BT_RXDH") == 0) {
-            if (argc == 18) {
-                AICWFDBG(LOGINFO, "btrf rxdh\n");
-                for (bt_index = 0; bt_index < 17; bt_index++) {
-                    dh_cmd_rxdh[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_rxdh[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_RXDH, sizeof(dh_cmd_rxdh), (u8_l *)&dh_cmd_rxdh, NULL);
-        } else if (strcasecmp(argv[0], "BT_STOP") == 0) {
-            if (argc == 6) {
-                AICWFDBG(LOGINFO, "btrf stop\n");
-                for (bt_index = 0; bt_index < 5; bt_index++) {
-                    dh_cmd_stop[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_stop[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_STOP, sizeof(dh_cmd_stop), (u8_l *)&dh_cmd_stop, NULL);
-        } else if (strcasecmp(argv[0], "GET_BT_RX_RESULT") ==0) {
-            AICWFDBG(LOGINFO, "get_bt_rx_result\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_BT_RX_RESULT, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 12);
-            bytes_written = 12;
-        }
-        #endif
-        else {
-            AICWFDBG(LOGERROR, "wrong cmd:%s in %s\n", cmd, __func__);
-            bytes_written = -EINVAL;
-            break;
-        }
-        #endif
-    } while(0);
-    kfree(cmd);
-    kfree(para);
-    return bytes_written;
-}
-
-//Android private command
-
-#define RWNX_COUNTRY_CODE_LEN 2
-#define CMD_SET_COUNTRY         "COUNTRY"
-#define CMD_SET_VENDOR_EX_IE    "SET_VENDOR_EX_IE"
-#define CMD_SET_AP_WPS_P2P_IE   "SET_AP_WPS_P2P_IE"
-#define CMD_SET_TESTMODE        "SET_TESTMODE"
-
-
-struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
-struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
-extern int reg_regdb_size;
-
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-extern u8_l vendor_extension_data[256];
-extern u8_l vendor_extension_len;
-
-void set_vendor_extension_ie(char *command){
-
-	char databyte[3]={0x00, 0x00, 0x00};
-	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
-	int command_index = skip;
-	int data_index = 0;
-
-	memset(vendor_extension_data, 0, 256);
-	vendor_extension_len = 0;
-	memcpy(databyte, command + command_index, 2);
-	vendor_extension_len = command_strtoul(databyte, NULL, 16);
-	AICWFDBG(LOGINFO, "%s len:%d \r\n", __func__, vendor_extension_len);
-
-	//parser command and save data in vendor_extension_data
-	for(data_index = 0;data_index < vendor_extension_len; data_index++){
-		command_index = command_index + 3;
-		memcpy(databyte, command + command_index, 2);
-		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
-	}
-
-}
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-
-int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
-{
-#define PRIVATE_COMMAND_MAX_LEN 8192
-#define PRIVATE_COMMAND_DEF_LEN 4096
-
-	struct rwnx_vif *vif = netdev_priv(net);
-    int ret = 0;
-    char *command = NULL;
-    int bytes_written = 0;
-    android_wifi_priv_cmd priv_cmd;
-    int buf_size = 0;
-	int skip = 0;
-	char *country = NULL;
-	struct ieee80211_regdomain *regdomain;
-	//int index = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    ///todo: add our lock
-    //net_os_wake_lock(net);
-
-
-/*    if (!capable(CAP_NET_ADMIN)) {
-        ret = -EPERM;
-        goto exit;
-    }*/
-    if (!ifr->ifr_data) {
-        ret = -EINVAL;
-        goto exit;
-    }
-
-#ifdef CONFIG_COMPAT
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
-    if (in_compat_syscall())
-#else
-    if (is_compat_task())
-#endif
-    {
-        compat_android_wifi_priv_cmd compat_priv_cmd;
-        if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-        priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
-        priv_cmd.used_len = compat_priv_cmd.used_len;
-        priv_cmd.total_len = compat_priv_cmd.total_len;
-    } else
-#endif /* CONFIG_COMPAT */
-    {
-        if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-    }
-    if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
-        AICWFDBG(LOGERROR, "%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
-        ret = -EINVAL;
-        goto exit;
-    }
-
-    buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
-    command = kmalloc((buf_size + 1), GFP_KERNEL);
-
-    if (!command)
-    {
-        AICWFDBG(LOGERROR, "%s: failed to allocate memory\n", __FUNCTION__);
-        ret = -ENOMEM;
-        goto exit;
-    }
-    if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
-        ret = -EFAULT;
-        goto exit;
-    }
-    command[priv_cmd.total_len] = '\0';
-
-    /* outputs */
-    AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
-    AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
-    AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
-
-
-#if 1//Handle Android command
-	if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
-		skip = strlen(CMD_SET_COUNTRY) + 1;
-		country = command + skip;
-		if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
-			AICWFDBG(LOGERROR, "%s: invalid country code\n", __func__);
-			ret = -EINVAL;
-			goto exit;
-		}
-#if 0
-		for(index = 0; index < reg_regdb_size; index++){
-			regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
-			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-				AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
-			}else{
-				AICWFDBG(LOGINFO, "regulatory_set_wiphy_regd ok \r\n");
-			}
-		}
-#endif
-		AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
-		regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-		if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-			AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
-		}
-#else
-		wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
-#endif
-	}
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-	else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
-		set_vendor_extension_ie(command);
-	}
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-	else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
-		ret = 0;
-		goto exit;
-	}else if(!strncasecmp(command, CMD_SET_TESTMODE, strlen(CMD_SET_TESTMODE))){
-    	if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
-            if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC)){
-                set_testmode(!testmode);
-	            rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
-            }
-        }
-        ret = 0;
-		goto exit;
-    }
-#endif//Handle Android command
-
-
-    bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
-    if (bytes_written >= 0) {
-        if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
-            command[0] = '\0';
-        }
-        if (bytes_written >= priv_cmd.total_len) {
-            AICWFDBG(LOGINFO, "%s: err. bytes_written:%d >= buf_size:%d \n",
-                __FUNCTION__, bytes_written, buf_size);
-            goto exit;
-        }
-        bytes_written++;
-        priv_cmd.used_len = bytes_written;
-        if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
-            AICWFDBG(LOGERROR, "%s: failed to copy data to user buffer\n", __FUNCTION__);
-            ret = -EFAULT;
-        }
-    }
-    else {
-        /* Propagate the error */
-        ret = bytes_written;
-    }
-
-exit:
-    ///todo: add our unlock
-    //net_os_wake_unlock(net);
-    kfree(command);
-    return ret;
-}
-
-#define IOCTL_HOSTAPD   (SIOCIWFIRSTPRIV+28)
-#define IOCTL_WPAS      (SIOCIWFIRSTPRIV+30)
+#define IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
+#define IOCTL_WPAS (SIOCIWFIRSTPRIV + 30)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
-static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, void __user *data, int cmd)
+static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req,
+			 void __user *data, int cmd)
 #else
 static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, int cmd)
 #endif
 {
-    int ret = 0;
-    ///TODO: add ioctl command handler later
-    switch(cmd)
-    {
-        case IOCTL_HOSTAPD:
-            AICWFDBG(LOGINFO, "IOCTL_HOSTAPD\n");
-            break;
-        case IOCTL_WPAS:
-            AICWFDBG(LOGINFO, "IOCTL_WPAS\n");
-            break;
-        case SIOCDEVPRIVATE:
-            AICWFDBG(LOGINFO, "IOCTL SIOCDEVPRIVATE\n");
-            break;
-        case (SIOCDEVPRIVATE+1):
-            AICWFDBG(LOGINFO, "IOCTL PRIVATE\n");
-            android_priv_cmd(net, req, cmd);
-	    break;
-        default:
-            ret = -EOPNOTSUPP;
-    }
-    return ret;
+	int ret = 0;
+	///TODO: add ioctl command handler later
+	switch (cmd) {
+	case IOCTL_HOSTAPD:
+		AICWFDBG(LOGINFO, "IOCTL_HOSTAPD\n");
+		break;
+	case IOCTL_WPAS:
+		AICWFDBG(LOGINFO, "IOCTL_WPAS\n");
+		break;
+	case SIOCDEVPRIVATE:
+		AICWFDBG(LOGINFO, "IOCTL SIOCDEVPRIVATE\n");
+		break;
+	case (SIOCDEVPRIVATE + 1):
+		AICWFDBG(LOGINFO, "IOCTL PRIVATE\n");
+		ret = android_priv_cmd(net, req, cmd);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+	}
+	return ret;
 }
 
 /**
@@ -2918,9 +1735,9 @@ static int rwnx_do_ioctl(struct net_device *net, struct ifreq *req, int cmd)
  */
 static struct net_device_stats *rwnx_get_stats(struct net_device *dev)
 {
-    struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_vif *vif = netdev_priv(dev);
 
-    return &vif->net_stats;
+	return &vif->net_stats;
 }
 
 /**
@@ -2930,10 +1747,10 @@ static struct net_device_stats *rwnx_get_stats(struct net_device *dev)
  *	transmit queues.
  */
 u16 rwnx_select_queue(struct net_device *dev, struct sk_buff *skb,
-                      struct net_device *sb_dev)
+		      struct net_device *sb_dev)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    return rwnx_select_txq(rwnx_vif, skb);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	return rwnx_select_txq(rwnx_vif, skb);
 }
 
 /**
@@ -2944,221 +1761,231 @@ u16 rwnx_select_queue(struct net_device *dev, struct sk_buff *skb,
  */
 static int rwnx_set_mac_address(struct net_device *dev, void *addr)
 {
-    struct sockaddr *sa = addr;
-    int ret;
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct sockaddr *sa = addr;
+	int ret;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 	printk("%s enter \r\n", __func__);
 
-    ret = eth_mac_addr(dev, sa);
-    memcpy(rwnx_vif->wdev.address, dev->dev_addr, 6);
+	ret = eth_mac_addr(dev, sa);
+	memcpy(rwnx_vif->wdev.address, dev->dev_addr, 6);
 
-    return ret;
+	return ret;
 }
 
 static const struct net_device_ops rwnx_netdev_ops = {
-    .ndo_open               = rwnx_open,
-    .ndo_stop               = rwnx_close,
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
-    .ndo_siocdevprivate     = rwnx_do_ioctl,
-    #else
-    .ndo_do_ioctl           = rwnx_do_ioctl,
-    #endif
-    .ndo_start_xmit         = rwnx_start_xmit,
-    .ndo_get_stats          = rwnx_get_stats,
+	.ndo_open = rwnx_open,
+	.ndo_stop = rwnx_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	.ndo_siocdevprivate = rwnx_do_ioctl,
+#else
+	.ndo_do_ioctl = rwnx_do_ioctl,
+#endif
+	.ndo_start_xmit = rwnx_start_xmit,
+	.ndo_get_stats = rwnx_get_stats,
 #ifndef CONFIG_ONE_TXQ
-    .ndo_select_queue       = rwnx_select_queue,
+	.ndo_select_queue = rwnx_select_queue,
 #endif
 #ifdef CONFIG_SUPPORT_REALTIME_CHANGE_MAC
-    .ndo_set_mac_address    = rwnx_set_mac_address
+	.ndo_set_mac_address = rwnx_set_mac_address
 #endif
-//    .ndo_set_features       = rwnx_set_features,
-//    .ndo_set_rx_mode        = rwnx_set_multicast_list,
+	//    .ndo_set_features       = rwnx_set_features,
+	//    .ndo_set_rx_mode        = rwnx_set_multicast_list,
 };
 
 static const struct net_device_ops rwnx_netdev_monitor_ops = {
-    .ndo_open               = rwnx_open,
-    .ndo_stop               = rwnx_close,
-    #ifdef CONFIG_RWNX_MON_XMIT
-    .ndo_start_xmit         = rwnx_start_monitor_if_xmit,
-    .ndo_select_queue       = rwnx_select_queue,
-    #endif
-    .ndo_get_stats          = rwnx_get_stats,
-    .ndo_set_mac_address    = rwnx_set_mac_address,
+	.ndo_open = rwnx_open,
+	.ndo_stop = rwnx_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	.ndo_siocdevprivate = rwnx_do_ioctl,
+#else
+	.ndo_do_ioctl = rwnx_do_ioctl,
+#endif
+#ifdef CONFIG_RWNX_MON_XMIT
+	.ndo_start_xmit = rwnx_start_monitor_if_xmit,
+	.ndo_select_queue = rwnx_select_queue,
+#endif
+	.ndo_get_stats = rwnx_get_stats,
+	.ndo_set_mac_address = rwnx_set_mac_address,
 };
 
 static void rwnx_netdev_setup(struct net_device *dev)
 {
-    ether_setup(dev);
-    dev->priv_flags &= ~IFF_TX_SKB_SHARING;
-    dev->netdev_ops = &rwnx_netdev_ops;
-#if LINUX_VERSION_CODE <  KERNEL_VERSION(4, 12, 0)
-    dev->destructor = free_netdev;
+	ether_setup(dev);
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	dev->netdev_ops = &rwnx_netdev_ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+	dev->destructor = free_netdev;
 #else
-    dev->needs_free_netdev = true;
+	dev->needs_free_netdev = true;
 #endif
-    dev->watchdog_timeo = RWNX_TX_LIFETIME_MS;
+	dev->watchdog_timeo = RWNX_TX_LIFETIME_MS;
 
-    dev->needed_headroom = sizeof(struct rwnx_txhdr) + RWNX_SWTXHDR_ALIGN_SZ - 14;
+	dev->needed_headroom =
+		sizeof(struct rwnx_txhdr) + RWNX_SWTXHDR_ALIGN_SZ - 14;
 #ifdef CONFIG_RWNX_AMSDUS_TX
-    dev->needed_headroom = max(dev->needed_headroom,
-                               (unsigned short)(sizeof(struct rwnx_amsdu_txhdr)
-                                                + sizeof(struct ethhdr) + 4
-                                                + sizeof(rfc1042_header) + 2));
+	dev->needed_headroom =
+		max(dev->needed_headroom,
+		    (unsigned short)(sizeof(struct rwnx_amsdu_txhdr) +
+				     sizeof(struct ethhdr) + 4 +
+				     sizeof(rfc1042_header) + 2));
 #endif /* CONFIG_RWNX_AMSDUS_TX */
 
-    dev->hw_features = 0;
+	dev->hw_features = 0;
 }
 
 #ifndef CONFIG_USE_WIRELESS_EXT
 #ifdef CONFIG_WIRELESS_EXT
-    #include <net/iw_handler.h>
-    struct iw_handler_def aic_handlers_def;
+#include <net/iw_handler.h>
+struct iw_handler_def aic_handlers_def;
 #endif
 #endif
 
-
 /*********************************************************************
  * Cfg80211 callbacks (and helper)
  *********************************************************************/
 static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
-                                               const char *name,
-                                               unsigned char name_assign_type,
-                                               enum nl80211_iftype type,
-                                               struct vif_params *params)
+					   const char *name,
+					   unsigned char name_assign_type,
+					   enum nl80211_iftype type,
+					   struct vif_params *params)
 {
-    struct net_device *ndev;
-    struct rwnx_vif *vif;
-    int min_idx, max_idx;
-    int vif_idx = -1;
-    int i;
-    int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
-
-    if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
-		((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
-		    nx_nb_ndev_txq = NX_NB_NDEV_TXQ_FOR_OLD_IC;
-    }
+	struct net_device *ndev;
+	struct rwnx_vif *vif;
+	int min_idx, max_idx;
+	int vif_idx = -1;
+	int i;
+	int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
+
+	if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
+	    ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) &&
+	     chip_id < 3)) {
+		nx_nb_ndev_txq = NX_NB_NDEV_TXQ_FOR_OLD_IC;
+	}
 
-	AICWFDBG(LOGINFO, "rwnx_interface_add: %s, %d, %d\r\n", name, type, NL80211_IFTYPE_P2P_DEVICE);
-    // Look for an available VIF
-    if (type == NL80211_IFTYPE_AP_VLAN) {
-        min_idx = NX_VIRT_DEV_MAX;
-        max_idx = NX_VIRT_DEV_MAX + NX_REMOTE_STA_MAX;
-    } else {
-        min_idx = 0;
-        max_idx = NX_VIRT_DEV_MAX;
-    }
+	AICWFDBG(LOGINFO, "rwnx_interface_add: %s, %d, %d\r\n", name, type,
+		 NL80211_IFTYPE_P2P_DEVICE);
+	// Look for an available VIF
+	if (type == NL80211_IFTYPE_AP_VLAN) {
+		min_idx = NX_VIRT_DEV_MAX;
+		max_idx = NX_VIRT_DEV_MAX + NX_REMOTE_STA_MAX;
+	} else {
+		min_idx = 0;
+		max_idx = NX_VIRT_DEV_MAX;
+	}
 
-    for (i = min_idx; i < max_idx; i++) {
-        if ((rwnx_hw->avail_idx_map) & BIT(i)) {
-            vif_idx = i;
-            break;
-        }
-    }
-    if (vif_idx < 0)
-        return NULL;
-
-    #ifndef CONFIG_RWNX_MON_DATA
-    list_for_each_entry(vif, &rwnx_hw->vifs, list) {
-        // Check if monitor interface already exists or type is monitor
-        if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MONITOR) ||
-           (type == NL80211_IFTYPE_MONITOR)) {
-            wiphy_err(rwnx_hw->wiphy,
-                    "Monitor+Data interface support (MON_DATA) disabled\n");
-            return NULL;
-        }
-    }
-    #endif
+	for (i = min_idx; i < max_idx; i++) {
+		if ((rwnx_hw->avail_idx_map) & BIT(i)) {
+			vif_idx = i;
+			break;
+		}
+	}
+	if (vif_idx < 0)
+		return NULL;
+
+#ifndef CONFIG_RWNX_MON_DATA
+	list_for_each_entry(vif, &rwnx_hw->vifs, list) {
+		// Check if monitor interface already exists or type is monitor
+		if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MONITOR) ||
+		    (type == NL80211_IFTYPE_MONITOR)) {
+			wiphy_err(
+				rwnx_hw->wiphy,
+				"Monitor+Data interface support (MON_DATA) disabled\n");
+			return NULL;
+		}
+	}
+#endif
 
 #ifndef CONFIG_ONE_TXQ
-    ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
-                                rwnx_netdev_setup, nx_nb_ndev_txq, 1);
+	ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
+				rwnx_netdev_setup, nx_nb_ndev_txq, 1);
 #else
-    ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
-                                    rwnx_netdev_setup, 1, 1);
-#endif
-
-    if (!ndev)
-        return NULL;
-
-    vif = netdev_priv(ndev);
-    vif->key_has_add = 0;
-    ndev->ieee80211_ptr = &vif->wdev;
-    vif->wdev.wiphy = rwnx_hw->wiphy;
-    vif->rwnx_hw = rwnx_hw;
-    vif->ndev = ndev;
-    vif->drv_vif_index = vif_idx;
-    SET_NETDEV_DEV(ndev, wiphy_dev(vif->wdev.wiphy));
-    vif->wdev.netdev = ndev;
-    vif->wdev.iftype = type;
-    vif->up = false;
-    vif->ch_index = RWNX_CH_NOT_SET;
-    memset(&vif->net_stats, 0, sizeof(vif->net_stats));
-    vif->is_p2p_vif = 0;
+	ndev = alloc_netdev_mqs(sizeof(*vif), name, name_assign_type,
+				rwnx_netdev_setup, 1, 1);
+#endif
+
+	if (!ndev)
+		return NULL;
+
+	vif = netdev_priv(ndev);
+	vif->key_has_add = 0;
+	ndev->ieee80211_ptr = &vif->wdev;
+	vif->wdev.wiphy = rwnx_hw->wiphy;
+	vif->rwnx_hw = rwnx_hw;
+	vif->ndev = ndev;
+	vif->drv_vif_index = vif_idx;
+	SET_NETDEV_DEV(ndev, wiphy_dev(vif->wdev.wiphy));
+	vif->wdev.netdev = ndev;
+	vif->wdev.iftype = type;
+	vif->up = false;
+	vif->ch_index = RWNX_CH_NOT_SET;
+	memset(&vif->net_stats, 0, sizeof(vif->net_stats));
+	vif->is_p2p_vif = 0;
 #ifdef CONFIG_BR_SUPPORT
-    spin_lock_init(&vif->br_ext_lock);
+	spin_lock_init(&vif->br_ext_lock);
 #endif /* CONFIG_BR_SUPPORT */
 
-    switch (type) {
-    case NL80211_IFTYPE_STATION:
-        vif->sta.ap = NULL;
-        vif->sta.tdls_sta = NULL;
-        vif->sta.external_auth = false;
-        break;
-    case NL80211_IFTYPE_P2P_CLIENT:
-        vif->sta.ap = NULL;
-        vif->sta.tdls_sta = NULL;
-        vif->sta.external_auth = false;
-        vif->is_p2p_vif = 1;
-        break;
-    case NL80211_IFTYPE_MESH_POINT:
-        INIT_LIST_HEAD(&vif->ap.mpath_list);
-        INIT_LIST_HEAD(&vif->ap.proxy_list);
-        vif->ap.create_path = false;
-        vif->ap.generation = 0;
-        vif->ap.mesh_pm = NL80211_MESH_POWER_ACTIVE;
-        vif->ap.next_mesh_pm = NL80211_MESH_POWER_ACTIVE;
-        // no break
-    case NL80211_IFTYPE_AP:
-        INIT_LIST_HEAD(&vif->ap.sta_list);
-        memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
-        break;
-    case NL80211_IFTYPE_P2P_GO:
-        INIT_LIST_HEAD(&vif->ap.sta_list);
-        memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
-        vif->is_p2p_vif = 1;
-        break;
-    case NL80211_IFTYPE_AP_VLAN:
-    {
-        struct rwnx_vif *master_vif;
-        bool found = false;
-        list_for_each_entry(master_vif, &rwnx_hw->vifs, list) {
-            if ((RWNX_VIF_TYPE(master_vif) == NL80211_IFTYPE_AP) &&
-                !(!memcmp(master_vif->ndev->dev_addr, params->macaddr,
-                           ETH_ALEN))) {
-                 found=true;
-                 break;
-            }
-        }
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		vif->sta.ap = NULL;
+		vif->sta.tdls_sta = NULL;
+		vif->sta.external_auth = false;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		vif->sta.ap = NULL;
+		vif->sta.tdls_sta = NULL;
+		vif->sta.external_auth = false;
+		vif->is_p2p_vif = 1;
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		INIT_LIST_HEAD(&vif->ap.mpath_list);
+		INIT_LIST_HEAD(&vif->ap.proxy_list);
+		vif->ap.create_path = false;
+		vif->ap.generation = 0;
+		vif->ap.mesh_pm = NL80211_MESH_POWER_ACTIVE;
+		vif->ap.next_mesh_pm = NL80211_MESH_POWER_ACTIVE;
+		// no break
+	case NL80211_IFTYPE_AP:
+		INIT_LIST_HEAD(&vif->ap.sta_list);
+		memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		INIT_LIST_HEAD(&vif->ap.sta_list);
+		memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
+		vif->is_p2p_vif = 1;
+		break;
+	case NL80211_IFTYPE_AP_VLAN: {
+		struct rwnx_vif *master_vif;
+		bool found = false;
+		list_for_each_entry(master_vif, &rwnx_hw->vifs, list) {
+			if ((RWNX_VIF_TYPE(master_vif) == NL80211_IFTYPE_AP) &&
+			    !(!memcmp(master_vif->ndev->dev_addr,
+				      params->macaddr, ETH_ALEN))) {
+				found = true;
+				break;
+			}
+		}
 
-        if (!found)
-            goto err;
+		if (!found)
+			goto err;
 
-         vif->ap_vlan.master = master_vif;
-         vif->ap_vlan.sta_4a = NULL;
-         break;
-    }
-    case NL80211_IFTYPE_MONITOR:
-        ndev->type = ARPHRD_IEEE80211_RADIOTAP;
-        ndev->netdev_ops = &rwnx_netdev_monitor_ops;
-        break;
-    default:
-        break;
-    }
+		vif->ap_vlan.master = master_vif;
+		vif->ap_vlan.sta_4a = NULL;
+		break;
+	}
+	case NL80211_IFTYPE_MONITOR:
+		ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+		ndev->netdev_ops = &rwnx_netdev_monitor_ops;
+		break;
+	default:
+		break;
+	}
 
 	if (type == NL80211_IFTYPE_AP_VLAN) {
-		memcpy((void *)ndev->dev_addr, (const void *)params->macaddr, ETH_ALEN);
-		memcpy((void *)vif->wdev.address, (const void *)params->macaddr, ETH_ALEN);
+		memcpy((void *)ndev->dev_addr, (const void *)params->macaddr,
+		       ETH_ALEN);
+		memcpy((void *)vif->wdev.address, (const void *)params->macaddr,
+		       ETH_ALEN);
 	} else {
 #if LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0)
 		unsigned char mac_addr[6];
@@ -3169,204 +1996,208 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
 		memcpy(vif->wdev.address, mac_addr, ETH_ALEN);
 #else
 		memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-		//ndev->dev_addr[5] ^= vif_idx;
-        vif->wdev.address[5] ^= vif_idx;
+		ndev->dev_addr[5] ^= vif_idx;
 		memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
 #endif
 	}
 
+	AICWFDBG(LOGINFO, "interface add:%x %x %x %x %x %x\n",
+		 vif->wdev.address[0], vif->wdev.address[1],
+		 vif->wdev.address[2], vif->wdev.address[3],
+		 vif->wdev.address[4], vif->wdev.address[5]);
 
-	AICWFDBG(LOGINFO, "interface add:%x %x %x %x %x %x\n", vif->wdev.address[0], vif->wdev.address[1],
-        vif->wdev.address[2], vif->wdev.address[3], vif->wdev.address[4], vif->wdev.address[5]);
-
-    if (params) {
-        vif->use_4addr = params->use_4addr;
-        ndev->ieee80211_ptr->use_4addr = params->use_4addr;
-    } else
-        vif->use_4addr = false;
+	if (params) {
+		vif->use_4addr = params->use_4addr;
+		ndev->ieee80211_ptr->use_4addr = params->use_4addr;
+	} else
+		vif->use_4addr = false;
 
 #ifdef CONFIG_USE_WIRELESS_EXT
 	aicwf_set_wireless_ext(ndev, rwnx_hw);
 #else
 #ifdef CONFIG_WIRELESS_EXT
-    memset(&aic_handlers_def, 0,sizeof(struct iw_handler_def));
-    ndev->wireless_handlers = (struct iw_handler_def *)&aic_handlers_def;
+	memset(&aic_handlers_def, 0, sizeof(struct iw_handler_def));
+	ndev->wireless_handlers = (struct iw_handler_def *)&aic_handlers_def;
 #endif
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
-        if (cfg80211_register_netdevice(ndev))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	if (cfg80211_register_netdevice(ndev))
 #else
-        if (register_netdevice(ndev))
+	if (register_netdevice(ndev))
 #endif
-            goto err;
+		goto err;
 
+	spin_lock_bh(&rwnx_hw->cb_lock);
+	list_add_tail(&vif->list, &rwnx_hw->vifs);
+	spin_unlock_bh(&rwnx_hw->cb_lock);
+	rwnx_hw->avail_idx_map &= ~BIT(vif_idx);
 
-    spin_lock_bh(&rwnx_hw->cb_lock);
-    list_add_tail(&vif->list, &rwnx_hw->vifs);
-    spin_unlock_bh(&rwnx_hw->cb_lock);
-    rwnx_hw->avail_idx_map &= ~BIT(vif_idx);
-
-    return vif;
+	return vif;
 
 err:
-    free_netdev(ndev);
-    return NULL;
+	free_netdev(ndev);
+	return NULL;
 }
 
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 void aicwf_p2p_alive_timeout(ulong data)
 #else
 void aicwf_p2p_alive_timeout(struct timer_list *t)
 #endif
 {
-    struct rwnx_hw *rwnx_hw;
-    struct rwnx_vif *rwnx_vif;
-    struct rwnx_vif *rwnx_vif1, *tmp;
-    u8_l p2p = 0;
-    #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-    rwnx_vif = (struct rwnx_vif *)data;
-    rwnx_hw = rwnx_vif->rwnx_hw;
-    #else
-    rwnx_hw = from_timer(rwnx_hw, t, p2p_alive_timer);
-    rwnx_vif = rwnx_hw->p2p_dev_vif;
-    #endif
+	struct rwnx_hw *rwnx_hw;
+	struct rwnx_vif *rwnx_vif;
+	struct rwnx_vif *rwnx_vif1, *tmp;
+	u8_l p2p = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	rwnx_vif = (struct rwnx_vif *)data;
+	rwnx_hw = rwnx_vif->rwnx_hw;
+#else
+	rwnx_hw = from_timer(rwnx_hw, t, p2p_alive_timer);
+	rwnx_vif = rwnx_hw->p2p_dev_vif;
+#endif
 
 	//printk("%s enter %d \r\n", __func__, atomic_read(&rwnx_hw->p2p_alive_timer_count));
 
 #if 1 //AIDEN workaround
-	if(atomic_read(&rwnx_hw->p2p_alive_timer_count) > 2){
-		p2p_working = 0;
-	}
-#endif
-
-    list_for_each_entry_safe(rwnx_vif1, tmp, &rwnx_hw->vifs, list) {
-        if ((rwnx_hw->avail_idx_map & BIT(rwnx_vif1->drv_vif_index)) == 0) {
-            switch(RWNX_VIF_TYPE(rwnx_vif1)) {
-            case NL80211_IFTYPE_P2P_CLIENT:
-            case NL80211_IFTYPE_P2P_GO:
-                rwnx_hw->is_p2p_alive = 1;
-                p2p = 1;
-                break;
-            default:
-                break;
-            }
-       }
-    }
+	if (atomic_read(&rwnx_hw->p2p_alive_timer_count) > 2) {
+		rwnx_hw->p2p_working = false;
+	}
+#endif
 
-    if (p2p){
-        atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
-    }else{
-        atomic_inc(&rwnx_hw->p2p_alive_timer_count);
-    }
+	list_for_each_entry_safe(rwnx_vif1, tmp, &rwnx_hw->vifs, list) {
+		if ((rwnx_hw->avail_idx_map & BIT(rwnx_vif1->drv_vif_index)) ==
+		    0) {
+			switch (RWNX_VIF_TYPE(rwnx_vif1)) {
+			case NL80211_IFTYPE_P2P_CLIENT:
+			case NL80211_IFTYPE_P2P_GO:
+				rwnx_hw->is_p2p_alive = 1;
+				p2p = 1;
+				break;
+			default:
+				break;
+			}
+		}
+	}
 
-    if (atomic_read(&rwnx_hw->p2p_alive_timer_count) < P2P_ALIVE_TIME_COUNT) {
-        mod_timer(&rwnx_hw->p2p_alive_timer,
-            jiffies + msecs_to_jiffies(P2P_ALIVE_TIME_MS));
-        return;
-    } else
-        atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+	if (p2p) {
+		atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+	} else {
+		atomic_inc(&rwnx_hw->p2p_alive_timer_count);
+	}
 
-    rwnx_hw->is_p2p_alive = 0;
-    rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index, true);
+	if (atomic_read(&rwnx_hw->p2p_alive_timer_count) <
+	    P2P_ALIVE_TIME_COUNT) {
+		mod_timer(&rwnx_hw->p2p_alive_timer,
+			  jiffies + msecs_to_jiffies(P2P_ALIVE_TIME_MS));
+		return;
+	} else
+		atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
 
-     /* Ensure that we won't process disconnect ind */
-     spin_lock_bh(&rwnx_hw->cb_lock);
+	rwnx_hw->is_p2p_alive = 0;
+	rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index, true);
 
-     rwnx_vif->up = false;
-     rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
-     AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
-     rwnx_hw->vif_started--;
-     spin_unlock_bh(&rwnx_hw->cb_lock);
-}
+	/* Ensure that we won't process disconnect ind */
+	spin_lock_bh(&rwnx_hw->cb_lock);
 
+	rwnx_vif->up = false;
+	rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__,
+		 rwnx_vif->vif_index);
+	rwnx_hw->vif_started--;
+	spin_unlock_bh(&rwnx_hw->cb_lock);
+}
 
 /*********************************************************************
  * Cfg80211 callbacks (and helper)
  *********************************************************************/
-static struct wireless_dev *rwnx_virtual_interface_add(struct rwnx_hw *rwnx_hw,
-                                               const char *name,
-                                               unsigned char name_assign_type,
-                                               enum nl80211_iftype type,
-                                               struct vif_params *params)
+static struct wireless_dev *
+rwnx_virtual_interface_add(struct rwnx_hw *rwnx_hw, const char *name,
+			   unsigned char name_assign_type,
+			   enum nl80211_iftype type, struct vif_params *params)
 {
-    struct wireless_dev *wdev = NULL;
-    struct rwnx_vif *vif;
-    int min_idx, max_idx;
-    int vif_idx = -1;
-    int i;
+	struct wireless_dev *wdev = NULL;
+	struct rwnx_vif *vif;
+	int min_idx, max_idx;
+	int vif_idx = -1;
+	int i;
 
-    AICWFDBG(LOGINFO, "rwnx_virtual_interface_add: %d, %s\n", type, name);
+	AICWFDBG(LOGINFO, "rwnx_virtual_interface_add: %d, %s\n", type, name);
 
-    if (type == NL80211_IFTYPE_AP_VLAN) {
-        min_idx = NX_VIRT_DEV_MAX;
-        max_idx = NX_VIRT_DEV_MAX + NX_REMOTE_STA_MAX;
-    } else {
-        min_idx = 0;
-        max_idx = NX_VIRT_DEV_MAX;
-    }
+	if (type == NL80211_IFTYPE_AP_VLAN) {
+		min_idx = NX_VIRT_DEV_MAX;
+		max_idx = NX_VIRT_DEV_MAX + NX_REMOTE_STA_MAX;
+	} else {
+		min_idx = 0;
+		max_idx = NX_VIRT_DEV_MAX;
+	}
 
-    for (i = min_idx; i < max_idx; i++) {
-        if ((rwnx_hw->avail_idx_map) & BIT(i)) {
-            vif_idx = i;
-            break;
-        }
-    }
+	for (i = min_idx; i < max_idx; i++) {
+		if ((rwnx_hw->avail_idx_map) & BIT(i)) {
+			vif_idx = i;
+			break;
+		}
+	}
 
-    if (vif_idx < 0) {
-        AICWFDBG(LOGERROR, "virtual_interface_add %s fail\n", name);
-        return NULL;
-    }
+	if (vif_idx < 0) {
+		AICWFDBG(LOGERROR, "virtual_interface_add %s fail\n", name);
+		return NULL;
+	}
 
-    vif = kzalloc(sizeof(struct rwnx_vif), GFP_KERNEL);
-    if (unlikely(!vif)) {
-        AICWFDBG(LOGERROR, "Could not allocate wireless device\n");
-        return NULL;
-    }
-    wdev = &vif->wdev;
-    wdev->wiphy = rwnx_hw->wiphy;
-    wdev->iftype = type;
-
-    AICWFDBG(LOGINFO, "rwnx_virtual_interface_add, ifname=%s, wdev=%p, vif_idx=%d\n", name, wdev, vif_idx);
-
-    #ifndef CONFIG_USE_P2P0
-    vif->is_p2p_vif = 1;
-    vif->rwnx_hw = rwnx_hw;
-    vif->vif_index = vif_idx;
-    vif->wdev.wiphy = rwnx_hw->wiphy;
-    vif->drv_vif_index = vif_idx;
-    vif->up = false;
-    vif->ch_index = RWNX_CH_NOT_SET;
-    memset(&vif->net_stats, 0, sizeof(vif->net_stats));
-    vif->use_4addr = false;
-
-    spin_lock_bh(&rwnx_hw->cb_lock);
-    list_add_tail(&vif->list, &rwnx_hw->vifs);
-    spin_unlock_bh(&rwnx_hw->cb_lock);
-
-    if (rwnx_hw->is_p2p_alive == 0) {
-        #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-        init_timer(&rwnx_hw->p2p_alive_timer);
-        rwnx_hw->p2p_alive_timer.data = (unsigned long)vif;
-        rwnx_hw->p2p_alive_timer.function = aicwf_p2p_alive_timeout;
-        #else
-        timer_setup(&rwnx_hw->p2p_alive_timer, aicwf_p2p_alive_timeout, 0);
-        #endif
-        rwnx_hw->is_p2p_alive = 0;
-        rwnx_hw->is_p2p_connected = 0;
-        rwnx_hw->p2p_dev_vif = vif;
-        atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
-    }
-    #endif
-    rwnx_hw->avail_idx_map &= ~BIT(vif_idx);
+	vif = kzalloc(sizeof(struct rwnx_vif), GFP_KERNEL);
+	if (unlikely(!vif)) {
+		AICWFDBG(LOGERROR, "Could not allocate wireless device\n");
+		return NULL;
+	}
+	wdev = &vif->wdev;
+	wdev->wiphy = rwnx_hw->wiphy;
+	wdev->iftype = type;
+
+	AICWFDBG(LOGINFO,
+		 "rwnx_virtual_interface_add, ifname=%s, wdev=%p, vif_idx=%d\n",
+		 name, wdev, vif_idx);
 
-    memcpy(vif->wdev.address, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-    vif->wdev.address[5] ^= vif_idx;
-    AICWFDBG(LOGERROR, "p2p dev addr=%x %x %x %x %x %x\n", vif->wdev.address[0], vif->wdev.address[1], \
-        vif->wdev.address[2], vif->wdev.address[3], vif->wdev.address[4], vif->wdev.address[5]);
+#ifndef CONFIG_USE_P2P0
+	vif->is_p2p_vif = 1;
+	vif->rwnx_hw = rwnx_hw;
+	vif->vif_index = vif_idx;
+	vif->wdev.wiphy = rwnx_hw->wiphy;
+	vif->drv_vif_index = vif_idx;
+	vif->up = false;
+	vif->ch_index = RWNX_CH_NOT_SET;
+	memset(&vif->net_stats, 0, sizeof(vif->net_stats));
+	vif->use_4addr = false;
 
-    return wdev;
+	spin_lock_bh(&rwnx_hw->cb_lock);
+	list_add_tail(&vif->list, &rwnx_hw->vifs);
+	spin_unlock_bh(&rwnx_hw->cb_lock);
+
+	if (rwnx_hw->is_p2p_alive == 0) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+		init_timer(&rwnx_hw->p2p_alive_timer);
+		rwnx_hw->p2p_alive_timer.data = (unsigned long)vif;
+		rwnx_hw->p2p_alive_timer.function = aicwf_p2p_alive_timeout;
+#else
+		timer_setup(&rwnx_hw->p2p_alive_timer, aicwf_p2p_alive_timeout,
+			    0);
+#endif
+		rwnx_hw->is_p2p_alive = 0;
+		rwnx_hw->is_p2p_connected = 0;
+		rwnx_hw->p2p_dev_vif = vif;
+		atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+	}
+#endif
+	rwnx_hw->avail_idx_map &= ~BIT(vif_idx);
+
+	memcpy(vif->wdev.address, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+	vif->wdev.address[5] ^= vif_idx;
+	AICWFDBG(LOGERROR, "p2p dev addr=%x %x %x %x %x %x\n",
+		 vif->wdev.address[0], vif->wdev.address[1],
+		 vif->wdev.address[2], vif->wdev.address[3],
+		 vif->wdev.address[4], vif->wdev.address[5]);
+
+	return wdev;
 }
 
 /*
@@ -3375,51 +2206,65 @@ static struct wireless_dev *rwnx_virtual_interface_add(struct rwnx_hw *rwnx_hw,
  */
 
 static struct rwnx_sta *rwnx_retrieve_sta(struct rwnx_hw *rwnx_hw,
-                                          struct rwnx_vif *rwnx_vif, u8 *addr,
-                                          __le16 fc, bool ap)
+					  struct rwnx_vif *rwnx_vif, u8 *addr,
+					  __le16 fc, bool ap)
 {
-    if (ap) {
-        /* only deauth, disassoc and action are bufferable MMPDUs */
-        bool bufferable = ieee80211_is_deauth(fc) ||
-                          ieee80211_is_disassoc(fc) ||
-                          ieee80211_is_action(fc);
-
-        /* Check if the packet is bufferable or not */
-        if (bufferable)
-        {
-            /* Check if address is a broadcast or a multicast address */
-            if (is_broadcast_ether_addr(addr) || is_multicast_ether_addr(addr)) {
-                /* Returned STA pointer */
-                struct rwnx_sta *rwnx_sta = &rwnx_hw->sta_table[rwnx_vif->ap.bcmc_index];
-
-                if (rwnx_sta->valid)
-                    return rwnx_sta;
-            } else {
-                /* Returned STA pointer */
-                struct rwnx_sta *rwnx_sta;
-
-                /* Go through list of STAs linked with the provided VIF */
+	if (ap) {
+		/* only deauth, disassoc and action are bufferable MMPDUs */
+		bool bufferable = ieee80211_is_deauth(fc) ||
+				  ieee80211_is_disassoc(fc) ||
+				  ieee80211_is_action(fc);
+
+		/* Check if the packet is bufferable or not */
+		if (bufferable) {
+			/* Check if address is a broadcast or a multicast address */
+			if (is_broadcast_ether_addr(addr) ||
+			    is_multicast_ether_addr(addr)) {
+				/* Returned STA pointer */
+				struct rwnx_sta *rwnx_sta =
+					&rwnx_hw->sta_table[rwnx_vif->ap
+								    .bcmc_index];
+
+				if (rwnx_sta->valid)
+					return rwnx_sta;
+			} else {
+				/* Returned STA pointer */
+				struct rwnx_sta *rwnx_sta;
+
+				/* Go through list of STAs linked with the provided VIF */
 				spin_lock_bh(&rwnx_vif->rwnx_hw->cb_lock);
-                list_for_each_entry(rwnx_sta, &rwnx_vif->ap.sta_list, list) {
-					AICWFDBG(LOGDEBUG, "%s mac_addr:%x %x %x %x %x %x addr:%x %x %x %x %x %x \r\n", __func__,
-						rwnx_sta->mac_addr[0],rwnx_sta->mac_addr[1],rwnx_sta->mac_addr[2],
-						rwnx_sta->mac_addr[3],rwnx_sta->mac_addr[4],rwnx_sta->mac_addr[5],
-						addr[0],addr[1],addr[2],addr[3],addr[4],addr[5]);
-                    if (rwnx_sta->valid &&
-                        ether_addr_equal(rwnx_sta->mac_addr, addr)) {
-                        /* Return the found STA */
-						spin_unlock_bh(&rwnx_vif->rwnx_hw->cb_lock);
-                        return rwnx_sta;
-                    }
-                }
+				list_for_each_entry(rwnx_sta,
+						    &rwnx_vif->ap.sta_list,
+						    list) {
+					AICWFDBG(
+						LOGDEBUG,
+						"%s mac_addr:%x %x %x %x %x %x addr:%x %x %x %x %x %x \r\n",
+						__func__, rwnx_sta->mac_addr[0],
+						rwnx_sta->mac_addr[1],
+						rwnx_sta->mac_addr[2],
+						rwnx_sta->mac_addr[3],
+						rwnx_sta->mac_addr[4],
+						rwnx_sta->mac_addr[5], addr[0],
+						addr[1], addr[2], addr[3],
+						addr[4], addr[5]);
+					if (rwnx_sta->valid &&
+					    ether_addr_equal(rwnx_sta->mac_addr,
+							     addr)) {
+						/* Return the found STA */
+						spin_unlock_bh(
+							&rwnx_vif->rwnx_hw
+								 ->cb_lock);
+						return rwnx_sta;
+					}
+				}
 				spin_unlock_bh(&rwnx_vif->rwnx_hw->cb_lock);
-            }
-        }
-    } else {
-        return rwnx_vif->sta.ap;
-    }
+			}
+		}
+	} else {
+		return rwnx_vif->sta.ap;
+	}
 
-    return NULL;
+	return NULL;
 }
 
 /**
@@ -3429,50 +2274,52 @@ static struct rwnx_sta *rwnx_retrieve_sta(struct rwnx_hw *rwnx_hw,
  *	wireless_dev, or an ERR_PTR. For P2P device wdevs, the driver must
  *	also set the address member in the wdev.
  */
-static struct wireless_dev *rwnx_cfg80211_add_iface(struct wiphy *wiphy,
-                                                    const char *name,
-                                                    unsigned char name_assign_type,
-                                                    enum nl80211_iftype type,
-                                                    struct vif_params *params)
+static struct wireless_dev *
+rwnx_cfg80211_add_iface(struct wiphy *wiphy, const char *name,
+			unsigned char name_assign_type,
+			enum nl80211_iftype type, struct vif_params *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct wireless_dev *wdev;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct wireless_dev *wdev;
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0))
-    unsigned char name_assign_type = NET_NAME_UNKNOWN;
+	unsigned char name_assign_type = NET_NAME_UNKNOWN;
 #endif
 
-    if (type != NL80211_IFTYPE_P2P_DEVICE) {
-        struct rwnx_vif *vif= rwnx_interface_add(rwnx_hw, name, name_assign_type, type, params);
-        if (!vif)
-            return ERR_PTR(-EINVAL);
-        return &vif->wdev;
+	if (type != NL80211_IFTYPE_P2P_DEVICE) {
+		struct rwnx_vif *vif = rwnx_interface_add(
+			rwnx_hw, name, name_assign_type, type, params);
+		if (!vif)
+			return ERR_PTR(-EINVAL);
+		return &vif->wdev;
 
-    } else {
-        wdev = rwnx_virtual_interface_add(rwnx_hw, name, name_assign_type, type, params);
-        if (!wdev)
-            return ERR_PTR(-EINVAL);
-        return wdev;
-    }
+	} else {
+		wdev = rwnx_virtual_interface_add(
+			rwnx_hw, name, name_assign_type, type, params);
+		if (!wdev)
+			return ERR_PTR(-EINVAL);
+		return wdev;
+	}
 }
 
 /**
  * @del_virtual_intf: remove the virtual interface
  */
-static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)
+static int rwnx_cfg80211_del_iface(struct wiphy *wiphy,
+				   struct wireless_dev *wdev)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
-    struct net_device *dev = wdev->netdev;
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
+	struct net_device *dev = wdev->netdev;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
 #else
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 #endif
-   // printk("del_iface: %p\n",wdev);
+	// printk("del_iface: %p\n",wdev);
 
-	AICWFDBG(LOGINFO, "del_iface: %p, %x\n",wdev, wdev->address[5]);
+	AICWFDBG(LOGINFO, "del_iface: %p, %x\n", wdev, wdev->address[5]);
 
-    if (!dev || !rwnx_vif->ndev) {
+	if (!dev || !rwnx_vif->ndev) {
 #if 0
 	if (rwnx_vif == rwnx_hw->p2p_dev_vif) {
 		if (timer_pending(&rwnx_hw->p2p_alive_timer)) {
@@ -3480,40 +2327,39 @@ static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wde
 		}
 	}
 #endif
-        cfg80211_unregister_wdev(wdev);
-        spin_lock_bh(&rwnx_hw->cb_lock);
-        list_del(&rwnx_vif->list);
-        spin_unlock_bh(&rwnx_hw->cb_lock);
-        rwnx_hw->avail_idx_map |= BIT(rwnx_vif->drv_vif_index);
-        rwnx_vif->ndev = NULL;
-        kfree(rwnx_vif);
-        return 0;
-    }
+		cfg80211_unregister_wdev(wdev);
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		list_del(&rwnx_vif->list);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+		rwnx_hw->avail_idx_map |= BIT(rwnx_vif->drv_vif_index);
+		rwnx_vif->ndev = NULL;
+		kfree(rwnx_vif);
+		return 0;
+	}
 #if 0
     netdev_info(dev, "Remove Interface");
 #endif
 
 	AICWFDBG(LOGINFO, "%s Remove Interface \r\n", dev->name);
-    if (dev->reg_state == NETREG_REGISTERED) {
-        /* Will call rwnx_close if interface is UP */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
-        cfg80211_unregister_netdevice(dev);
+	if (dev->reg_state == NETREG_REGISTERED) {
+		/* Will call rwnx_close if interface is UP */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		cfg80211_unregister_netdevice(dev);
 #else
-        unregister_netdevice(dev);
+		unregister_netdevice(dev);
 #endif
+	}
 
-    }
-
-    spin_lock_bh(&rwnx_hw->cb_lock);
-    list_del(&rwnx_vif->list);
-    spin_unlock_bh(&rwnx_hw->cb_lock);
-    rwnx_hw->avail_idx_map |= BIT(rwnx_vif->drv_vif_index);
-    rwnx_vif->ndev = NULL;
+	spin_lock_bh(&rwnx_hw->cb_lock);
+	list_del(&rwnx_vif->list);
+	spin_unlock_bh(&rwnx_hw->cb_lock);
+	rwnx_hw->avail_idx_map |= BIT(rwnx_vif->drv_vif_index);
+	rwnx_vif->ndev = NULL;
 
-    /* Clear the priv in adapter */
-    dev->ieee80211_ptr = NULL;
+	/* Clear the priv in adapter */
+	dev->ieee80211_ptr = NULL;
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -3521,85 +2367,89 @@ static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wde
  *	keep the struct wireless_dev's iftype updated.
  */
 static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
-                                      struct net_device *dev,
-                                      enum nl80211_iftype type,
-                                      struct vif_params *params)
+				      struct net_device *dev,
+				      enum nl80211_iftype type,
+				      struct vif_params *params)
 {
 #ifndef CONFIG_RWNX_MON_DATA
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #endif
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct mm_add_if_cfm add_if_cfm;
-    bool_l p2p = false;
-    int ret;
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct mm_add_if_cfm add_if_cfm;
+	bool_l p2p = false;
+	int ret;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d\r\n", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d\r\n", vif->wdev.iftype,
+		 type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
 
 #ifdef CONFIG_COEX
-    if (type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_P2P_GO)
-        rwnx_send_coex_req(vif->rwnx_hw, 1, 0);
-    if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_P2P_GO)
-        rwnx_send_coex_req(vif->rwnx_hw, 0, 1);
+	if (type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_P2P_GO)
+		rwnx_send_coex_req(vif->rwnx_hw, 1, 0);
+	if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_AP ||
+	    RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_P2P_GO)
+		rwnx_send_coex_req(vif->rwnx_hw, 0, 1);
 #endif
 #ifndef CONFIG_RWNX_MON_DATA
-    if ((type == NL80211_IFTYPE_MONITOR) &&
-       (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MONITOR)) {
-        struct rwnx_vif *vif_el;
-        list_for_each_entry(vif_el, &rwnx_hw->vifs, list) {
-            // Check if data interface already exists
-            if ((vif_el != vif) &&
-               (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MONITOR)) {
-                wiphy_err(rwnx_hw->wiphy,
-                        "Monitor+Data interface support (MON_DATA) disabled\n");
-                return -EIO;
-            }
-        }
-    }
+	if ((type == NL80211_IFTYPE_MONITOR) &&
+	    (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MONITOR)) {
+		struct rwnx_vif *vif_el;
+		list_for_each_entry(vif_el, &rwnx_hw->vifs, list) {
+			// Check if data interface already exists
+			if ((vif_el != vif) &&
+			    (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_MONITOR)) {
+				wiphy_err(
+					rwnx_hw->wiphy,
+					"Monitor+Data interface support (MON_DATA) disabled\n");
+				return -EIO;
+			}
+		}
+	}
 #endif
 
-    // Reset to default case (i.e. not monitor)
-    dev->type = ARPHRD_ETHER;
-    dev->netdev_ops = &rwnx_netdev_ops;
+	// Reset to default case (i.e. not monitor)
+	dev->type = ARPHRD_ETHER;
+	dev->netdev_ops = &rwnx_netdev_ops;
 
-    switch (type) {
-    case NL80211_IFTYPE_STATION:
-    case NL80211_IFTYPE_P2P_CLIENT:
-        vif->sta.ap = NULL;
-        vif->sta.tdls_sta = NULL;
-        vif->sta.external_auth = false;
-        break;
-    case NL80211_IFTYPE_MESH_POINT:
-        INIT_LIST_HEAD(&vif->ap.mpath_list);
-        INIT_LIST_HEAD(&vif->ap.proxy_list);
-        vif->ap.create_path = false;
-        vif->ap.generation = 0;
-        // no break
-    case NL80211_IFTYPE_AP:
-    case NL80211_IFTYPE_P2P_GO:
-        INIT_LIST_HEAD(&vif->ap.sta_list);
-        memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
-        break;
-    case NL80211_IFTYPE_AP_VLAN:
-        return -EPERM;
-    case NL80211_IFTYPE_MONITOR:
-        dev->type = ARPHRD_IEEE80211_RADIOTAP;
-        dev->netdev_ops = &rwnx_netdev_monitor_ops;
-        break;
-    default:
-        break;
-    }
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		vif->sta.ap = NULL;
+		vif->sta.tdls_sta = NULL;
+		vif->sta.external_auth = false;
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		INIT_LIST_HEAD(&vif->ap.mpath_list);
+		INIT_LIST_HEAD(&vif->ap.proxy_list);
+		vif->ap.create_path = false;
+		vif->ap.generation = 0;
+		// no break
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		INIT_LIST_HEAD(&vif->ap.sta_list);
+		memset(&vif->ap.bcn, 0, sizeof(vif->ap.bcn));
+		break;
+	case NL80211_IFTYPE_AP_VLAN:
+		return -EPERM;
+	case NL80211_IFTYPE_MONITOR:
+		dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		dev->netdev_ops = &rwnx_netdev_monitor_ops;
+		break;
+	default:
+		break;
+	}
 
-    vif->wdev.iftype = type;
-    if (params->use_4addr != -1)
-        vif->use_4addr = params->use_4addr;
-    if (type == NL80211_IFTYPE_P2P_CLIENT || type == NL80211_IFTYPE_P2P_GO){
-        p2p = true;
-    }
+	vif->wdev.iftype = type;
+	if (params->use_4addr != -1)
+		vif->use_4addr = params->use_4addr;
+	if (type == NL80211_IFTYPE_P2P_CLIENT ||
+	    type == NL80211_IFTYPE_P2P_GO) {
+		p2p = true;
+	}
 	if (vif->up) {
-	    /* Abort scan request on the vif */
-	    if (vif->rwnx_hw->scan_request &&
-	        vif->rwnx_hw->scan_request->wdev == &vif->wdev) {
+		/* Abort scan request on the vif */
+		if (vif->rwnx_hw->scan_request &&
+		    vif->rwnx_hw->scan_request->wdev == &vif->wdev) {
 #if 0
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 	        struct cfg80211_scan_info info = {
@@ -3615,63 +2465,70 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	        }
 	        vif->rwnx_hw->scan_request = NULL;
 #else
-            if ((ret = rwnx_send_scanu_cancel_req(vif->rwnx_hw, NULL))) {
-                AICWFDBG(LOGERROR, "scanu_cancel fail\n");
-                return ret;
-            }
-#endif
-	    }
-        
-	    if ((ret = rwnx_send_remove_if(vif->rwnx_hw, vif->vif_index, false))) {
+			if ((ret = rwnx_send_scanu_cancel_req(vif->rwnx_hw,
+							      NULL))) {
+				AICWFDBG(LOGERROR, "scanu_cancel fail\n");
+				return ret;
+			}
+#endif
+		}
+
+		if ((ret = rwnx_send_remove_if(vif->rwnx_hw, vif->vif_index,
+					       false))) {
 			AICWFDBG(LOGERROR, "remove_if fail\n");
-	        return ret;
-	    }
+			return ret;
+		}
 		vif->rwnx_hw->vif_table[vif->vif_index] = NULL;
 		AICWFDBG(LOGINFO, "change_if from %d \n", vif->vif_index);
-	    if ((ret = rwnx_send_add_if(vif->rwnx_hw, vif->wdev.address,
-	                                              RWNX_VIF_TYPE(vif), p2p, &add_if_cfm))) {
-	            AICWFDBG(LOGERROR, "add if fail\n");
-	            return ret;
-	    }
-	    if (add_if_cfm.status != 0) {
-				AICWFDBG(LOGERROR, "add if status fail\n");
-	            return -EIO;
-	    }
+		if ((ret = rwnx_send_add_if(vif->rwnx_hw, vif->wdev.address,
+					    RWNX_VIF_TYPE(vif), p2p,
+					    &add_if_cfm))) {
+			AICWFDBG(LOGERROR, "add if fail\n");
+			return ret;
+		}
+		if (add_if_cfm.status != 0) {
+			AICWFDBG(LOGERROR, "add if status fail\n");
+			return -EIO;
+		}
 
 		AICWFDBG(LOGINFO, "change_if to %d \n", add_if_cfm.inst_nbr);
-	    /* Save the index retrieved from LMAC */
-	    spin_lock_bh(&vif->rwnx_hw->cb_lock);
-	    vif->vif_index = add_if_cfm.inst_nbr;
-	    vif->rwnx_hw->vif_table[add_if_cfm.inst_nbr] = vif;
-	    spin_unlock_bh(&vif->rwnx_hw->cb_lock);
-	}
-
-    if (type == NL80211_IFTYPE_MONITOR) {
-        vif->rwnx_hw->monitor_vif = vif->vif_index;
-        #if defined(CONFIG_RWNX_MON_XMIT)
-        rwnx_txq_unk_vif_init(vif);
-        #endif
-        #if defined(CONFIG_RWNX_MON_RXFILTER)
-        rwnx_send_set_filter(vif->rwnx_hw, (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS | FIF_PSPOLL | FIF_PROBE_REQ));
-        #endif
-    } else {
-        vif->rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
-    }
+		/* Save the index retrieved from LMAC */
+		spin_lock_bh(&vif->rwnx_hw->cb_lock);
+		vif->vif_index = add_if_cfm.inst_nbr;
+		vif->rwnx_hw->vif_table[add_if_cfm.inst_nbr] = vif;
+		spin_unlock_bh(&vif->rwnx_hw->cb_lock);
+	}
 
-    return 0;
+	if (type == NL80211_IFTYPE_MONITOR) {
+		vif->rwnx_hw->monitor_vif = vif->vif_index;
+#if defined(CONFIG_RWNX_MON_XMIT)
+		rwnx_txq_unk_vif_init(vif);
+#endif
+#if defined(CONFIG_RWNX_MON_RXFILTER)
+		rwnx_send_set_filter(vif->rwnx_hw,
+				     (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS |
+				      FIF_PSPOLL | FIF_PROBE_REQ));
+#endif
+	} else {
+		vif->rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
+	}
+
+	return 0;
 }
 
-static int rwnx_cfgp2p_start_p2p_device(struct wiphy *wiphy, struct wireless_dev *wdev)
+static int rwnx_cfgp2p_start_p2p_device(struct wiphy *wiphy,
+					struct wireless_dev *wdev)
 {
-    int ret = 0;
+	int ret = 0;
 
-    //do nothing
-    AICWFDBG(LOGINFO, "P2P interface started\n");
+	//do nothing
+	AICWFDBG(LOGINFO, "P2P interface started\n");
 
-    return ret;
+	return ret;
 }
 
-static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev *wdev)
+static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy,
+					struct wireless_dev *wdev)
 {
 #if 0
     int ret = 0;
@@ -3705,7 +2562,7 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
 	/* Abort scan request on the vif */
 	if (rwnx_hw->scan_request &&
-		rwnx_hw->scan_request->wdev == &rwnx_vif->wdev) {
+	    rwnx_hw->scan_request->wdev == &rwnx_vif->wdev) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 		struct cfg80211_scan_info info = {
 			.aborted = true,
@@ -3717,7 +2574,7 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 #endif
 		rwnx_hw->scan_request = NULL;
 		ret = rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
-		if (ret){
+		if (ret) {
 			AICWFDBG(LOGERROR, "scanu_cancel fail\n");
 		}
 	}
@@ -3733,7 +2590,8 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 			spin_lock_bh(&rwnx_hw->cb_lock);
 			rwnx_vif->up = false;
 			rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
-            AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
+			AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n",
+				 __func__, rwnx_vif->vif_index);
 			rwnx_hw->vif_started--;
 			spin_unlock_bh(&rwnx_hw->cb_lock);
 		}
@@ -3741,21 +2599,22 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 
 	AICWFDBG(LOGINFO, "Exit. P2P interface stopped\n");
 
-    return;
+	return;
 }
 
-int rwnx_send_check_p2p(struct cfg80211_scan_request *param){
+int rwnx_send_check_p2p(struct cfg80211_scan_request *param)
+{
 	int index = (u8)min_t(int, SCAN_SSID_MAX, param->n_ssids);
 	int i = 0;
 
-	for(i = 0;i < index;i++){
-        if (!memcmp("DIRECT-", param->ssids[i].ssid,
-            (sizeof("DIRECT-") - 1))) {
-            //printk("AIDEN rwnx_send_check_p2p!!\r\n");
+	for (i = 0; i < index; i++) {
+		if (!memcmp("DIRECT-", param->ssids[i].ssid,
+			    (sizeof("DIRECT-") - 1))) {
+			//printk("AIDEN rwnx_send_check_p2p!!\r\n");
 			return 1;
-        }
+		}
 	}
-		return 0;
+	return 0;
 }
 
 /**
@@ -3765,61 +2624,66 @@ int rwnx_send_check_p2p(struct cfg80211_scan_request *param){
  *	the scan/scan_done bracket too.
  */
 static int rwnx_cfg80211_scan(struct wiphy *wiphy,
-	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-	struct net_device *dev,
-	#endif
-                              struct cfg80211_scan_request *request)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
+			      struct net_device *dev,
+#endif
+			      struct cfg80211_scan_request *request)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-    struct rwnx_vif *rwnx_vif = container_of(request->wdev, struct rwnx_vif,
-                                            wdev);
+	struct rwnx_vif *rwnx_vif =
+		container_of(request->wdev, struct rwnx_vif, wdev);
 #else
-    struct rwnx_vif* rwnx_vif = netdev_priv(request->dev);
+	struct rwnx_vif *rwnx_vif = netdev_priv(request->dev);
 #endif
-    int error;
+	int error;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-	if(testmode){
+	if (testmode) {
 		AICWFDBG(LOGERROR, "%s in testmode return busy\r\n", __func__);
 		return -EBUSY;
 	}
 
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGERROR, "%s in connecting return busy\r\n", __func__);
+	if ((int)atomic_read(&rwnx_vif->drv_conn_state) ==
+	    (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(LOGERROR, "%s in connecting return busy\r\n",
+			 __func__);
 		return -EBUSY;
 	}
 
 #ifndef CONFIG_STA_SCAN_WHEN_P2P_WORKING
-	if (p2p_working && RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_CLIENT &&
-		!rwnx_send_check_p2p(request)) {
+	if (rwnx_hw->p2p_working &&
+	    RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_CLIENT &&
+	    !rwnx_send_check_p2p(request)) {
 		AICWFDBG(LOGINFO, "p2p is working, scan abort\n");
 		return -EBUSY;
 	}
 #endif
 
-	if (scanning) {
+	if (rwnx_hw->scanning) {
 		AICWFDBG(LOGERROR, "%s is scanning, abort\n", __func__);
-    #if 0//AIDEN test
+#if 0 //AIDEN test
 		error =  rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
 		if (error)
 			return error;
 		msleep(150);
-    #endif
-        return -EBUSY;
+#endif
+		return -EBUSY;
 	}
 
-	if((RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) &&  rwnx_vif->sta.external_auth){
+	if ((RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
+	     RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) &&
+	    rwnx_vif->sta.external_auth) {
 		AICWFDBG(LOGINFO, "scan about: external auth\r\n");
 		return -EBUSY;
 	}
 
-    rwnx_hw->scan_request = request;
-    if ((error = rwnx_send_scanu_req(rwnx_hw, rwnx_vif, request)))
-        return error;
+	rwnx_hw->scan_request = request;
+	if ((error = rwnx_send_scanu_req(rwnx_hw, rwnx_vif, request)))
+		return error;
 
-    return 0;
+	return 0;
 }
 
 bool key_flag = false;
@@ -3829,90 +2693,90 @@ bool key_flag = false;
  */
 static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                                                 int link_id,
+				 int link_id,
 #endif
-                                 u8 key_index, bool pairwise, const u8 *mac_addr,
-                                 struct key_params *params)
+				 u8 key_index, bool pairwise,
+				 const u8 *mac_addr, struct key_params *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(netdev);
-    int i, error = 0;
-    struct mm_key_add_cfm key_add_cfm;
-    u8_l cipher = 0;
-    struct rwnx_sta *sta = NULL;
-    struct rwnx_key *rwnx_key;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(netdev);
+	int i, error = 0;
+	struct mm_key_add_cfm key_add_cfm;
+	u8_l cipher = 0;
+	struct rwnx_sta *sta = NULL;
+	struct rwnx_key *rwnx_key;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    if (mac_addr) {
-        sta = rwnx_get_sta(rwnx_hw, mac_addr);
-        if (!sta)
-            return -EINVAL;
-        rwnx_key = &sta->key;
-        if (vif->wdev.iftype == NL80211_IFTYPE_STATION || vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
-            vif->sta.paired_cipher_type = params->cipher;
-    }
-    else {
-        rwnx_key = &vif->key[key_index];
-        vif->key_has_add = 1;
-        if (vif->wdev.iftype == NL80211_IFTYPE_STATION || vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
-            vif->sta.group_cipher_type = params->cipher;
-    }
+	if (mac_addr) {
+		sta = rwnx_get_sta(rwnx_hw, mac_addr);
+		if (!sta)
+			return -EINVAL;
+		rwnx_key = &sta->key;
+		if (vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+		    vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
+			vif->sta.paired_cipher_type = params->cipher;
+	} else {
+		rwnx_key = &vif->key[key_index];
+		vif->key_has_add = 1;
+		if (vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+		    vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
+			vif->sta.group_cipher_type = params->cipher;
+	}
 
-    /* Retrieve the cipher suite selector */
-    switch (params->cipher) {
-    case WLAN_CIPHER_SUITE_WEP40:
-        cipher = MAC_CIPHER_WEP40;
-        break;
-    case WLAN_CIPHER_SUITE_WEP104:
-        cipher = MAC_CIPHER_WEP104;
-        break;
-    case WLAN_CIPHER_SUITE_TKIP:
-        cipher = MAC_CIPHER_TKIP;
-        break;
-    case WLAN_CIPHER_SUITE_CCMP:
-        cipher = MAC_CIPHER_CCMP;
-        break;
-    case WLAN_CIPHER_SUITE_AES_CMAC:
-        cipher = MAC_CIPHER_BIP_CMAC_128;
-        break;
-    case WLAN_CIPHER_SUITE_SMS4:
-    {
-        // Need to reverse key order
-        u8 tmp, *key = (u8 *)params->key;
-        cipher = MAC_CIPHER_WPI_SMS4;
-        for (i = 0; i < WPI_SUBKEY_LEN/2; i++) {
-            tmp = key[i];
-            key[i] = key[WPI_SUBKEY_LEN - 1 - i];
-            key[WPI_SUBKEY_LEN - 1 - i] = tmp;
-        }
-        for (i = 0; i < WPI_SUBKEY_LEN/2; i++) {
-            tmp = key[i + WPI_SUBKEY_LEN];
-            key[i + WPI_SUBKEY_LEN] = key[WPI_KEY_LEN - 1 - i];
-            key[WPI_KEY_LEN - 1 - i] = tmp;
-        }
-        break;
-    }
-    default:
-        return -EINVAL;
-    }
+	/* Retrieve the cipher suite selector */
+	switch (params->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		cipher = MAC_CIPHER_WEP40;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		cipher = MAC_CIPHER_WEP104;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		cipher = MAC_CIPHER_TKIP;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		cipher = MAC_CIPHER_CCMP;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		cipher = MAC_CIPHER_BIP_CMAC_128;
+		break;
+	case WLAN_CIPHER_SUITE_SMS4: {
+		// Need to reverse key order
+		u8 tmp, *key = (u8 *)params->key;
+		cipher = MAC_CIPHER_WPI_SMS4;
+		for (i = 0; i < WPI_SUBKEY_LEN / 2; i++) {
+			tmp = key[i];
+			key[i] = key[WPI_SUBKEY_LEN - 1 - i];
+			key[WPI_SUBKEY_LEN - 1 - i] = tmp;
+		}
+		for (i = 0; i < WPI_SUBKEY_LEN / 2; i++) {
+			tmp = key[i + WPI_SUBKEY_LEN];
+			key[i + WPI_SUBKEY_LEN] = key[WPI_KEY_LEN - 1 - i];
+			key[WPI_KEY_LEN - 1 - i] = tmp;
+		}
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
 
-    key_flag = false;
-    if ((error = rwnx_send_key_add(rwnx_hw, vif->vif_index,
-                                   (sta ? sta->sta_idx : 0xFF), pairwise,
-                                   (u8 *)params->key, params->key_len,
-                                   key_index, cipher, &key_add_cfm)))
-        return error;
+	key_flag = false;
+	if ((error = rwnx_send_key_add(rwnx_hw, vif->vif_index,
+				       (sta ? sta->sta_idx : 0xFF), pairwise,
+				       (u8 *)params->key, params->key_len,
+				       key_index, cipher, &key_add_cfm)))
+		return error;
 
-    if (key_add_cfm.status != 0) {
-        RWNX_PRINT_CFM_ERR(key_add);
-        return -EIO;
-    }
+	if (key_add_cfm.status != 0) {
+		RWNX_PRINT_CFM_ERR(key_add);
+		return -EIO;
+	}
 
-    /* Save the index retrieved from LMAC */
-    rwnx_key->hw_idx = key_add_cfm.hw_key_idx;
+	/* Save the index retrieved from LMAC */
+	rwnx_key->hw_idx = key_add_cfm.hw_key_idx;
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -3925,86 +2789,89 @@ static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                                                 int link_id,
+				 int link_id,
 #endif
 
-                                 u8 key_index, bool pairwise, const u8 *mac_addr,
-                                 void *cookie,
-                                 void (*callback)(void *cookie, struct key_params*))
+				 u8 key_index, bool pairwise,
+				 const u8 *mac_addr, void *cookie,
+				 void (*callback)(void *cookie,
+						  struct key_params *))
 {
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    return -1;
+	return -1;
 }
 
-
 /**
  * @del_key: remove a key given the @mac_addr (%NULL for a group key)
  *	and @key_index, return -ENOENT if the key doesn't exist.
  */
 static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                                                 int link_id,
+				 int link_id,
 #endif
 
-                                 u8 key_index, bool pairwise, const u8 *mac_addr)
+				 u8 key_index, bool pairwise,
+				 const u8 *mac_addr)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(netdev);
-    int error;
-    struct rwnx_sta *sta = NULL;
-    struct rwnx_key *rwnx_key;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(netdev);
+	int error;
+	struct rwnx_sta *sta = NULL;
+	struct rwnx_key *rwnx_key;
 	if (!key_flag && vif->wdev.iftype == NL80211_IFTYPE_STATION)
 		return 0;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-    if (mac_addr) {
-        sta = rwnx_get_sta(rwnx_hw, mac_addr);
-        if (!sta)
-            return -EINVAL;
-        rwnx_key = &sta->key;
-        if (vif->wdev.iftype == NL80211_IFTYPE_STATION || vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
-            vif->sta.paired_cipher_type = 0xff;
-    }
-    else {
-        rwnx_key = &vif->key[key_index];
-        vif->key_has_add = 0;
-        if (vif->wdev.iftype == NL80211_IFTYPE_STATION || vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
-            vif->sta.group_cipher_type = 0xff;
-    }
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+	if (mac_addr) {
+		sta = rwnx_get_sta(rwnx_hw, mac_addr);
+		if (!sta)
+			return -EINVAL;
+		rwnx_key = &sta->key;
+		if (vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+		    vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
+			vif->sta.paired_cipher_type = 0xff;
+	} else {
+		rwnx_key = &vif->key[key_index];
+		vif->key_has_add = 0;
+		if (vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+		    vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)
+			vif->sta.group_cipher_type = 0xff;
+	}
 
-    error = rwnx_send_key_del(rwnx_hw, rwnx_key->hw_idx);
+	error = rwnx_send_key_del(rwnx_hw, rwnx_key->hw_idx);
 
-    rwnx_key->hw_idx = 0;
-    return error;
+	rwnx_key->hw_idx = 0;
+	return error;
 }
 
 /**
  * @set_default_key: set the default key on an interface
  */
 static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
-                                         struct net_device *netdev,
+					 struct net_device *netdev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                                                 int link_id,
+					 int link_id,
 #endif
-                                         u8 key_index, bool unicast, bool multicast)
+					 u8 key_index, bool unicast,
+					 bool multicast)
 {
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    return 0;
+	return 0;
 }
 
 /**
  * @set_default_mgmt_key: set the default management frame key on an interface
  */
 static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
-                                              struct net_device *netdev,
+					      struct net_device *netdev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                                                 int link_id,
+					      int link_id,
 #endif
-                                              u8 key_index)
+					      u8 key_index)
 {
-    return 0;
+	return 0;
 }
 
 /**
@@ -4016,124 +2883,150 @@ static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
  */
 
 static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
-                                 struct cfg80211_connect_params *sme)
+				 struct cfg80211_connect_params *sme)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct sm_connect_cfm sm_connect_cfm;
-    int error = 0;
-    int is_wep = ((sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||
-	                (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) ||
-	                (sme->crypto.ciphers_pairwise[0] == WLAN_CIPHER_SUITE_WEP40) ||
-		            (sme->crypto.ciphers_pairwise[0] == WLAN_CIPHER_SUITE_WEP104));
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct sm_connect_cfm sm_connect_cfm;
+	int error = 0;
+	int is_wep =
+		((sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||
+		 (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) ||
+		 (sme->crypto.ciphers_pairwise[0] == WLAN_CIPHER_SUITE_WEP40) ||
+		 (sme->crypto.ciphers_pairwise[0] == WLAN_CIPHER_SUITE_WEP104));
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 #if 1
-#if 0
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
-		AICWFDBG(LOGERROR, "%s driver was connected return it \r\n", __func__);
-		return -EALREADY;
-	}
-#endif
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
+
+	if ((int)atomic_read(&rwnx_vif->drv_conn_state) ==
+	    (int)RWNX_DRV_STATUS_CONNECTED) {
 		AICWFDBG(LOGDEBUG, "%s this connection is roam \r\n", __func__);
 		rwnx_vif->sta.is_roam = true;
-	}else{
-		rwnx_vif->sta.is_roam = false; 
-	}
-
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
-		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
-		AICWFDBG(LOGERROR, "%s driver is disconnecting or connecting ,return it \r\n", __func__);
-		return -EALREADY;
-	}
-#endif
-
-	atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTING);
-
-    if(is_wep) {
-        if(sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
-            if(rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err) {
-                if(rwnx_vif->last_auth_type == NL80211_AUTHTYPE_SHARED_KEY)
-                    sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
-                else
-                    sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-            } else {
-                    if((rwnx_vif->wep_enabled && !rwnx_vif->wep_auth_err))
-                        sme->auth_type = rwnx_vif->last_auth_type;
-                    else
-                        sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-            }
-			AICWFDBG(LOGINFO, "auto: use sme->auth_type = %d\r\n", sme->auth_type);
-        } else {
-            if (rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err && (sme->auth_type == rwnx_vif->last_auth_type)) {
-                if(sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
-                    sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
-					AICWFDBG(LOGINFO, "start connect, auth_type changed, shared --> open\n");
-                } else if(sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
-                    sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-					AICWFDBG(LOGINFO, "start connect, auth_type changed, open --> shared\n");
-                }
-            }
-        }
-    }
+	} else {
+		rwnx_vif->sta.is_roam = false;
+	}
+
+	if ((int)atomic_read(&rwnx_vif->drv_conn_state) ==
+		    (int)RWNX_DRV_STATUS_DISCONNECTING ||
+	    (int)atomic_read(&rwnx_vif->drv_conn_state) ==
+		    (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(
+			LOGERROR,
+			"%s driver is disconnecting or connecting ,return it \r\n",
+			__func__);
+		return 0;
+	}
+#endif
+
+	if (rwnx_vif->sta.is_roam) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state,
+				    (int)RWNX_DRV_STATUS_ROAMING);
+	} else {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state,
+				    (int)RWNX_DRV_STATUS_CONNECTING);
+	}
+
+	if (is_wep) {
+		if (sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
+			if (rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err) {
+				if (rwnx_vif->last_auth_type ==
+				    NL80211_AUTHTYPE_SHARED_KEY)
+					sme->auth_type =
+						NL80211_AUTHTYPE_OPEN_SYSTEM;
+				else
+					sme->auth_type =
+						NL80211_AUTHTYPE_SHARED_KEY;
+			} else {
+				if ((rwnx_vif->wep_enabled &&
+				     !rwnx_vif->wep_auth_err))
+					sme->auth_type =
+						rwnx_vif->last_auth_type;
+				else
+					sme->auth_type =
+						NL80211_AUTHTYPE_SHARED_KEY;
+			}
+			AICWFDBG(LOGINFO, "auto: use sme->auth_type = %d\r\n",
+				 sme->auth_type);
+		} else {
+			if (rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err &&
+			    (sme->auth_type == rwnx_vif->last_auth_type)) {
+				if (sme->auth_type ==
+				    NL80211_AUTHTYPE_SHARED_KEY) {
+					sme->auth_type =
+						NL80211_AUTHTYPE_OPEN_SYSTEM;
+					AICWFDBG(
+						LOGINFO,
+						"start connect, auth_type changed, shared --> open\n");
+				} else if (sme->auth_type ==
+					   NL80211_AUTHTYPE_OPEN_SYSTEM) {
+					sme->auth_type =
+						NL80211_AUTHTYPE_SHARED_KEY;
+					AICWFDBG(
+						LOGINFO,
+						"start connect, auth_type changed, open --> shared\n");
+				}
+			}
+		}
+	}
 
-    /* For SHARED-KEY authentication, must install key first */
-    if (sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY && sme->key)
-    {
-        struct key_params key_params;
-        key_params.key = (u8*)sme->key;
-        key_params.seq = NULL;
-        key_params.key_len = sme->key_len;
-        key_params.seq_len = 0;
-        key_params.cipher = sme->crypto.cipher_group;
-        rwnx_cfg80211_add_key(wiphy, dev,
+	/* For SHARED-KEY authentication, must install key first */
+	if (sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY && sme->key) {
+		struct key_params key_params;
+		key_params.key = (u8 *)sme->key;
+		key_params.seq = NULL;
+		key_params.key_len = sme->key_len;
+		key_params.seq_len = 0;
+		key_params.cipher = sme->crypto.cipher_group;
+		rwnx_cfg80211_add_key(wiphy, dev,
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
-                                0,
+				      0,
 #endif
-	sme->key_idx, false, NULL, &key_params);
-    }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
-    else if ((sme->auth_type == NL80211_AUTHTYPE_SAE) &&
-             !(sme->flags & CONNECT_REQ_EXTERNAL_AUTH_SUPPORT)) {
-        netdev_err(dev, "Doesn't support SAE without external authentication\n");
-        return -EINVAL;
-    }
+				      sme->key_idx, false, NULL, &key_params);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || \
+	defined(CONFIG_WPA3_FOR_OLD_KERNEL)
+	else if ((sme->auth_type == NL80211_AUTHTYPE_SAE) &&
+		 !(sme->flags & CONNECT_REQ_EXTERNAL_AUTH_SUPPORT)) {
+		netdev_err(
+			dev,
+			"Doesn't support SAE without external authentication\n");
+		return -EINVAL;
+	}
 #endif
 
-    if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
-        rwnx_hw->is_p2p_connected = 1;
-    }
-
-    if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION || rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
-        rwnx_vif->sta.paired_cipher_type = 0xff;
-        rwnx_vif->sta.group_cipher_type = 0xff;
-    }
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
+		rwnx_hw->is_p2p_connected = 1;
+	}
 
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION ||
+	    rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {
+		rwnx_vif->sta.paired_cipher_type = 0xff;
+		rwnx_vif->sta.group_cipher_type = 0xff;
+	}
 
-    /* Forward the information to the LMAC */
-    if ((error = rwnx_send_sm_connect_req(rwnx_hw, rwnx_vif, sme, &sm_connect_cfm)))
-        return error;
+	/* Forward the information to the LMAC */
+	if ((error = rwnx_send_sm_connect_req(rwnx_hw, rwnx_vif, sme,
+					      &sm_connect_cfm)))
+		return error;
 
-    // Check the status
-    switch (sm_connect_cfm.status)
-    {
-        case CO_OK:
-            error = 0;
-            break;
-        case CO_BUSY:
-            error = -EINPROGRESS;
-            break;
-        case CO_OP_IN_PROGRESS:
-            error = -EALREADY;
-            break;
-        default:
-            error = -EIO;
-            break;
-    }
+	// Check the status
+	switch (sm_connect_cfm.status) {
+	case CO_OK:
+		error = 0;
+		break;
+	case CO_BUSY:
+		error = -EINPROGRESS;
+		break;
+	case CO_OP_IN_PROGRESS:
+		error = -EALREADY;
+		break;
+	default:
+		error = -EIO;
+		break;
+	}
 
-    return error;
+	return error;
 }
 
 /**
@@ -4141,183 +3034,188 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
  *	(invoked with the wireless_dev mutex held)
  */
 static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
-                                    u16 reason_code)
+				    u16 reason_code)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 	AICWFDBG(LOGINFO, "%s drv_vif_index:%d disconnect reason:%d \r\n",
-		__func__, rwnx_vif->drv_vif_index, reason_code);
-
-#if 0
-	while(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGERROR, "%s driver connecting waiting 100ms \r\n", __func__);
-		msleep(100);
-		retry--;
-		if(retry == 0){
-			break;
-		}
-		if(rwnx_hw->usbdev->state == USB_DOWN_ST){
-			break;
-		}
-	}
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
+		 __func__, rwnx_vif->drv_vif_index, reason_code);
 
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
-	}
-#endif
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGINFO, "%s call cfg80211_connect_result reason:%d \r\n",
-			__func__, reason_code);
-		msleep(500);
+	if (atomic_read(&rwnx_vif->drv_conn_state) ==
+	    RWNX_DRV_STATUS_DISCONNECTED) {
+		AICWFDBG(LOGERROR, "%s this\r\n", __func__);
+		WARN_ON(1);
+		return -EBUSY;
 	}
 
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
-		AICWFDBG(LOGERROR, "%s wifi is disconnecting, return it:%d \r\n",
-				__func__, reason_code);
+	if (atomic_read(&rwnx_vif->drv_conn_state) ==
+	    RWNX_DRV_STATUS_DISCONNECTING) {
+		AICWFDBG(LOGERROR,
+			 "%s wifi is disconnecting, return it:%d \r\n",
+			 __func__, reason_code);
 		return -EBUSY;
 	}
 
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
+	if (atomic_read(&rwnx_vif->drv_conn_state) ==
+		    RWNX_DRV_STATUS_CONNECTED ||
+	    atomic_read(&rwnx_vif->drv_conn_state) ==
+		    RWNX_DRV_STATUS_CONNECTING ||
+	    atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_ROAMING) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state,
+				    RWNX_DRV_STATUS_DISCONNECTING);
 
-		#ifdef CONFIG_USE_WIRELESS_EXT
-		memset(rwnx_hw->wext_essid, 0, 32);
-		#endif
+#ifdef CONFIG_USE_WIRELESS_EXT
+		memset(rwnx_hw->wext_essid, 0, 33);
+#endif
 		key_flag = true;
-		return(rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code));
-	}else{
+		return (rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif,
+						    reason_code));
+	}
+#if 0
+    else{
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 			reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
 		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
-
+#endif
+	return 0;
 }
 
 #ifdef CONFIG_SCHED_SCAN
 
 static int rwnx_cfg80211_sched_scan_stop(struct wiphy *wiphy,
-					   struct net_device *ndev
+					 struct net_device *ndev
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
-					   ,u64 reqid)
+					 ,
+					 u64 reqid)
 #else
-                        )
+)
 #endif
 {
-
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	//struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 	AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
 
-    if(rwnx_hw->scan_request){
-        AICWFDBG(LOGINFO, "%s rwnx_send_scanu_cancel_req\r\n", __func__);
-        return rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
-    }else{
-        return 0;
-    }
+	if (rwnx_hw->scan_request) {
+		AICWFDBG(LOGINFO, "%s rwnx_send_scanu_cancel_req\r\n",
+			 __func__);
+		return rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
+	} else {
+		return 0;
+	}
 }
 
-
-static int rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy,
-                             struct net_device *dev,
-                             struct cfg80211_sched_scan_request *request)
+static int
+rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
+			       struct cfg80211_sched_scan_request *request)
 
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct cfg80211_scan_request *scan_request = NULL;
+	struct cfg80211_scan_request *scan_request = NULL;
 
-    int ret = 0;
-    int index = 0;
+	int ret = 0;
+	int index = 0;
 
-    AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
+	AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
 
-    if(rwnx_hw->is_sched_scan || scanning){
-        AICWFDBG(LOGERROR, "%s is_sched_scanning and scanning, busy", __func__);
-        return -EBUSY;
-    }
+	if (rwnx_hw->is_sched_scan || rwnx_hw->scanning) {
+		AICWFDBG(LOGERROR, "%s is_sched_scanning and scanning, busy",
+			 __func__);
+		return -EBUSY;
+	}
 
-    scan_request = (struct cfg80211_scan_request *)kmalloc(sizeof(struct cfg80211_scan_request), GFP_KERNEL);
+	scan_request = (struct cfg80211_scan_request *)kmalloc(
+		sizeof(struct cfg80211_scan_request), GFP_KERNEL);
 
-    scan_request->ssids = request->ssids;
-    scan_request->n_channels = request->n_channels;
-    scan_request->n_ssids = request->n_match_sets;
-    scan_request->no_cck = false;
+	scan_request->ssids = request->ssids;
+	scan_request->n_channels = request->n_channels;
+	scan_request->n_ssids = request->n_match_sets;
+	scan_request->no_cck = false;
 	scan_request->ie = request->ie;
 	scan_request->ie_len = request->ie_len;
-    scan_request->flags = request->flags;
-    scan_request->wiphy = wiphy;
-    scan_request->scan_start = request->scan_start;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
-    memcpy(scan_request->mac_addr, request->mac_addr, ETH_ALEN);
-    memcpy(scan_request->mac_addr_mask, request->mac_addr_mask, ETH_ALEN);
-#endif
-    rwnx_hw->sched_scan_req = request;
-    scan_request->wdev = &rwnx_vif->wdev;
-    AICWFDBG(LOGDEBUG, "%s scan_request->n_channels:%d \r\n", __func__, scan_request->n_channels);
-    AICWFDBG(LOGDEBUG, "%s scan_request->n_ssids:%d \r\n", __func__, scan_request->n_ssids);
-
-    for(index = 0; index < scan_request->n_ssids; index++){
-        memset(scan_request->ssids[index].ssid, 0, IEEE80211_MAX_SSID_LEN);
-
-        memcpy(scan_request->ssids[index].ssid,
-            request->match_sets[index].ssid.ssid,
-            IEEE80211_MAX_SSID_LEN);
-
-        scan_request->ssids[index].ssid_len = request->match_sets[index].ssid.ssid_len;
-
-        AICWFDBG(LOGDEBUG, "%s request ssid:%s len:%d \r\n", __func__,
-            scan_request->ssids[index].ssid, scan_request->ssids[index].ssid_len);
-    }
+	scan_request->flags = request->flags;
+	scan_request->wiphy = wiphy;
+	scan_request->scan_start = request->scan_start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	memcpy(scan_request->mac_addr, request->mac_addr, ETH_ALEN);
+	memcpy(scan_request->mac_addr_mask, request->mac_addr_mask, ETH_ALEN);
+#endif
+	rwnx_hw->sched_scan_req = request;
+	scan_request->wdev = &rwnx_vif->wdev;
+	AICWFDBG(LOGDEBUG, "%s scan_request->n_channels:%d \r\n", __func__,
+		 scan_request->n_channels);
+	AICWFDBG(LOGDEBUG, "%s scan_request->n_ssids:%d \r\n", __func__,
+		 scan_request->n_ssids);
+
+	for (index = 0; index < scan_request->n_ssids; index++) {
+		memset(scan_request->ssids[index].ssid, 0,
+		       IEEE80211_MAX_SSID_LEN);
+
+		memcpy(scan_request->ssids[index].ssid,
+		       request->match_sets[index].ssid.ssid,
+		       IEEE80211_MAX_SSID_LEN);
+
+		scan_request->ssids[index].ssid_len =
+			request->match_sets[index].ssid.ssid_len;
+
+		AICWFDBG(LOGDEBUG, "%s request ssid:%s len:%d \r\n", __func__,
+			 scan_request->ssids[index].ssid,
+			 scan_request->ssids[index].ssid_len);
+	}
 
-	for(index = 0;index < scan_request->n_channels; index++){
+	for (index = 0; index < scan_request->n_channels; index++) {
 		scan_request->channels[index] = request->channels[index];
 
-        AICWFDBG(LOGDEBUG, "%s scan_request->channels[%d]:%d \r\n", __func__, index,
-            scan_request->channels[index]->center_freq);
+		AICWFDBG(LOGDEBUG, "%s scan_request->channels[%d]:%d \r\n",
+			 __func__, index,
+			 scan_request->channels[index]->center_freq);
 
-		if(scan_request->channels[index] == NULL){
-			AICWFDBG(LOGERROR, "%s ERROR!!! channels is NULL", __func__);
+		if (scan_request->channels[index] == NULL) {
+			AICWFDBG(LOGERROR, "%s ERROR!!! channels is NULL",
+				 __func__);
 			continue;
 		}
 	}
 
-    rwnx_hw->is_sched_scan = true;
+	rwnx_hw->is_sched_scan = true;
 
-    if(scanning){
-        AICWFDBG(LOGERROR, "%s scanning, about it", __func__);
-        kfree(scan_request);
-        return -EBUSY;
-    }else{
-        ret = rwnx_cfg80211_scan(wiphy, scan_request);
-    }
+	if (rwnx_hw->scanning) {
+		AICWFDBG(LOGERROR, "%s scanning, about it", __func__);
+		kfree(scan_request);
+		return -EBUSY;
+	} else {
+		ret = rwnx_cfg80211_scan(wiphy, scan_request);
+	}
 
 	return ret;
 }
 #endif //CONFIG_SCHED_SCAN
 
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || \
+	defined(CONFIG_WPA3_FOR_OLD_KERNEL)
 /**
  * @external_auth: indicates result of offloaded authentication processing from
  *     user space
  */
-static int rwnx_cfg80211_external_auth(struct wiphy *wiphy, struct net_device *dev,
-                                       struct cfg80211_external_auth_params *params)
+static int
+rwnx_cfg80211_external_auth(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_external_auth_params *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 
 	//printk("%s Enter \r\n");
-    if (!rwnx_vif->sta.external_auth)
-        return -EINVAL;
+	if (!rwnx_vif->sta.external_auth)
+		return -EINVAL;
 
-    rwnx_external_auth_disable(rwnx_vif);
-    return rwnx_send_sm_external_auth_required_rsp(rwnx_hw, rwnx_vif,
-                                                   params->status);
+	rwnx_external_auth_disable(rwnx_vif);
+	return rwnx_send_sm_external_auth_required_rsp(rwnx_hw, rwnx_vif,
+						       params->status);
 }
 #endif
 
@@ -4325,206 +3223,217 @@ static int rwnx_cfg80211_external_auth(struct wiphy *wiphy, struct net_device *d
  * @add_station: Add a new station.
  */
 static int rwnx_cfg80211_add_station(struct wiphy *wiphy,
-	struct net_device *dev,
+				     struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-		u8 *mac,
+				     u8 *mac,
 #else
-		const u8 *mac,
+				     const u8 *mac,
 #endif
-	struct station_parameters *params)
+				     struct station_parameters *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct me_sta_add_cfm me_sta_add_cfm;
-    int error = 0;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct me_sta_add_cfm me_sta_add_cfm;
+	int error = 0;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    WARN_ON(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN);
+	WARN_ON(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN);
 
-    /* Do not add TDLS station */
-    if (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
-        return 0;
+	/* Do not add TDLS station */
+	if (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
+		return 0;
 
-    /* Indicate we are in a STA addition process - This will allow handling
+	/* Indicate we are in a STA addition process - This will allow handling
      * potential PS mode change indications correctly
      */
-    rwnx_hw->adding_sta = true;
-
-    /* Forward the information to the LMAC */
-    if ((error = rwnx_send_me_sta_add(rwnx_hw, params, mac, rwnx_vif->vif_index,
-                                      &me_sta_add_cfm)))
-        return error;
-
-    // Check the status
-    switch (me_sta_add_cfm.status)
-    {
-        case CO_OK:
-        {
-            struct rwnx_sta *sta = &rwnx_hw->sta_table[me_sta_add_cfm.sta_idx];
-            int tid;
-            sta->aid = params->aid;
-
-            sta->sta_idx = me_sta_add_cfm.sta_idx;
-            sta->ch_idx = rwnx_vif->ch_index;
-            sta->vif_idx = rwnx_vif->vif_index;
-            sta->vlan_idx = sta->vif_idx;
-            sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
+	rwnx_hw->adding_sta = true;
+
+	/* Forward the information to the LMAC */
+	if ((error = rwnx_send_me_sta_add(rwnx_hw, params, mac,
+					  rwnx_vif->vif_index,
+					  &me_sta_add_cfm)))
+		return error;
+
+	// Check the status
+	switch (me_sta_add_cfm.status) {
+	case CO_OK: {
+		struct rwnx_sta *sta =
+			&rwnx_hw->sta_table[me_sta_add_cfm.sta_idx];
+		int tid;
+		sta->aid = params->aid;
+
+		sta->sta_idx = me_sta_add_cfm.sta_idx;
+		sta->ch_idx = rwnx_vif->ch_index;
+		sta->vif_idx = rwnx_vif->vif_index;
+		sta->vlan_idx = sta->vif_idx;
+		sta->qos = (params->sta_flags_set &
+			    BIT(NL80211_STA_FLAG_WME)) != 0;
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-            sta->ht = params->link_sta_params.ht_capa ? 1 : 0;
-            sta->vht = params->link_sta_params.vht_capa ? 1 : 0;
+		sta->ht = params->link_sta_params.ht_capa ? 1 : 0;
+		sta->vht = params->link_sta_params.vht_capa ? 1 : 0;
 #else
-            sta->ht = params->ht_capa ? 1 : 0;
-            sta->vht = params->vht_capa ? 1 : 0;
-#endif
-
-            sta->acm = 0;
-            sta->key.hw_idx = 0;
-
-            if (params->local_pm != NL80211_MESH_POWER_UNKNOWN)
-                sta->mesh_pm = params->local_pm;
-            else
-                sta->mesh_pm = rwnx_vif->ap.next_mesh_pm;
-            rwnx_update_mesh_power_mode(rwnx_vif);
-
-            for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
-                int uapsd_bit = rwnx_hwq2uapsd[rwnx_tid2hwq[tid]];
-                if (params->uapsd_queues & uapsd_bit)
-                    sta->uapsd_tids |= 1 << tid;
-                else
-                    sta->uapsd_tids &= ~(1 << tid);
-            }
-            memcpy(sta->mac_addr, mac, ETH_ALEN);
+		sta->ht = params->ht_capa ? 1 : 0;
+		sta->vht = params->vht_capa ? 1 : 0;
+#endif
+
+		sta->acm = 0;
+		sta->key.hw_idx = 0;
+
+		if (params->local_pm != NL80211_MESH_POWER_UNKNOWN)
+			sta->mesh_pm = params->local_pm;
+		else
+			sta->mesh_pm = rwnx_vif->ap.next_mesh_pm;
+		rwnx_update_mesh_power_mode(rwnx_vif);
+
+		for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
+			int uapsd_bit = rwnx_hwq2uapsd[rwnx_tid2hwq[tid]];
+			if (params->uapsd_queues & uapsd_bit)
+				sta->uapsd_tids |= 1 << tid;
+			else
+				sta->uapsd_tids &= ~(1 << tid);
+		}
+		memcpy(sta->mac_addr, mac, ETH_ALEN);
 #ifdef CONFIG_DEBUG_FS
-            rwnx_dbgfs_register_rc_stat(rwnx_hw, sta);
-#endif
-            /* Ensure that we won't process PS change or channel switch ind*/
-            spin_lock_bh(&rwnx_hw->cb_lock);
-            rwnx_txq_sta_init(rwnx_hw, sta, rwnx_txq_vif_get_status(rwnx_vif));
-            list_add_tail(&sta->list, &rwnx_vif->ap.sta_list);
-            sta->valid = true;
-            rwnx_ps_bh_enable(rwnx_hw, sta, sta->ps.active || me_sta_add_cfm.pm_state);
-            spin_unlock_bh(&rwnx_hw->cb_lock);
-
-            error = 0;
-            if(atomic_read(&rwnx_hw->sta_flowctrl[sta->sta_idx].tx_pending_cnt) > 0)
-                AICWFDBG(LOGDEBUG, "sta idx %d fc error %d.\n", sta->sta_idx, atomic_read(&rwnx_hw->sta_flowctrl[sta->sta_idx].tx_pending_cnt));
-
-            if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP || rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
-                struct station_info sinfo;
-                memset(&sinfo, 0, sizeof(struct station_info));
-                sinfo.assoc_req_ies = NULL;
-                sinfo.assoc_req_ies_len = 0;
-                #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
-                sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
-                #endif
-		        cfg80211_new_sta(rwnx_vif->ndev, sta->mac_addr, &sinfo, GFP_KERNEL);
-            }
+		rwnx_dbgfs_register_rc_stat(rwnx_hw, sta);
+#endif
+		/* Ensure that we won't process PS change or channel switch ind*/
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_txq_sta_init(rwnx_hw, sta,
+				  rwnx_txq_vif_get_status(rwnx_vif));
+		list_add_tail(&sta->list, &rwnx_vif->ap.sta_list);
+		sta->valid = true;
+		rwnx_ps_bh_enable(rwnx_hw, sta,
+				  sta->ps.active || me_sta_add_cfm.pm_state);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+
+		error = 0;
+		if (atomic_read(&rwnx_hw->sta_flowctrl[sta->sta_idx]
+					 .tx_pending_cnt) > 0)
+			AICWFDBG(
+				LOGDEBUG, "sta idx %d fc error %d.\n",
+				sta->sta_idx,
+				atomic_read(&rwnx_hw->sta_flowctrl[sta->sta_idx]
+						     .tx_pending_cnt));
+
+		if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP ||
+		    rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
+			struct station_info sinfo;
+			memset(&sinfo, 0, sizeof(struct station_info));
+			sinfo.assoc_req_ies = NULL;
+			sinfo.assoc_req_ies_len = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
+			sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
+#endif
+			cfg80211_new_sta(rwnx_vif->ndev, sta->mac_addr, &sinfo,
+					 GFP_KERNEL);
+		}
 #ifdef CONFIG_RWNX_BFMER
-            if (rwnx_hw->mod_params->bfmer)
-                rwnx_send_bfmer_enable(rwnx_hw, sta, params->vht_capa);
+		if (rwnx_hw->mod_params->bfmer)
+			rwnx_send_bfmer_enable(rwnx_hw, sta, params->vht_capa);
 
-            rwnx_mu_group_sta_init(sta, params->vht_capa);
+		rwnx_mu_group_sta_init(sta, params->vht_capa);
 #endif /* CONFIG_RWNX_BFMER */
 
-            #define PRINT_STA_FLAG(f)                               \
-                (params->sta_flags_set & BIT(NL80211_STA_FLAG_##f) ? "["#f"]" : "")
-
-            netdev_info(dev, "Add sta %d (%pM) flags=%s%s%s%s%s%s%s",
-                        sta->sta_idx, mac,
-                        PRINT_STA_FLAG(AUTHORIZED),
-                        PRINT_STA_FLAG(SHORT_PREAMBLE),
-                        PRINT_STA_FLAG(WME),
-                        PRINT_STA_FLAG(MFP),
-                        PRINT_STA_FLAG(AUTHENTICATED),
-                        PRINT_STA_FLAG(TDLS_PEER),
-                        PRINT_STA_FLAG(ASSOCIATED));
-            #undef PRINT_STA_FLAG
-            break;
-        }
-        default:
-            error = -EBUSY;
-            break;
-    }
+#define PRINT_STA_FLAG(f) \
+	(params->sta_flags_set & BIT(NL80211_STA_FLAG_##f) ? "[" #f "]" : "")
+
+		netdev_info(dev, "Add sta %d (%pM) flags=%s%s%s%s%s%s%s",
+			    sta->sta_idx, mac, PRINT_STA_FLAG(AUTHORIZED),
+			    PRINT_STA_FLAG(SHORT_PREAMBLE), PRINT_STA_FLAG(WME),
+			    PRINT_STA_FLAG(MFP), PRINT_STA_FLAG(AUTHENTICATED),
+			    PRINT_STA_FLAG(TDLS_PEER),
+			    PRINT_STA_FLAG(ASSOCIATED));
+#undef PRINT_STA_FLAG
+		break;
+	}
+	default:
+		error = -EBUSY;
+		break;
+	}
 
-    rwnx_hw->adding_sta = false;
+	rwnx_hw->adding_sta = false;
 
-    return error;
+	return error;
 }
 
 /**
  * @del_station: Remove a station
  */
 static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
-                                            struct net_device *dev,
+					    struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-		u8 *mac
+					    u8 *mac
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))
-		const u8 *mac
+					    const u8 *mac
 #else
-		struct station_del_parameters *params
+					    struct station_del_parameters *params
 #endif
 )
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_sta *cur, *tmp;
-    int error = 0, found = 0;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_sta *cur, *tmp;
+	int error = 0, found = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-    const u8 *mac = NULL;
+	const u8 *mac = NULL;
 #endif
 #ifdef AICWF_RX_REORDER
-    struct reord_ctrl_info *reord_info, *reord_tmp;
-    u8 *macaddr;
-    struct aicwf_rx_priv *rx_priv;
+	struct reord_ctrl_info *reord_info, *reord_tmp;
+	u8 *macaddr;
+	struct aicwf_rx_priv *rx_priv;
 #endif
 
-    //RWNX_DBG(RWNX_FN_ENTRY_STR);
-    AICWFDBG(LOGDEBUG ,"%s: %pM\n", __func__, mac);
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-    if (params)
-        mac = params->mac;
+	if (params)
+		mac = params->mac;
 #endif
+	AICWFDBG(LOGDEBUG, "%s: %pM\n", __func__, mac);
 
 	do {
 		spin_lock_bh(&rwnx_hw->cb_lock);
-		if(list_empty(&rwnx_vif->ap.sta_list)) {
+		if (list_empty(&rwnx_vif->ap.sta_list)) {
 			spin_unlock_bh(&rwnx_hw->cb_lock);
 			break;
 		}
 
-	    list_for_each_entry_safe(cur, tmp, &rwnx_vif->ap.sta_list, list) {
-	        if ((!mac) || (!memcmp(cur->mac_addr, mac, ETH_ALEN)))  {
+		list_for_each_entry_safe(cur, tmp, &rwnx_vif->ap.sta_list,
+					 list) {
+			if ((!mac) || (!memcmp(cur->mac_addr, mac, ETH_ALEN))) {
 				found = 1;
 				break;
-	    	}
-	    }
-
-		if(found) {
-            		cur->ps.active = false;
-            		cur->valid = false;
-            		list_del(&cur->list);
-        	}
+			}
+		}
+
+		if (found) {
+			cur->ps.active = false;
+			cur->valid = false;
+			list_del(&cur->list);
+		}
 		spin_unlock_bh(&rwnx_hw->cb_lock);
 
-		if(found) {
-			netdev_info(dev, "Del sta %d (%pM)", cur->sta_idx, cur->mac_addr);
+		if (found) {
+			netdev_info(dev, "Del sta %d (%pM)", cur->sta_idx,
+				    cur->mac_addr);
 			if (cur->vif_idx != cur->vlan_idx) {
 				struct rwnx_vif *vlan_vif;
 				vlan_vif = rwnx_hw->vif_table[cur->vlan_idx];
 				if (vlan_vif->up) {
-					if ((RWNX_VIF_TYPE(vlan_vif) == NL80211_IFTYPE_AP_VLAN) &&
-						(vlan_vif->use_4addr)) {
+					if ((RWNX_VIF_TYPE(vlan_vif) ==
+					     NL80211_IFTYPE_AP_VLAN) &&
+					    (vlan_vif->use_4addr)) {
 						vlan_vif->ap_vlan.sta_4a = NULL;
 					} else {
-						WARN(1, "Deleting sta belonging to VLAN other than AP_VLAN 4A");
+						WARN(1,
+						     "Deleting sta belonging to VLAN other than AP_VLAN 4A");
 					}
 				}
 			}
-            		if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP || rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
-                		cfg80211_del_sta(rwnx_vif->ndev, cur->mac_addr, GFP_KERNEL);
-            		}
+			if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP ||
+			    rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
+				cfg80211_del_sta(rwnx_vif->ndev, cur->mac_addr,
+						 GFP_KERNEL);
+			}
 
 #ifdef AICWF_RX_REORDER
 #ifdef AICWF_SDIO_SUPPORT
@@ -4532,19 +3441,35 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
 #else
 			rx_priv = rwnx_hw->usbdev->rx_priv;
 #endif
-			if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-				BUG();//should be other function
-			}
-			else if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)){
+			if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) ||
+			    (rwnx_vif->wdev.iftype ==
+			     NL80211_IFTYPE_P2P_CLIENT)) {
+				BUG(); //should be other function
+			} else if ((rwnx_vif->wdev.iftype ==
+				    NL80211_IFTYPE_AP) ||
+				   (rwnx_vif->wdev.iftype ==
+				    NL80211_IFTYPE_P2P_GO)) {
 				macaddr = cur->mac_addr;
-				AICWFDBG(LOGINFO, "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0],macaddr[1],macaddr[2], \
-									   macaddr[3],macaddr[4],macaddr[5]);
-				list_for_each_entry_safe(reord_info, reord_tmp,
+				AICWFDBG(LOGINFO,
+					 "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n",
+					 macaddr[0], macaddr[1], macaddr[2],
+					 macaddr[3], macaddr[4], macaddr[5]);
+				list_for_each_entry_safe(
+					reord_info, reord_tmp,
 					&rx_priv->stas_reord_list, list) {
-                    			AICWFDBG(LOGINFO, "reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0],reord_info->mac_addr[1],reord_info->mac_addr[2], \
-										   reord_info->mac_addr[3],reord_info->mac_addr[4],reord_info->mac_addr[5]);
-					if (!memcmp(reord_info->mac_addr, macaddr, 6)) {
-						reord_deinit_sta(rx_priv, reord_info);
+					AICWFDBG(
+						LOGINFO,
+						"reord_mac:%x,%x,%x,%x,%x,%x\r\n",
+						reord_info->mac_addr[0],
+						reord_info->mac_addr[1],
+						reord_info->mac_addr[2],
+						reord_info->mac_addr[3],
+						reord_info->mac_addr[4],
+						reord_info->mac_addr[5]);
+					if (!memcmp(reord_info->mac_addr,
+						    macaddr, 6)) {
+						reord_deinit_sta(rx_priv,
+								 reord_info);
 						break;
 					}
 				}
@@ -4552,7 +3477,8 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
 #endif
 
 			rwnx_txq_sta_deinit(rwnx_hw, cur);
-			error = rwnx_send_me_sta_del(rwnx_hw, cur->sta_idx, false);
+			error = rwnx_send_me_sta_del(rwnx_hw, cur->sta_idx,
+						     false);
 			if ((error != 0) && (error != -EPIPE))
 				return error;
 
@@ -4567,22 +3493,22 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
 #endif
 		}
 
-		if(mac)
+		if (mac)
 			break;
-	}	while (1);
+	} while (1);
 
-    rwnx_update_mesh_power_mode(rwnx_vif);
+	rwnx_update_mesh_power_mode(rwnx_vif);
 
-	if(!found && mac != NULL)
+	if (!found && mac != NULL)
 		return -ENOENT;
 	else
-    	return 0;
+		return 0;
 }
 
-
 void apm_staloss_work_process(struct work_struct *work)
 {
-	struct rwnx_hw *rwnx_hw = container_of(work, struct rwnx_hw, apmStalossWork);
+	struct rwnx_hw *rwnx_hw =
+		container_of(work, struct rwnx_hw, apmStalossWork);
 	struct rwnx_sta *cur, *tmp;
 	int error = 0;
 
@@ -4592,24 +3518,26 @@ void apm_staloss_work_process(struct work_struct *work)
 	struct aicwf_rx_priv *rx_priv;
 #endif
 	struct rwnx_vif *rwnx_vif;
-    bool_l found = false;
+	bool_l found = false;
 	const u8 *mac = rwnx_hw->sta_mac_addr;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    // Look for VIF entry
-    list_for_each_entry(rwnx_vif, &rwnx_hw->vifs, list) {
-        if (rwnx_vif->vif_index == rwnx_hw->apm_vif_idx) {
-            found = true;
-            break;
-        }
-    }
+	// Look for VIF entry
+	list_for_each_entry(rwnx_vif, &rwnx_hw->vifs, list) {
+		if (rwnx_vif->vif_index == rwnx_hw->apm_vif_idx) {
+			found = true;
+			break;
+		}
+	}
 
-	AICWFDBG(LOGINFO, "apm vif idx=%d, found=%d, mac addr=%pM\n", rwnx_hw->apm_vif_idx, found, mac);
-    if (!found || !rwnx_vif || (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_AP && RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_GO))
-    {
-        return;
-    }
+	AICWFDBG(LOGINFO, "apm vif idx=%d, found=%d, mac addr=%pM\n",
+		 rwnx_hw->apm_vif_idx, found, mac);
+	if (!found || !rwnx_vif ||
+	    (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_AP &&
+	     RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_GO)) {
+		return;
+	}
 
 	found = false;
 	spin_lock_bh(&rwnx_hw->cb_lock);
@@ -4619,28 +3547,31 @@ void apm_staloss_work_process(struct work_struct *work)
 			break;
 		}
 	}
-        if(found) {
+	if (found) {
 		cur->ps.active = false;
-        	cur->valid = false;
-	        list_del(&cur->list);
+		cur->valid = false;
+		list_del(&cur->list);
 	}
 	spin_unlock_bh(&rwnx_hw->cb_lock);
 
-	if(found) {
-		netdev_info(rwnx_vif->ndev, "Del sta %d (%pM)", cur->sta_idx, cur->mac_addr);
+	if (found) {
+		netdev_info(rwnx_vif->ndev, "Del sta %d (%pM)", cur->sta_idx,
+			    cur->mac_addr);
 		if (cur->vif_idx != cur->vlan_idx) {
 			struct rwnx_vif *vlan_vif;
 			vlan_vif = rwnx_hw->vif_table[cur->vlan_idx];
 			if (vlan_vif->up) {
-				if ((RWNX_VIF_TYPE(vlan_vif) == NL80211_IFTYPE_AP_VLAN) &&
-					(vlan_vif->use_4addr)) {
+				if ((RWNX_VIF_TYPE(vlan_vif) ==
+				     NL80211_IFTYPE_AP_VLAN) &&
+				    (vlan_vif->use_4addr)) {
 					vlan_vif->ap_vlan.sta_4a = NULL;
 				} else {
-					WARN(1, "Deleting sta belonging to VLAN other than AP_VLAN 4A");
+					WARN(1,
+					     "Deleting sta belonging to VLAN other than AP_VLAN 4A");
 				}
 			}
 		}
-		   // if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP || rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
+		// if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP || rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {
 		//		cfg80211_del_sta(rwnx_vif->ndev, cur->mac_addr, GFP_KERNEL);
 		//	}
 
@@ -4650,17 +3581,28 @@ void apm_staloss_work_process(struct work_struct *work)
 #else
 		rx_priv = rwnx_hw->usbdev->rx_priv;
 #endif
-		if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-			BUG();//should be other function
-		} else if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)) {
+		if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) ||
+		    (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
+			BUG(); //should be other function
+		} else if ((rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) ||
+			   (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)) {
 			macaddr = cur->mac_addr;
-			AICWFDBG(LOGINFO, "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0], macaddr[1], macaddr[2], \
-								   macaddr[3], macaddr[4], macaddr[5]);
+			AICWFDBG(LOGINFO,
+				 "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n",
+				 macaddr[0], macaddr[1], macaddr[2], macaddr[3],
+				 macaddr[4], macaddr[5]);
 			//spin_lock_bh(&rx_priv->stas_reord_lock);
 			list_for_each_entry_safe(reord_info, reord_tmp,
-				&rx_priv->stas_reord_list, list) {
-				AICWFDBG(LOGINFO, "reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0], reord_info->mac_addr[1], reord_info->mac_addr[2], \
-									   reord_info->mac_addr[3], reord_info->mac_addr[4], reord_info->mac_addr[5]);
+						 &rx_priv->stas_reord_list,
+						 list) {
+				AICWFDBG(LOGINFO,
+					 "reord_mac:%x,%x,%x,%x,%x,%x\r\n",
+					 reord_info->mac_addr[0],
+					 reord_info->mac_addr[1],
+					 reord_info->mac_addr[2],
+					 reord_info->mac_addr[3],
+					 reord_info->mac_addr[4],
+					 reord_info->mac_addr[5]);
 				if (!memcmp(reord_info->mac_addr, macaddr, 6)) {
 					reord_deinit_sta(rx_priv, reord_info);
 					break;
@@ -4681,11 +3623,10 @@ void apm_staloss_work_process(struct work_struct *work)
 		rwnx_mu_group_sta_del(rwnx_hw, cur);
 #endif /* CONFIG_RWNX_BFMER */
 
-
 #ifdef CONFIG_DEBUG_FS
 		rwnx_dbgfs_unregister_rc_stat(rwnx_hw, cur);
 #endif
-	}else {
+	} else {
 		printk("sta not found: %pM\n", mac);
 		return;
 	}
@@ -4693,40 +3634,49 @@ void apm_staloss_work_process(struct work_struct *work)
 	rwnx_update_mesh_power_mode(rwnx_vif);
 }
 
-
 void apm_probe_sta_work_process(struct work_struct *work)
 {
-       struct apm_probe_sta *probe_sta = container_of(work, struct apm_probe_sta, apmprobestaWork);
-       struct rwnx_vif *rwnx_vif = container_of(probe_sta, struct rwnx_vif, sta_probe);
-       bool found = false;
-       struct rwnx_sta *cur, *tmp;
+	struct apm_probe_sta *probe_sta =
+		container_of(work, struct apm_probe_sta, apmprobestaWork);
+	struct rwnx_vif *rwnx_vif =
+		container_of(probe_sta, struct rwnx_vif, sta_probe);
+	bool found = false;
+	struct rwnx_sta *cur, *tmp;
 
-       u8 *mac = rwnx_vif->sta_probe.sta_mac_addr;
+	u8 *mac = rwnx_vif->sta_probe.sta_mac_addr;
 
-       RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-	   spin_lock_bh(&rwnx_vif->rwnx_hw->cb_lock);
-       list_for_each_entry_safe(cur, tmp, &rwnx_vif->ap.sta_list, list) {
-               if (!memcmp(cur->mac_addr, mac, ETH_ALEN)) {
-                       found = true;
-                       break;
-               }
-       }
-	   spin_unlock_bh(&rwnx_vif->rwnx_hw->cb_lock);
+	spin_lock_bh(&rwnx_vif->rwnx_hw->cb_lock);
+	list_for_each_entry_safe(cur, tmp, &rwnx_vif->ap.sta_list, list) {
+		if (!memcmp(cur->mac_addr, mac, ETH_ALEN)) {
+			found = true;
+			break;
+		}
+	}
+	spin_unlock_bh(&rwnx_vif->rwnx_hw->cb_lock);
 
-       printk("sta %pM found = %d\n", mac, found);
+	printk("sta %pM found = %d\n", mac, found);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0)
-       if(found)
-               cfg80211_probe_status(rwnx_vif->ndev, mac, (u64)rwnx_vif->sta_probe.probe_id, 1, 0, false, GFP_ATOMIC);
-       else
-               cfg80211_probe_status(rwnx_vif->ndev, mac, (u64)rwnx_vif->sta_probe.probe_id, 0, 0, false, GFP_ATOMIC);
+	if (found)
+		cfg80211_probe_status(rwnx_vif->ndev, mac,
+				      (u64)rwnx_vif->sta_probe.probe_id, 1, 0,
+				      false, GFP_ATOMIC);
+	else
+		cfg80211_probe_status(rwnx_vif->ndev, mac,
+				      (u64)rwnx_vif->sta_probe.probe_id, 0, 0,
+				      false, GFP_ATOMIC);
 #else
-       if(found)
-                cfg80211_probe_status(rwnx_vif->ndev, mac, (u64)rwnx_vif->sta_probe.probe_id, 1, GFP_ATOMIC);
-        else
-                cfg80211_probe_status(rwnx_vif->ndev, mac, (u64)rwnx_vif->sta_probe.probe_id, 0, GFP_ATOMIC);
+	if (found)
+		cfg80211_probe_status(rwnx_vif->ndev, mac,
+				      (u64)rwnx_vif->sta_probe.probe_id, 1,
+				      GFP_ATOMIC);
+	else
+		cfg80211_probe_status(rwnx_vif->ndev, mac,
+				      (u64)rwnx_vif->sta_probe.probe_id, 0,
+				      GFP_ATOMIC);
 #endif
-       rwnx_vif->sta_probe.probe_id ++;
+	rwnx_vif->sta_probe.probe_id++;
 }
 
 /**
@@ -4736,302 +3686,323 @@ void apm_probe_sta_work_process(struct work_struct *work)
  *	them, also against the existing state! Drivers must call
  *	cfg80211_check_station_change() to validate the information.
  */
-static int rwnx_cfg80211_change_station(struct wiphy *wiphy, struct net_device *dev,
+static int rwnx_cfg80211_change_station(struct wiphy *wiphy,
+					struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-	u8 *mac,
+					u8 *mac,
 #else
-	const u8 *mac,
+					const u8 *mac,
 #endif
-	struct station_parameters *params)
+					struct station_parameters *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct rwnx_sta *sta;
-
-    sta = rwnx_get_sta(rwnx_hw, mac);
-    if (!sta)
-    {
-        /* Add the TDLS station */
-        if (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))
-        {
-            struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-            struct me_sta_add_cfm me_sta_add_cfm;
-            int error = 0;
-
-            /* Indicate we are in a STA addition process - This will allow handling
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_sta *sta;
+
+	sta = rwnx_get_sta(rwnx_hw, mac);
+	if (!sta) {
+		/* Add the TDLS station */
+		if (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) {
+			struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+			struct me_sta_add_cfm me_sta_add_cfm;
+			int error = 0;
+
+			/* Indicate we are in a STA addition process - This will allow handling
              * potential PS mode change indications correctly
              */
-            rwnx_hw->adding_sta = true;
-
-            /* Forward the information to the LMAC */
-            if ((error = rwnx_send_me_sta_add(rwnx_hw, params, mac, rwnx_vif->vif_index,
-                                              &me_sta_add_cfm)))
-                return error;
-
-            // Check the status
-            switch (me_sta_add_cfm.status)
-            {
-                case CO_OK:
-                {
-                    int tid;
-                    sta = &rwnx_hw->sta_table[me_sta_add_cfm.sta_idx];
-                    sta->aid = params->aid;
-                    sta->sta_idx = me_sta_add_cfm.sta_idx;
-                    sta->ch_idx = rwnx_vif->ch_index;
-                    sta->vif_idx = rwnx_vif->vif_index;
-                    sta->vlan_idx = sta->vif_idx;
-                    sta->qos = (params->sta_flags_set & BIT(NL80211_STA_FLAG_WME)) != 0;
+			rwnx_hw->adding_sta = true;
+
+			/* Forward the information to the LMAC */
+			if ((error = rwnx_send_me_sta_add(rwnx_hw, params, mac,
+							  rwnx_vif->vif_index,
+							  &me_sta_add_cfm)))
+				return error;
+
+			// Check the status
+			switch (me_sta_add_cfm.status) {
+			case CO_OK: {
+				int tid;
+				sta = &rwnx_hw->sta_table[me_sta_add_cfm.sta_idx];
+				sta->aid = params->aid;
+				sta->sta_idx = me_sta_add_cfm.sta_idx;
+				sta->ch_idx = rwnx_vif->ch_index;
+				sta->vif_idx = rwnx_vif->vif_index;
+				sta->vlan_idx = sta->vif_idx;
+				sta->qos = (params->sta_flags_set &
+					    BIT(NL80211_STA_FLAG_WME)) != 0;
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-                sta->ht = params->link_sta_params.ht_capa ? 1 : 0;
-                sta->vht = params->link_sta_params.vht_capa ? 1 : 0;
+				sta->ht = params->link_sta_params.ht_capa ? 1 :
+									    0;
+				sta->vht = params->link_sta_params.vht_capa ?
+						   1 :
+						   0;
 #else
-                sta->ht = params->ht_capa ? 1 : 0;
-                sta->vht = params->vht_capa ? 1 : 0;
-#endif
-                    sta->acm = 0;
-                    for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
-                        int uapsd_bit = rwnx_hwq2uapsd[rwnx_tid2hwq[tid]];
-                        if (params->uapsd_queues & uapsd_bit)
-                            sta->uapsd_tids |= 1 << tid;
-                        else
-                            sta->uapsd_tids &= ~(1 << tid);
-                    }
-                    memcpy(sta->mac_addr, mac, ETH_ALEN);
+				sta->ht = params->ht_capa ? 1 : 0;
+				sta->vht = params->vht_capa ? 1 : 0;
+#endif
+				sta->acm = 0;
+				for (tid = 0; tid < NX_NB_TXQ_PER_STA; tid++) {
+					int uapsd_bit =
+						rwnx_hwq2uapsd[rwnx_tid2hwq[tid]];
+					if (params->uapsd_queues & uapsd_bit)
+						sta->uapsd_tids |= 1 << tid;
+					else
+						sta->uapsd_tids &= ~(1 << tid);
+				}
+				memcpy(sta->mac_addr, mac, ETH_ALEN);
 #ifdef CONFIG_DEBUG_FS
-                    rwnx_dbgfs_register_rc_stat(rwnx_hw, sta);
-#endif
-                    /* Ensure that we won't process PS change or channel switch ind*/
-                    spin_lock_bh(&rwnx_hw->cb_lock);
-                    rwnx_txq_sta_init(rwnx_hw, sta, rwnx_txq_vif_get_status(rwnx_vif));
-                    if (rwnx_vif->tdls_status == TDLS_SETUP_RSP_TX) {
-                        rwnx_vif->tdls_status = TDLS_LINK_ACTIVE;
-                        sta->tdls.initiator = true;
-                        sta->tdls.active = true;
-                    }
-                    /* Set TDLS channel switch capability */
-                    if ((params->ext_capab[3] & WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH) &&
-                        !rwnx_vif->tdls_chsw_prohibited)
-                        sta->tdls.chsw_allowed = true;
-                    rwnx_vif->sta.tdls_sta = sta;
-                    sta->valid = true;
-                    spin_unlock_bh(&rwnx_hw->cb_lock);
+				rwnx_dbgfs_register_rc_stat(rwnx_hw, sta);
+#endif
+				/* Ensure that we won't process PS change or channel switch ind*/
+				spin_lock_bh(&rwnx_hw->cb_lock);
+				rwnx_txq_sta_init(
+					rwnx_hw, sta,
+					rwnx_txq_vif_get_status(rwnx_vif));
+				if (rwnx_vif->tdls_status ==
+				    TDLS_SETUP_RSP_TX) {
+					rwnx_vif->tdls_status =
+						TDLS_LINK_ACTIVE;
+					sta->tdls.initiator = true;
+					sta->tdls.active = true;
+				}
+				/* Set TDLS channel switch capability */
+				if ((params->ext_capab[3] &
+				     WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH) &&
+				    !rwnx_vif->tdls_chsw_prohibited)
+					sta->tdls.chsw_allowed = true;
+				rwnx_vif->sta.tdls_sta = sta;
+				sta->valid = true;
+				spin_unlock_bh(&rwnx_hw->cb_lock);
 #ifdef CONFIG_RWNX_BFMER
-                    if (rwnx_hw->mod_params->bfmer)
-                        rwnx_send_bfmer_enable(rwnx_hw, sta, params->vht_capa);
+				if (rwnx_hw->mod_params->bfmer)
+					rwnx_send_bfmer_enable(
+						rwnx_hw, sta, params->vht_capa);
 
-                    rwnx_mu_group_sta_init(sta, NULL);
+				rwnx_mu_group_sta_init(sta, NULL);
 #endif /* CONFIG_RWNX_BFMER */
 
-                    #define PRINT_STA_FLAG(f)                               \
-                        (params->sta_flags_set & BIT(NL80211_STA_FLAG_##f) ? "["#f"]" : "")
-
-                    netdev_info(dev, "Add %s TDLS sta %d (%pM) flags=%s%s%s%s%s%s%s",
-                                sta->tdls.initiator ? "initiator" : "responder",
-                                sta->sta_idx, mac,
-                                PRINT_STA_FLAG(AUTHORIZED),
-                                PRINT_STA_FLAG(SHORT_PREAMBLE),
-                                PRINT_STA_FLAG(WME),
-                                PRINT_STA_FLAG(MFP),
-                                PRINT_STA_FLAG(AUTHENTICATED),
-                                PRINT_STA_FLAG(TDLS_PEER),
-                                PRINT_STA_FLAG(ASSOCIATED));
-                    #undef PRINT_STA_FLAG
-
-                    break;
-                }
-                default:
-                    error = -EBUSY;
-                    break;
-            }
-
-            rwnx_hw->adding_sta = false;
-        } else  {
-            return -EINVAL;
-        }
-    }
+#define PRINT_STA_FLAG(f) \
+	(params->sta_flags_set & BIT(NL80211_STA_FLAG_##f) ? "[" #f "]" : "")
+
+				netdev_info(
+					dev,
+					"Add %s TDLS sta %d (%pM) flags=%s%s%s%s%s%s%s",
+					sta->tdls.initiator ? "initiator" :
+							      "responder",
+					sta->sta_idx, mac,
+					PRINT_STA_FLAG(AUTHORIZED),
+					PRINT_STA_FLAG(SHORT_PREAMBLE),
+					PRINT_STA_FLAG(WME),
+					PRINT_STA_FLAG(MFP),
+					PRINT_STA_FLAG(AUTHENTICATED),
+					PRINT_STA_FLAG(TDLS_PEER),
+					PRINT_STA_FLAG(ASSOCIATED));
+#undef PRINT_STA_FLAG
+
+				break;
+			}
+			default:
+				error = -EBUSY;
+				break;
+			}
 
-    if (params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED))
-        rwnx_send_me_set_control_port_req(rwnx_hw,
-                (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED)) != 0,
-                sta->sta_idx);
+			rwnx_hw->adding_sta = false;
+		} else {
+			return -EINVAL;
+		}
+	}
 
-    if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MESH_POINT) {
-        if (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE) {
-            if (params->plink_state < NUM_NL80211_PLINK_STATES) {
-                rwnx_send_mesh_peer_update_ntf(rwnx_hw, vif, sta->sta_idx, params->plink_state);
-            }
-        }
+	if (params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED))
+		rwnx_send_me_set_control_port_req(
+			rwnx_hw,
+			(params->sta_flags_set &
+			 BIT(NL80211_STA_FLAG_AUTHORIZED)) != 0,
+			sta->sta_idx);
+
+	if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MESH_POINT) {
+		if (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE) {
+			if (params->plink_state < NUM_NL80211_PLINK_STATES) {
+				rwnx_send_mesh_peer_update_ntf(
+					rwnx_hw, vif, sta->sta_idx,
+					params->plink_state);
+			}
+		}
 
-        if (params->local_pm != NL80211_MESH_POWER_UNKNOWN) {
-            sta->mesh_pm = params->local_pm;
-            rwnx_update_mesh_power_mode(vif);
-        }
-    }
+		if (params->local_pm != NL80211_MESH_POWER_UNKNOWN) {
+			sta->mesh_pm = params->local_pm;
+			rwnx_update_mesh_power_mode(vif);
+		}
+	}
 
-    if (params->vlan) {
-        uint8_t vlan_idx;
-
-        vif = netdev_priv(params->vlan);
-        vlan_idx = vif->vif_index;
-
-        if (sta->vlan_idx != vlan_idx) {
-            struct rwnx_vif *old_vif;
-            old_vif = rwnx_hw->vif_table[sta->vlan_idx];
-            rwnx_txq_sta_switch_vif(sta, old_vif, vif);
-            sta->vlan_idx = vlan_idx;
-
-            if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_AP_VLAN) &&
-                (vif->use_4addr)) {
-                WARN((vif->ap_vlan.sta_4a),
-                     "4A AP_VLAN interface with more than one sta");
-                vif->ap_vlan.sta_4a = sta;
-            }
-
-            if ((RWNX_VIF_TYPE(old_vif) == NL80211_IFTYPE_AP_VLAN) &&
-                (old_vif->use_4addr)) {
-                old_vif->ap_vlan.sta_4a = NULL;
-            }
-        }
-    }
+	if (params->vlan) {
+		uint8_t vlan_idx;
 
-    return 0;
+		vif = netdev_priv(params->vlan);
+		vlan_idx = vif->vif_index;
+
+		if (sta->vlan_idx != vlan_idx) {
+			struct rwnx_vif *old_vif;
+			old_vif = rwnx_hw->vif_table[sta->vlan_idx];
+			rwnx_txq_sta_switch_vif(sta, old_vif, vif);
+			sta->vlan_idx = vlan_idx;
+
+			if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_AP_VLAN) &&
+			    (vif->use_4addr)) {
+				WARN((vif->ap_vlan.sta_4a),
+				     "4A AP_VLAN interface with more than one sta");
+				vif->ap_vlan.sta_4a = sta;
+			}
+
+			if ((RWNX_VIF_TYPE(old_vif) ==
+			     NL80211_IFTYPE_AP_VLAN) &&
+			    (old_vif->use_4addr)) {
+				old_vif->ap_vlan.sta_4a = NULL;
+			}
+		}
+	}
+
+	return 0;
 }
 
 /**
  * @start_ap: Start acting in AP mode defined by the parameters.
  */
 static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
-                                  struct cfg80211_ap_settings *settings)
+				  struct cfg80211_ap_settings *settings)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct apm_start_cfm apm_start_cfm;
-    struct rwnx_ipc_elem_var elem;
-    struct rwnx_sta *sta;
-    int error = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct apm_start_cfm apm_start_cfm;
+	struct rwnx_ipc_elem_var elem;
+	struct rwnx_sta *sta;
+	int error = 0;
 
-    INIT_WORK(&rwnx_vif->sta_probe.apmprobestaWork, apm_probe_sta_work_process);
-    rwnx_vif->sta_probe.apmprobesta_wq = create_singlethread_workqueue("apmprobe_wq");
-    if (!rwnx_vif->sta_probe.apmprobesta_wq) {
-	    txrx_err("insufficient memory to create apmprobe_wq.\n");
-	    return -ENOBUFS;
-    }
-    if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)
-	    rwnx_hw->is_p2p_connected = 1;
-    /* Forward the information to the LMAC */
-    if ((error = rwnx_send_apm_start_req(rwnx_hw, rwnx_vif, settings,
-                                         &apm_start_cfm, &elem)))
-        goto end;
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    // Check the status
-    switch (apm_start_cfm.status)
-    {
-        case CO_OK:
-        {
-            u8 txq_status = 0;
-            rwnx_vif->ap.bcmc_index = apm_start_cfm.bcmc_idx;
-            rwnx_vif->ap.flags = 0;
-            #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
-            rwnx_vif->ap.aic_index = 0;
-            #endif
-            sta = &rwnx_hw->sta_table[apm_start_cfm.bcmc_idx];
-            sta->valid = true;
-            sta->aid = 0;
-            sta->sta_idx = apm_start_cfm.bcmc_idx;
-            sta->ch_idx = apm_start_cfm.ch_idx;
-            sta->vif_idx = rwnx_vif->vif_index;
-            sta->qos = false;
-            sta->acm = 0;
-            sta->ps.active = false;
-            rwnx_mu_group_sta_init(sta, NULL);
-            spin_lock_bh(&rwnx_hw->cb_lock);
+	INIT_WORK(&rwnx_vif->sta_probe.apmprobestaWork,
+		  apm_probe_sta_work_process);
+	rwnx_vif->sta_probe.apmprobesta_wq =
+		create_singlethread_workqueue("apmprobe_wq");
+	if (!rwnx_vif->sta_probe.apmprobesta_wq) {
+		txrx_err("insufficient memory to create apmprobe_wq.\n");
+		return -ENOBUFS;
+	}
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)
+		rwnx_hw->is_p2p_connected = 1;
+	/* Forward the information to the LMAC */
+	if ((error = rwnx_send_apm_start_req(rwnx_hw, rwnx_vif, settings,
+					     &apm_start_cfm, &elem)))
+		goto end;
+
+	// Check the status
+	switch (apm_start_cfm.status) {
+	case CO_OK: {
+		u8 txq_status = 0;
+		rwnx_vif->ap.bcmc_index = apm_start_cfm.bcmc_idx;
+		rwnx_vif->ap.flags = 0;
+		rwnx_vif->ap.csa = NULL;
+#if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
+		rwnx_vif->ap.aic_index = 0;
+#endif
+		sta = &rwnx_hw->sta_table[apm_start_cfm.bcmc_idx];
+		sta->valid = true;
+		sta->aid = 0;
+		sta->sta_idx = apm_start_cfm.bcmc_idx;
+		sta->ch_idx = apm_start_cfm.ch_idx;
+		sta->vif_idx = rwnx_vif->vif_index;
+		sta->qos = false;
+		sta->acm = 0;
+		sta->ps.active = false;
+		rwnx_mu_group_sta_init(sta, NULL);
+		spin_lock_bh(&rwnx_hw->cb_lock);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
-	    rwnx_chanctx_link(rwnx_vif, apm_start_cfm.ch_idx,
-                              NULL);
+		rwnx_chanctx_link(rwnx_vif, apm_start_cfm.ch_idx, NULL);
 #else
-            rwnx_chanctx_link(rwnx_vif, apm_start_cfm.ch_idx,
-                              &settings->chandef);
-#endif
-            if (rwnx_hw->cur_chanctx != apm_start_cfm.ch_idx) {
-                txq_status = RWNX_TXQ_STOP_CHAN;
-            }
-            rwnx_txq_vif_init(rwnx_hw, rwnx_vif, txq_status);
-            spin_unlock_bh(&rwnx_hw->cb_lock);
-
-            netif_tx_start_all_queues(dev);
-            netif_carrier_on(dev);
-            error = 0;
-            /* If the AP channel is already the active, we probably skip radar
+		rwnx_chanctx_link(rwnx_vif, apm_start_cfm.ch_idx,
+				  &settings->chandef);
+#endif
+		if (rwnx_hw->cur_chanctx != apm_start_cfm.ch_idx) {
+			txq_status = RWNX_TXQ_STOP_CHAN;
+		}
+		rwnx_txq_vif_init(rwnx_hw, rwnx_vif, txq_status);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+
+		netif_tx_start_all_queues(dev);
+		netif_carrier_on(dev);
+		error = 0;
+		/* If the AP channel is already the active, we probably skip radar
                activation on MM_CHANNEL_SWITCH_IND (unless another vif use this
                ctxt). In anycase retest if radar detection must be activated
              */
-            if (txq_status == 0) {
-                rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
-            }
-            break;
-        }
-        case CO_BUSY:
-            error = -EINPROGRESS;
-            break;
-        case CO_OP_IN_PROGRESS:
-            error = -EALREADY;
-            break;
-        default:
-            error = -EIO;
-            break;
-    }
+		if (txq_status == 0) {
+			rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
+		}
+		break;
+	}
+	case CO_BUSY:
+		error = -EINPROGRESS;
+		break;
+	case CO_OP_IN_PROGRESS:
+		error = -EALREADY;
+		break;
+	default:
+		error = -EIO;
+		break;
+	}
 
-    if (error) {
-        netdev_info(dev, "Failed to start AP (%d)", error);
-    } else {
-        netdev_info(dev, "AP started: ch=%d, bcmc_idx=%d channel=%d bw=%d",
-                    rwnx_vif->ch_index, rwnx_vif->ap.bcmc_index,
-                    ((settings->chandef).chan)->center_freq,
-                    ((settings->chandef).width));
-    }
+	if (error) {
+		netdev_info(dev, "Failed to start AP (%d)", error);
+	} else {
+		netdev_info(dev,
+			    "AP started: ch=%d, bcmc_idx=%d channel=%d bw=%d",
+			    rwnx_vif->ch_index, rwnx_vif->ap.bcmc_index,
+			    ((settings->chandef).chan)->center_freq,
+			    ((settings->chandef).width));
+	}
 
-  end:
-    //rwnx_ipc_elem_var_deallocs(rwnx_hw, &elem);
+end:
+	//rwnx_ipc_elem_var_deallocs(rwnx_hw, &elem);
 
-    return error;
+	return error;
 }
 
-
 /**
  * @change_beacon: Change the beacon parameters for an access point mode
  *	interface. This should reject the call when AP mode wasn't started.
  */
-// for mainline linux 
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
-                                       struct cfg80211_ap_update *params)
+// #if LINUX_VERSION_CODE > KERNEL_VERSION(6, 7, 0)
+#if 1
+static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       struct cfg80211_ap_update *info)
 #else
-static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
-                                       struct cfg80211_beacon_data *info)
+static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy,
+				       struct net_device *dev,
+				       struct cfg80211_beacon_data *info)
 #endif
 {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-    struct cfg80211_beacon_data *info = &params->beacon;
-#endif
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct rwnx_bcn *bcn = &vif->ap.bcn;
-    struct rwnx_ipc_elem_var elem;
-    u8 *buf;
-    int error = 0;
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_bcn *bcn = &vif->ap.bcn;
+	struct rwnx_ipc_elem_var elem;
+	u8 *buf;
+	int error = 0;
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 	//elem init
 	elem.dma_addr = 0;
 
-    // Build the beacon
-    buf = rwnx_build_bcn(bcn, info);
-    if (!buf)
-        return -ENOMEM;
+	// Build the beacon
+// #if LINUX_VERSION_CODE > KERNEL_VERSION(6, 7, 0)
+#if 1
+	buf = rwnx_build_bcn(bcn, &info->beacon);
+#else
+	buf = rwnx_build_bcn(bcn, info);
+#endif
+	if (!buf)
+		return -ENOMEM;
 
-    rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, bcn->len);
+	rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, bcn->len);
 
 #if 0
     // Sync buffer for FW
@@ -5039,63 +4010,64 @@ static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *d
                                           buf, NULL, NULL)))
         return error;
 #endif
-    // Forward the information to the LMAC
-    error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index, elem.dma_addr,
-                                 bcn->len, bcn->head_len, bcn->tim_len, NULL);
+	// Forward the information to the LMAC
+	error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index, elem.dma_addr,
+				     bcn->len, bcn->head_len, bcn->tim_len,
+				     NULL);
 
 #if 0
     rwnx_ipc_elem_var_deallocs(rwnx_hw, &elem);
 #else
 
-
 #endif
-    return error;
+	return error;
 }
 
 /**
  * * @stop_ap: Stop being an AP, including stopping beaconing.
  */
 #if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev, unsigned int link_id)
+static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
+				 unsigned int link_id)
 #else
 static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 #endif
 
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_sta *sta;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_sta *sta;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    netif_tx_stop_all_queues(dev);
-    netif_carrier_off(dev);
+	netif_tx_stop_all_queues(dev);
+	netif_carrier_off(dev);
 
-    if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)
-        rwnx_hw->is_p2p_connected = 0;
-    rwnx_radar_cancel_cac(&rwnx_hw->radar);
-    rwnx_send_apm_stop_req(rwnx_hw, rwnx_vif);
-    spin_lock_bh(&rwnx_hw->cb_lock);
-    rwnx_chanctx_unlink(rwnx_vif);
-    spin_unlock_bh(&rwnx_hw->cb_lock);
+	/* delete any remaining STA*/
+	while (!list_empty(&rwnx_vif->ap.sta_list)) {
+		rwnx_cfg80211_del_station_compat(wiphy, dev, NULL);
+	}
 
-    /* delete any remaining STA*/
-    while (!list_empty(&rwnx_vif->ap.sta_list)) {
-        rwnx_cfg80211_del_station_compat(wiphy, dev, NULL);
-    }
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)
+		rwnx_hw->is_p2p_connected = 0;
+	rwnx_radar_cancel_cac(&rwnx_hw->radar);
+	rwnx_send_apm_stop_req(rwnx_hw, rwnx_vif);
+	spin_lock_bh(&rwnx_hw->cb_lock);
+	rwnx_chanctx_unlink(rwnx_vif);
+	spin_unlock_bh(&rwnx_hw->cb_lock);
 
-    /* delete BC/MC STA */
-    sta = &rwnx_hw->sta_table[rwnx_vif->ap.bcmc_index];
-    rwnx_txq_vif_deinit(rwnx_hw, rwnx_vif);
-    rwnx_del_bcn(&rwnx_vif->ap.bcn);
-    rwnx_del_csa(rwnx_vif);
+	/* delete BC/MC STA */
+	sta = &rwnx_hw->sta_table[rwnx_vif->ap.bcmc_index];
+	rwnx_txq_vif_deinit(rwnx_hw, rwnx_vif);
+	rwnx_del_bcn(&rwnx_vif->ap.bcn);
+	rwnx_del_csa(rwnx_vif);
 
-    flush_workqueue(rwnx_vif->sta_probe.apmprobesta_wq);
-    destroy_workqueue(rwnx_vif->sta_probe.apmprobesta_wq);
+	flush_workqueue(rwnx_vif->sta_probe.apmprobesta_wq);
+	destroy_workqueue(rwnx_vif->sta_probe.apmprobesta_wq);
 
-    netdev_info(dev, "AP Stopped");
+	netdev_info(dev, "AP Stopped");
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -5120,57 +4092,62 @@ cfg80211_chandef_identical(const struct cfg80211_chan_def *chandef1,
 #endif
 
 static int rwnx_cfg80211_set_monitor_channel(struct wiphy *wiphy,
-                                             struct cfg80211_chan_def *chandef)
+					     struct cfg80211_chan_def *chandef)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif;
-    struct me_config_monitor_cfm cfm;
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    if (rwnx_hw->monitor_vif == RWNX_INVALID_VIF)
-        return -EINVAL;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif;
+	struct me_config_monitor_cfm cfm;
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    rwnx_vif = rwnx_hw->vif_table[rwnx_hw->monitor_vif];
+	if (rwnx_hw->monitor_vif == RWNX_INVALID_VIF)
+		return -EINVAL;
 
-    // Do nothing if monitor interface is already configured with the requested channel
-    if (rwnx_chanctx_valid(rwnx_hw, rwnx_vif->ch_index)) {
-        struct rwnx_chanctx *ctxt;
-        ctxt = &rwnx_vif->rwnx_hw->chanctx_table[rwnx_vif->ch_index];
-        if (chandef && cfg80211_chandef_identical(&ctxt->chan_def, chandef))
-            return 0;
-    }
+	rwnx_vif = rwnx_hw->vif_table[rwnx_hw->monitor_vif];
 
-    // Always send command to firmware. It allows to retrieve channel context index
-    // and its configuration.
-    if (rwnx_send_config_monitor_req(rwnx_hw, chandef, &cfm))
-        return -EIO;
+	// Do nothing if monitor interface is already configured with the requested channel
+	if (rwnx_chanctx_valid(rwnx_hw, rwnx_vif->ch_index)) {
+		struct rwnx_chanctx *ctxt;
+		ctxt = &rwnx_vif->rwnx_hw->chanctx_table[rwnx_vif->ch_index];
+		if (chandef &&
+		    cfg80211_chandef_identical(&ctxt->chan_def, chandef))
+			return 0;
+	}
 
-    // Always re-set channel context info
-    rwnx_chanctx_unlink(rwnx_vif);
+	// Always send command to firmware. It allows to retrieve channel context index
+	// and its configuration.
+	if (rwnx_send_config_monitor_req(rwnx_hw, chandef, &cfm))
+		return -EIO;
 
+	// Always re-set channel context info
+	rwnx_chanctx_unlink(rwnx_vif);
 
+	// If there is also a STA interface not yet connected then monitor interface
+	// will only have a channel context after the connection of the STA interface.
+	if (cfm.chan_index != RWNX_CH_NOT_SET) {
+		struct cfg80211_chan_def mon_chandef;
 
-    // If there is also a STA interface not yet connected then monitor interface
-    // will only have a channel context after the connection of the STA interface.
-    if (cfm.chan_index != RWNX_CH_NOT_SET)
-    {
-        struct cfg80211_chan_def mon_chandef;
+		if (rwnx_hw->vif_started > 1) {
+			// In this case we just want to update the channel context index not
+			// the channel configuration
+			rwnx_chanctx_link(rwnx_vif, cfm.chan_index, NULL);
+			return -EBUSY;
+		}
 
-        if (rwnx_hw->vif_started > 1) {
-            // In this case we just want to update the channel context index not
-            // the channel configuration
-            rwnx_chanctx_link(rwnx_vif, cfm.chan_index, NULL);
-            return -EBUSY;
-        }
+		mon_chandef.chan =
+			ieee80211_get_channel(wiphy, cfm.chan.prim20_freq);
+		mon_chandef.center_freq1 = cfm.chan.center1_freq;
+		mon_chandef.center_freq2 = cfm.chan.center2_freq;
+		mon_chandef.width = chnl2bw[cfm.chan.type];
+		rwnx_chanctx_link(rwnx_vif, cfm.chan_index, &mon_chandef);
+	}
 
-        mon_chandef.chan = ieee80211_get_channel(wiphy, cfm.chan.prim20_freq);
-        mon_chandef.center_freq1 = cfm.chan.center1_freq;
-        mon_chandef.center_freq2 = cfm.chan.center2_freq;
-        mon_chandef.width =  chnl2bw[cfm.chan.type];
-        rwnx_chanctx_link(rwnx_vif, cfm.chan_index, &mon_chandef);
-    }
+	return 0;
+}
 
-    return 0;
+int rwnx_cfg80211_set_monitor_channel_(struct wiphy *wiphy,
+				       struct cfg80211_chan_def *chandef)
+{
+	return rwnx_cfg80211_set_monitor_channel(wiphy, chandef);
 }
 
 /**
@@ -5178,35 +4155,36 @@ static int rwnx_cfg80211_set_monitor_channel(struct wiphy *wiphy,
  *	later passes to cfg80211_probe_status().
  */
 int rwnx_cfg80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
-            const u8 *peer, u64 *cookie)
+			       const u8 *peer, u64 *cookie)
 {
-    //struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct rwnx_sta *sta = NULL;
+	//struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_sta *sta = NULL;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    if((RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_AP) && (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_P2P_GO) &&
-            (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_AP_VLAN))
-            return -EINVAL;
+	if ((RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_AP) &&
+	    (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_P2P_GO) &&
+	    (RWNX_VIF_TYPE(vif) != NL80211_IFTYPE_AP_VLAN))
+		return -EINVAL;
 
 	spin_lock_bh(&vif->rwnx_hw->cb_lock);
-    list_for_each_entry(sta, &vif->ap.sta_list, list){
-        if (sta->valid && ether_addr_equal(sta->mac_addr, peer))
-            break;
-    }
+	list_for_each_entry(sta, &vif->ap.sta_list, list) {
+		if (sta->valid && ether_addr_equal(sta->mac_addr, peer))
+			break;
+	}
 	spin_unlock_bh(&vif->rwnx_hw->cb_lock);
 
-    if (!sta)
-        return -ENOENT;
-
+	if (!sta)
+		return -ENOENT;
 
-    memcpy(vif->sta_probe.sta_mac_addr, peer, 6);
-    queue_work(vif->sta_probe.apmprobesta_wq, &vif->sta_probe.apmprobestaWork);
+	memcpy(vif->sta_probe.sta_mac_addr, peer, 6);
+	queue_work(vif->sta_probe.apmprobesta_wq,
+		   &vif->sta_probe.apmprobestaWork);
 
-    *cookie = vif->sta_probe.probe_id;
+	*cookie = vif->sta_probe.probe_id;
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -5215,12 +4193,12 @@ int rwnx_cfg80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
  *	concurrently with itself.
  */
 void rwnx_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
-                   struct net_device *dev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+				       struct net_device *dev,
 #else
-                   struct wireless_dev *wdev,
+				       struct wireless_dev *wdev,
 #endif
-                   u16 frame_type, bool reg)
+				       u16 frame_type, bool reg)
 {
 }
 
@@ -5232,10 +4210,9 @@ void rwnx_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
  */
 static int rwnx_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
-    return 0;
+	return 0;
 }
 
-
 /**
  * @set_tx_power: set the transmit power according to the parameters,
  *	the power passed is in mBm, to get dBm use MBM_TO_DBM(). The
@@ -5245,47 +4222,48 @@ static int rwnx_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
  */
 static int rwnx_cfg80211_set_tx_power(struct wiphy *wiphy,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
- struct wireless_dev *wdev,
+				      struct wireless_dev *wdev,
 #endif
-                                      enum nl80211_tx_power_setting type, int mbm)
+				      enum nl80211_tx_power_setting type,
+				      int mbm)
 {
-    #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
-    struct wireless_dev *wdev = NULL;
-    #endif
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif;
-    s8 pwr;
-    int res = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+	struct wireless_dev *wdev = NULL;
+#endif
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif;
+	s8 pwr;
+	int res = 0;
 
-    if (type == NL80211_TX_POWER_AUTOMATIC) {
-        pwr = 0x7f;
-    } else {
-        pwr = MBM_TO_DBM(mbm);
-    }
+	if (type == NL80211_TX_POWER_AUTOMATIC) {
+		pwr = 0x7f;
+	} else {
+		pwr = MBM_TO_DBM(mbm);
+	}
 
-    if (wdev) {
-        vif = container_of(wdev, struct rwnx_vif, wdev);
-        res = rwnx_send_set_power(rwnx_hw, vif->vif_index, pwr, NULL);
-    } else {
-        list_for_each_entry(vif, &rwnx_hw->vifs, list) {
-            res = rwnx_send_set_power(rwnx_hw, vif->vif_index, pwr, NULL);
-            if (res)
-                break;
-        }
-    }
+	if (wdev) {
+		vif = container_of(wdev, struct rwnx_vif, wdev);
+		res = rwnx_send_set_power(rwnx_hw, vif->vif_index, pwr, NULL);
+	} else {
+		list_for_each_entry(vif, &rwnx_hw->vifs, list) {
+			res = rwnx_send_set_power(rwnx_hw, vif->vif_index, pwr,
+						  NULL);
+			if (res)
+				break;
+		}
+	}
 
-    return res;
+	return res;
 }
 
-
 /**
  * @set_power_mgmt: set the power save to one of those two modes:
  *  Power-save off
  *  Power-save on - Dynamic mode
  */
 static int rwnx_cfg80211_set_power_mgmt(struct wiphy *wiphy,
-                                        struct net_device *dev,
-                                        bool enabled, int timeout)
+					struct net_device *dev, bool enabled,
+					int timeout)
 {
 #if 0
 
@@ -5309,42 +4287,42 @@ static int rwnx_cfg80211_set_power_mgmt(struct wiphy *wiphy,
 
     return rwnx_send_me_set_ps_mode(rwnx_hw, ps_mode);
 #else
-    return 0;
+	return 0;
 #endif
 }
 
-
-static int rwnx_cfg80211_set_txq_params(struct wiphy *wiphy, struct net_device *dev,
-                                        struct ieee80211_txq_params *params)
+static int rwnx_cfg80211_set_txq_params(struct wiphy *wiphy,
+					struct net_device *dev,
+					struct ieee80211_txq_params *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    u8 hw_queue, aifs, cwmin, cwmax;
-    u32 param;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	u8 hw_queue, aifs, cwmin, cwmax;
+	u32 param;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
-    hw_queue = rwnx_ac2hwq[0][params->queue];
+	hw_queue = rwnx_ac2hwq[0][params->queue];
 #else
-    hw_queue = rwnx_ac2hwq[0][params->ac];
+	hw_queue = rwnx_ac2hwq[0][params->ac];
 #endif
 
-    aifs  = params->aifs;
-    cwmin = fls(params->cwmin);
-    cwmax = fls(params->cwmax);
+	aifs = params->aifs;
+	cwmin = fls(params->cwmin);
+	cwmax = fls(params->cwmax);
 
-    /* Store queue information in general structure */
-    param  = (u32) (aifs << 0);
-    param |= (u32) (cwmin << 4);
-    param |= (u32) (cwmax << 8);
-    param |= (u32) (params->txop) << 12;
+	/* Store queue information in general structure */
+	param = (u32)(aifs << 0);
+	param |= (u32)(cwmin << 4);
+	param |= (u32)(cwmax << 8);
+	param |= (u32)(params->txop) << 12;
 
-    /* Send the MM_SET_EDCA_REQ message to the FW */
-    return rwnx_send_set_edca(rwnx_hw, hw_queue, param, false, rwnx_vif->vif_index);
+	/* Send the MM_SET_EDCA_REQ message to the FW */
+	return rwnx_send_set_edca(rwnx_hw, hw_queue, param, false,
+				  rwnx_vif->vif_index);
 }
 
-
 /**
  * @remain_on_channel: Request the driver to remain awake on the specified
  *	channel for the specified duration to complete an off-channel
@@ -5354,137 +4332,173 @@ static int rwnx_cfg80211_set_txq_params(struct wiphy *wiphy, struct net_device *
  */
 
 static int
-rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
-                            #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-                                struct wireless_dev *wdev,
-                            #else
-                                struct net_device *dev,
-                            #endif
-                                struct ieee80211_channel *chan,
-                            #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
-                                enum nl80211_channel_type channel_type,
-                            #endif
-                                unsigned int duration, u64 *cookie)
+rwnx_cfg80211_remain_on_channel_(struct wiphy *wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				 struct wireless_dev *wdev,
+#else
+				 struct net_device *dev,
+#endif
+				 struct ieee80211_channel *chan,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+				 enum nl80211_channel_type channel_type,
+#endif
+				 unsigned int duration, u64 *cookie,
+				 bool mgmt_roc_flag)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-    struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
+	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
 #else
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct wireless_dev *wdev = &rwnx_vif->wdev;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct wireless_dev *wdev = &rwnx_vif->wdev;
 #endif
-    struct rwnx_roc_elem *roc_elem;
-    struct mm_add_if_cfm add_if_cfm;
-    struct mm_remain_on_channel_cfm roc_cfm;
-    int error;
+	struct rwnx_roc_elem *roc_elem;
+	struct mm_add_if_cfm add_if_cfm;
+	struct mm_remain_on_channel_cfm roc_cfm;
+	int error;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    /* For debug purpose (use ftrace kernel option) */
+	/* For debug purpose (use ftrace kernel option) */
 #ifdef CREATE_TRACE_POINTS
-    trace_roc(rwnx_vif->vif_index, chan->center_freq, duration);
+	trace_roc(rwnx_vif->vif_index, chan->center_freq, duration);
 #endif
 
-#if 1// Fix up layer to send 50ms duration.
-	if(duration < 100){
-		AICWFDBG(LOGINFO, "%s duration time change to 200ms \r\n", __func__);
+#if 1 // Fix up layer to send 50ms duration.
+	if (duration < 100) {
+		AICWFDBG(LOGINFO, "%s duration time change to 200ms \r\n",
+			 __func__);
 		duration = 200;
 	}
 #endif
 
-    /* Check that no other RoC procedure has been launched */
-    if (rwnx_hw->roc_elem) {
-        msleep(2);
-        if (rwnx_hw->roc_elem) {
+	/* Check that no other RoC procedure has been launched */
+	if (rwnx_hw->roc_elem) {
+		msleep(2);
+		if (rwnx_hw->roc_elem) {
 			AICWFDBG(LOGERROR, "remain_on_channel fail\n");
-#if 0//AIDEN test
+#if 0 //AIDEN test
 			roc_elem = rwnx_hw->roc_elem;
 			kfree(roc_elem);
 			rwnx_hw->roc_elem = NULL;
 			//msleep(500);
 #else
-            return -EBUSY;
+			return -EBUSY;
 #endif
-        }
-    }
+		}
+	}
 	//msleep(500);
-	AICWFDBG(LOGINFO, "remain:%d,%d,%d,duration:%d\n",rwnx_vif->vif_index, rwnx_vif->is_p2p_vif, rwnx_hw->is_p2p_alive, duration);
+	AICWFDBG(LOGINFO, "remain:%d,%d,%d,duration:%d\n", rwnx_vif->vif_index,
+		 rwnx_vif->is_p2p_vif, rwnx_hw->is_p2p_alive, duration);
 	//if (rwnx_vif->is_p2p_vif) {
-	AICWFDBG(LOGINFO, "rwnx_vif:%p rwnx_hw->p2p_dev_vif:%p rwnx_vif->up:%d\r\n",
-			rwnx_vif, rwnx_hw->p2p_dev_vif, rwnx_vif->up);
+	AICWFDBG(LOGINFO,
+		 "rwnx_vif:%p rwnx_hw->p2p_dev_vif:%p rwnx_vif->up:%d\r\n",
+		 rwnx_vif, rwnx_hw->p2p_dev_vif, rwnx_vif->up);
 #ifdef CONFIG_USE_P2P0
-    if (rwnx_vif->is_p2p_vif) {
+	if (rwnx_vif->is_p2p_vif) {
 #else
-    if (rwnx_vif == rwnx_hw->p2p_dev_vif && !rwnx_vif->up) {
+	if (rwnx_vif == rwnx_hw->p2p_dev_vif && !rwnx_vif->up) {
 #endif
 		if (!rwnx_hw->is_p2p_alive) {
-			error = rwnx_send_add_if (rwnx_hw, rwnx_vif->wdev.address, //wdev->netdev->dev_addr,
-								  RWNX_VIF_TYPE(rwnx_vif), false, &add_if_cfm);
+			error = rwnx_send_add_if(
+				rwnx_hw,
+				rwnx_vif->wdev.address, //wdev->netdev->dev_addr,
+				RWNX_VIF_TYPE(rwnx_vif), false, &add_if_cfm);
 			if (error)
 				return -EIO;
 
 			if (add_if_cfm.status != 0) {
 				return -EIO;
 			}
-            /* Save the index retrieved from LMAC */
-            spin_lock_bh(&rwnx_hw->cb_lock);
-            rwnx_vif->vif_index = add_if_cfm.inst_nbr;
-            rwnx_vif->up = true;
-            rwnx_hw->vif_started++;
-            rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
-            spin_unlock_bh(&rwnx_hw->cb_lock);
-            rwnx_hw->is_p2p_alive = 1;
-            mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
-            atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
-        }
-        else {
-            mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
-            atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
-        }
-    }
+			/* Save the index retrieved from LMAC */
+			spin_lock_bh(&rwnx_hw->cb_lock);
+			rwnx_vif->vif_index = add_if_cfm.inst_nbr;
+			rwnx_vif->up = true;
+			rwnx_hw->vif_started++;
+			rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+			spin_unlock_bh(&rwnx_hw->cb_lock);
+			rwnx_hw->is_p2p_alive = 1;
+#ifndef CONFIG_USE_P2P0
+			mod_timer(&rwnx_hw->p2p_alive_timer,
+				  jiffies + msecs_to_jiffies(1000));
+			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
+		} else {
+#ifndef CONFIG_USE_P2P0
+			mod_timer(&rwnx_hw->p2p_alive_timer,
+				  jiffies + msecs_to_jiffies(1000));
+			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
+		}
+	}
 
-    /* Allocate a temporary RoC element */
-    roc_elem = kmalloc(sizeof(struct rwnx_roc_elem), GFP_KERNEL);
+	/* Allocate a temporary RoC element */
+	roc_elem = kmalloc(sizeof(struct rwnx_roc_elem), GFP_KERNEL);
 
-    /* Verify that element has well been allocated */
-    if (!roc_elem) {
-        return -ENOMEM;
-    }
+	/* Verify that element has well been allocated */
+	if (!roc_elem) {
+		return -ENOMEM;
+	}
 
-    /* Initialize the RoC information element */
-    roc_elem->wdev = wdev;
-    roc_elem->chan = chan;
-    roc_elem->duration = duration;
-    roc_elem->mgmt_roc = false;
-    roc_elem->on_chan = false;
-
-    /* Initialize the OFFCHAN TX queue to allow off-channel transmissions */
-    rwnx_txq_offchan_init(rwnx_vif);
-
-    /* Forward the information to the FMAC */
-    rwnx_hw->roc_elem = roc_elem;
-    error = rwnx_send_roc(rwnx_hw, rwnx_vif, chan, duration, &roc_cfm);
-
-    /* If no error, keep all the information for handling of end of procedure */
-    if (error == 0) {
-
-        /* Set the cookie value */
-        *cookie = (u64)(rwnx_hw->roc_cookie_cnt);
-        if(roc_cfm.status) {
-            // failed to roc
-            rwnx_hw->roc_elem = NULL;
-            kfree(roc_elem);
-            rwnx_txq_offchan_deinit(rwnx_vif);
-            return -EBUSY;
-        }
-    } else {
-        /* Free the allocated element */
-        rwnx_hw->roc_elem = NULL;
-        kfree(roc_elem);
-        rwnx_txq_offchan_deinit(rwnx_vif);
-    }
+	/* Initialize the RoC information element */
+	roc_elem->wdev = wdev;
+	roc_elem->chan = chan;
+	roc_elem->duration = duration;
+	roc_elem->mgmt_roc = mgmt_roc_flag;
+	roc_elem->on_chan = false;
+
+	/* Initialize the OFFCHAN TX queue to allow off-channel transmissions */
+	rwnx_txq_offchan_init(rwnx_vif);
+
+	/* Forward the information to the FMAC */
+	rwnx_hw->roc_elem = roc_elem;
+	error = rwnx_send_roc(rwnx_hw, rwnx_vif, chan, duration, &roc_cfm);
+
+	/* If no error, keep all the information for handling of end of procedure */
+	if (error == 0) {
+		/* Set the cookie value */
+		*cookie = (u64)(rwnx_hw->roc_cookie_cnt);
+		if (roc_cfm.status) {
+			// failed to roc
+			rwnx_hw->roc_elem = NULL;
+			kfree(roc_elem);
+			rwnx_txq_offchan_deinit(rwnx_vif);
+			return -EBUSY;
+		}
+	} else {
+		/* Free the allocated element */
+		rwnx_hw->roc_elem = NULL;
+		kfree(roc_elem);
+		rwnx_txq_offchan_deinit(rwnx_vif);
+	}
+
+	return error;
+}
 
-    return error;
+static int
+rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				struct wireless_dev *wdev,
+#else
+				struct net_device *dev,
+#endif
+				struct ieee80211_channel *chan,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+				enum nl80211_channel_type channel_type,
+#endif
+				unsigned int duration, u64 *cookie)
+{
+	return rwnx_cfg80211_remain_on_channel_(wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+						wdev,
+#else
+						dev,
+#endif
+						chan,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+						channel_type,
+#endif
+						duration, cookie, false);
 }
 
 /**
@@ -5493,33 +4507,33 @@ rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
  *	the duration value.
  */
 static int rwnx_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
-                                            #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-                                                  struct net_device *dev,
-                                            #else
-                                                  struct wireless_dev *wdev,
-                                            #endif
-                                                  u64 cookie)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
+						  struct net_device *dev,
+#else
+						  struct wireless_dev *wdev,
+#endif
+						  u64 cookie)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #ifdef CREATE_TRACE_POINTS
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 #else
-    struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
+	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
 #endif
 #endif
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 #ifdef CREATE_TRACE_POINTS
-    /* For debug purpose (use ftrace kernel option) */
-    trace_cancel_roc(rwnx_vif->vif_index);
+	/* For debug purpose (use ftrace kernel option) */
+	trace_cancel_roc(rwnx_vif->vif_index);
 #endif
-    /* Check if a RoC procedure is pending */
-    if (!rwnx_hw->roc_elem) {
-        return 0;
-    }
+	/* Check if a RoC procedure is pending */
+	if (!rwnx_hw->roc_elem) {
+		return 0;
+	}
 
-    /* Forward the information to the FMAC */
-    return rwnx_send_cancel_roc(rwnx_hw);
+	/* Forward the information to the FMAC */
+	return rwnx_send_cancel_roc(rwnx_hw);
 }
 
 #define IS_2P4GHZ(n) (n >= 2412 && n <= 2484)
@@ -5529,65 +4543,67 @@ static int rwnx_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
 /**
  * @dump_survey: get site survey information.
  */
-static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *netdev,
-                                     int idx, struct survey_info *info)
+static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy,
+				     struct net_device *netdev, int idx,
+				     struct survey_info *info)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct ieee80211_supported_band *sband;
-    struct rwnx_survey_info *rwnx_survey;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct ieee80211_supported_band *sband;
+	struct rwnx_survey_info *rwnx_survey;
 
-    //RWNX_DBG(RWNX_FN_ENTRY_STR);
+	//RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    if (idx >= ARRAY_SIZE(rwnx_hw->survey))
-        return -ENOENT;
+	if (idx >= ARRAY_SIZE(rwnx_hw->survey))
+		return -ENOENT;
 
-    rwnx_survey = &rwnx_hw->survey[idx];
+	rwnx_survey = &rwnx_hw->survey[idx];
 
-    // Check if provided index matches with a supported 2.4GHz channel
-    sband = wiphy->bands[NL80211_BAND_2GHZ];
-    if (sband && idx >= sband->n_channels) {
-        idx -= sband->n_channels;
-        sband = NULL;
-    }
+	// Check if provided index matches with a supported 2.4GHz channel
+	sband = wiphy->bands[NL80211_BAND_2GHZ];
+	if (sband && idx >= sband->n_channels) {
+		idx -= sband->n_channels;
+		sband = NULL;
+	}
 
 	//#ifdef USE_5G
 	if (rwnx_hw->band_5g_support) {
-	    if (!sband) {
-	        // Check if provided index matches with a supported 5GHz channel
-	        sband = wiphy->bands[NL80211_BAND_5GHZ];
-
-	        if (!sband || idx >= sband->n_channels)
-	            return -ENOENT;
-	    }
-	}else{
-	//#else
+		if (!sband) {
+			// Check if provided index matches with a supported 5GHz channel
+			sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+			if (!sband || idx >= sband->n_channels)
+				return -ENOENT;
+		}
+	} else {
+		//#else
 		if (!sband || idx >= sband->n_channels)
-            return -ENOENT;
+			return -ENOENT;
 	}
-	//#endif
-
-    // Fill the survey
-    info->channel = &sband->channels[idx];
-    info->filled = rwnx_survey->filled;
-
-    if (rwnx_survey->filled != 0) {
-        SURVEY_TIME(info) = (u64)rwnx_survey->chan_time_ms;
-        SURVEY_TIME_BUSY(info) = (u64)rwnx_survey->chan_time_busy_ms;
-        //info->noise = rwnx_survey->noise_dbm;
-	info->noise = ((IS_2P4GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_2GHZ :
-			(IS_5GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_5GHZ : DEFAULT_NOISE_FLOOR_5GHZ);
-
-
-        // Set the survey report as not used
-        if(info->noise == 0){
-		    rwnx_survey->filled = 0;
-        }else{
-            rwnx_survey->filled |= SURVEY_INFO_NOISE_DBM;
-        }
+	//#endif
 
-    }
+	// Fill the survey
+	info->channel = &sband->channels[idx];
+	info->filled = rwnx_survey->filled;
+
+	if (rwnx_survey->filled != 0) {
+		SURVEY_TIME(info) = (u64)rwnx_survey->chan_time_ms;
+		SURVEY_TIME_BUSY(info) = (u64)rwnx_survey->chan_time_busy_ms;
+		//info->noise = rwnx_survey->noise_dbm;
+		info->noise = ((IS_2P4GHZ(info->channel->center_freq)) ?
+				       DEFAULT_NOISE_FLOOR_2GHZ :
+			       (IS_5GHZ(info->channel->center_freq)) ?
+				       DEFAULT_NOISE_FLOOR_5GHZ :
+				       DEFAULT_NOISE_FLOOR_5GHZ);
+
+		// Set the survey report as not used
+		if (info->noise == 0) {
+			rwnx_survey->filled = 0;
+		} else {
+			rwnx_survey->filled |= SURVEY_INFO_NOISE_DBM;
+		}
+	}
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -5597,232 +4613,242 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 static int rwnx_cfg80211_get_channel(struct wiphy *wiphy,
-                                                    struct wireless_dev *wdev,
+				     struct wireless_dev *wdev,
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-                                                    unsigned int link_id,
+				     unsigned int link_id,
 #endif
-                                                    struct cfg80211_chan_def *chandef)
+				     struct cfg80211_chan_def *chandef)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
-    struct rwnx_chanctx *ctxt;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
+	struct rwnx_chanctx *ctxt;
 
-    if (!rwnx_vif->up) {
-        return -ENODATA;
-    }
+	if (!rwnx_vif->up) {
+		return -ENODATA;
+	}
 
-    if (rwnx_vif->vif_index == rwnx_hw->monitor_vif)
-    {
-        //retrieve channel from firmware
-        rwnx_cfg80211_set_monitor_channel(wiphy, NULL);
-    }
+	if (rwnx_vif->vif_index == rwnx_hw->monitor_vif) {
+		//retrieve channel from firmware
+		rwnx_cfg80211_set_monitor_channel(wiphy, NULL);
+	}
 
-    //Check if channel context is valid
-    if (!rwnx_chanctx_valid(rwnx_hw, rwnx_vif->ch_index)){
-        return -ENODATA;
-    }
+	//Check if channel context is valid
+	if (!rwnx_chanctx_valid(rwnx_hw, rwnx_vif->ch_index)) {
+		return -ENODATA;
+	}
 
-    ctxt = &rwnx_hw->chanctx_table[rwnx_vif->ch_index];
-    *chandef = ctxt->chan_def;
+	ctxt = &rwnx_hw->chanctx_table[rwnx_vif->ch_index];
+	*chandef = ctxt->chan_def;
 
-    return 0;
+	return 0;
 }
 #else
 struct ieee80211_channel *rwnx_cfg80211_get_channel(struct wiphy *wiphy)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct ieee80211_channel *chan = NULL;
-    struct rwnx_vif *vif;
-    bool_l found = false;
-    //may TBD
-
-    list_for_each_entry(vif, &rwnx_hw->vifs, list)
-    {
-        if(vif->wdev.iftype == NL80211_IFTYPE_AP)
-        {
-            found = true;
-            break;
-        }
-    }
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct ieee80211_channel *chan = NULL;
+	struct rwnx_vif *vif;
+	bool_l found = false;
+	//may TBD
 
-    if(found && rwnx_hw->set_chan.center_freq) {
-        chan = kzalloc(sizeof(struct ieee80211_channel), GFP_KERNEL);
-        memcpy((u8 *)chan, (u8 *)&rwnx_hw->set_chan, sizeof(struct ieee80211_channel));
-    }
+	list_for_each_entry(vif, &rwnx_hw->vifs, list) {
+		if (vif->wdev.iftype == NL80211_IFTYPE_AP) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found && rwnx_hw->set_chan.center_freq) {
+		chan = kzalloc(sizeof(struct ieee80211_channel), GFP_KERNEL);
+		memcpy((u8 *)chan, (u8 *)&rwnx_hw->set_chan,
+		       sizeof(struct ieee80211_channel));
+	}
 
-    return chan;
+	return chan;
 }
 #endif
 
-
 /**
  * @mgmt_tx: Transmit a management frame.
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
 static int rwnx_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
-                                 struct cfg80211_mgmt_tx_params *params,
-                                 u64 *cookie)
+				 struct cfg80211_mgmt_tx_params *params,
+				 u64 *cookie)
 #else
 static int rwnx_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
-                                 struct ieee80211_channel *channel, bool offchan,
-                                 unsigned int wait, const u8* buf, size_t len,
-                            #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-                                 bool no_cck,
-                            #endif
-                            #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
-                                 bool dont_wait_for_ack,
-                            #endif
-                                 u64 *cookie)
+				 struct ieee80211_channel *channel,
+				 bool offchan, unsigned int wait, const u8 *buf,
+				 size_t len,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
+				 bool no_cck,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
+				 bool dont_wait_for_ack,
+#endif
+				 u64 *cookie)
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct wireless_dev *wdev = &rwnx_vif->wdev;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct wireless_dev *wdev = &rwnx_vif->wdev;
 #else
-    struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
-#endif
-    struct rwnx_sta *rwnx_sta = NULL;
-    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-    struct ieee80211_channel *channel = params->chan;
-    const u8 *buf = params->buf;
-    //size_t len = params->len;
-    #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
-    struct ieee80211_mgmt *mgmt = (void *)buf;
-    bool ap = false;
-    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-    bool offchan = false;
-    #endif
-
-    /* Check if provided VIF is an AP or a STA one */
-    switch (RWNX_VIF_TYPE(rwnx_vif)) {
-        case NL80211_IFTYPE_AP_VLAN:
-            rwnx_vif = rwnx_vif->ap_vlan.master;
-        case NL80211_IFTYPE_AP:
-        case NL80211_IFTYPE_P2P_GO:
-        case NL80211_IFTYPE_MESH_POINT:
-            ap = true;
-            break;
-        case NL80211_IFTYPE_STATION:
-        case NL80211_IFTYPE_P2P_CLIENT:
-        default:
-            break;
-    }
+	struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
+#endif
+	struct rwnx_sta *rwnx_sta = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	struct ieee80211_channel *channel = params->chan;
+	const u8 *buf = params->buf;
+//size_t len = params->len;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
+	struct ieee80211_mgmt *mgmt = (void *)buf;
+	bool ap = false;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	bool offchan = false;
+#endif
 
+	/* Check if provided VIF is an AP or a STA one */
+	switch (RWNX_VIF_TYPE(rwnx_vif)) {
+	case NL80211_IFTYPE_AP_VLAN:
+		rwnx_vif = rwnx_vif->ap_vlan.master;
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+	case NL80211_IFTYPE_MESH_POINT:
+		ap = true;
+		break;
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+	default:
+		break;
+	}
 
-    /* Get STA on which management frame has to be sent */
-    rwnx_sta = rwnx_retrieve_sta(rwnx_hw, rwnx_vif, mgmt->da,
-                                 mgmt->frame_control, ap);
+	/* Get STA on which management frame has to be sent */
+	rwnx_sta = rwnx_retrieve_sta(rwnx_hw, rwnx_vif, mgmt->da,
+				     mgmt->frame_control, ap);
 
-	AICWFDBG(LOGDEBUG, "%s rwnx_sta:%p RWNX_VIF_TYPE(rwnx_vif):%d \r\n", __func__, rwnx_sta, RWNX_VIF_TYPE(rwnx_vif));
+	AICWFDBG(LOGDEBUG, "%s rwnx_sta:%p RWNX_VIF_TYPE(rwnx_vif):%d \r\n",
+		 __func__, rwnx_sta, RWNX_VIF_TYPE(rwnx_vif));
 
 #ifdef CREATE_TRACE_POINTS
-    trace_mgmt_tx((channel) ? channel->center_freq : 0,
-                  rwnx_vif->vif_index, (rwnx_sta) ? rwnx_sta->sta_idx : 0xFF,
-                  mgmt);
+	trace_mgmt_tx((channel) ? channel->center_freq : 0, rwnx_vif->vif_index,
+		      (rwnx_sta) ? rwnx_sta->sta_idx : 0xFF, mgmt);
 #endif
-    if (ap || rwnx_sta)
-        goto send_frame;
+	if (ap || rwnx_sta)
+		goto send_frame;
 
-    /* Not an AP interface sending frame to unknown STA:
+	/* Not an AP interface sending frame to unknown STA:
      * This is allowed for external authetication */
-    if (rwnx_vif->sta.external_auth && ieee80211_is_auth(mgmt->frame_control))
-        goto send_frame;
+	if (rwnx_vif->sta.external_auth &&
+	    ieee80211_is_auth(mgmt->frame_control))
+		goto send_frame;
 
-    /* Otherwise ROC is needed */
-    if (!channel) {
+	/* Otherwise ROC is needed */
+	if (!channel) {
 		AICWFDBG(LOGERROR, "mgmt_tx fail since channel\n");
-        return -EINVAL;
-    }
+		return -EINVAL;
+	}
 
-    /* Check that a RoC is already pending */
-    if (rwnx_hw->roc_elem) {
-        /* Get VIF used for current ROC */
+	/* Check that a RoC is already pending */
+	if (rwnx_hw->roc_elem) {
+		/* Get VIF used for current ROC */
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
-        struct rwnx_vif *rwnx_roc_vif = netdev_priv(rwnx_hw->roc_elem->wdev->netdev);
+		struct rwnx_vif *rwnx_roc_vif =
+			netdev_priv(rwnx_hw->roc_elem->wdev->netdev);
 #else
-        struct rwnx_vif *rwnx_roc_vif = container_of(rwnx_hw->roc_elem->wdev, struct rwnx_vif, wdev);//netdev_priv(rwnx_hw->roc_elem->wdev->netdev);
-#endif
-
-        /* Check if RoC channel is the same than the required one */
-        if ((rwnx_hw->roc_elem->chan->center_freq != channel->center_freq)
-            || (rwnx_vif->vif_index != rwnx_roc_vif->vif_index)) {
-            AICWFDBG(LOGERROR, "mgmt rx chan invalid: %d, %d", rwnx_hw->roc_elem->chan->center_freq, channel->center_freq);
-            return -EINVAL;
-        }
-    } else {
-        u64 cookie;
-        int error;
+		struct rwnx_vif *rwnx_roc_vif = container_of(
+			rwnx_hw->roc_elem->wdev, struct rwnx_vif,
+			wdev); //netdev_priv(rwnx_hw->roc_elem->wdev->netdev);
+#endif
+
+		/* Check if RoC channel is the same than the required one */
+		if ((rwnx_hw->roc_elem->chan->center_freq !=
+		     channel->center_freq) ||
+		    (rwnx_vif->vif_index != rwnx_roc_vif->vif_index)) {
+			AICWFDBG(LOGERROR, "mgmt rx chan invalid: %d, %d",
+				 rwnx_hw->roc_elem->chan->center_freq,
+				 channel->center_freq);
+			return -EINVAL;
+		}
+	} else {
+		u64 cookie;
+		int error;
 
 		AICWFDBG(LOGINFO, "mgmt rx remain on chan\n");
 
-        /* Start a ROC procedure for 30ms */
+		/* Start a ROC procedure for 30ms */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-        error = rwnx_cfg80211_remain_on_channel(wiphy, wdev, channel,
-                                                30, &cookie);
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
-        error = rwnx_cfg80211_remain_on_channel(wiphy, wdev, channel, NL80211_CHAN_NO_HT,
-                                                30, &cookie);
+		error = rwnx_cfg80211_remain_on_channel_(wiphy, wdev, channel,
+							 30, &cookie, true);
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)) && \
+	(LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+		error = rwnx_cfg80211_remain_on_channel_(wiphy, wdev, channel,
+							 NL80211_CHAN_NO_HT, 30,
+							 &cookie, true);
 #else
-        error = rwnx_cfg80211_remain_on_channel(wiphy, dev, channel, NL80211_CHAN_NO_HT,
-                                                30, &cookie);
+		error = rwnx_cfg80211_remain_on_channel_(wiphy, dev, channel,
+							 NL80211_CHAN_NO_HT, 30,
+							 &cookie, true);
 #endif
 
-        if (error) {
+		if (error) {
 			AICWFDBG(LOGERROR, "mgmt rx chan err\n");
-            return error;
-        }
-        /* Need to keep in mind that RoC has been launched internally in order to
+			return error;
+		}
+		/* Need to keep in mind that RoC has been launched internally in order to
          * avoid to call the cfg80211 callback once expired */
-        rwnx_hw->roc_elem->mgmt_roc = true;
-    }
+		//rwnx_hw->roc_elem->mgmt_roc = true;
+	}
 
-    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-    offchan = true;
-    #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	offchan = true;
+#endif
 
 send_frame:
-    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-    return rwnx_start_mgmt_xmit(rwnx_vif, rwnx_sta, params, offchan, cookie);
-    #else
-    return rwnx_start_mgmt_xmit(rwnx_vif, rwnx_sta, channel, offchan, wait, buf, len, no_cck, dont_wait_for_ack, cookie);
-    #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	return rwnx_start_mgmt_xmit(rwnx_vif, rwnx_sta, params, offchan,
+				    cookie);
+#else
+	return rwnx_start_mgmt_xmit(rwnx_vif, rwnx_sta, channel, offchan, wait,
+				    buf, len, no_cck, dont_wait_for_ack,
+				    cookie);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
 }
 
 /**
  * @start_radar_detection: Start radar detection in the driver.
  */
-static
-int rwnx_cfg80211_start_radar_detection(struct wiphy *wiphy,
-                                        struct net_device *dev,
-                                        struct cfg80211_chan_def *chandef
-                                    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
-                                        , u32 cac_time_ms
-                                    #endif
-                                        )
+static int rwnx_cfg80211_start_radar_detection(struct wiphy *wiphy,
+					       struct net_device *dev,
+					       struct cfg80211_chan_def *chandef
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+					       ,
+					       u32 cac_time_ms
+#endif
+)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct apm_start_cac_cfm cfm;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct apm_start_cac_cfm cfm;
 
-    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
-    rwnx_radar_start_cac(&rwnx_hw->radar, cac_time_ms, rwnx_vif);
-    #endif
-    rwnx_send_apm_start_cac_req(rwnx_hw, rwnx_vif, chandef, &cfm);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	rwnx_radar_start_cac(&rwnx_hw->radar, cac_time_ms, rwnx_vif);
+#endif
+	rwnx_send_apm_start_cac_req(rwnx_hw, rwnx_vif, chandef, &cfm);
 
-    if (cfm.status == CO_OK) {
-        spin_lock_bh(&rwnx_hw->cb_lock);
-        rwnx_chanctx_link(rwnx_vif, cfm.ch_idx, chandef);
-        if (rwnx_hw->cur_chanctx == rwnx_vif->ch_index)
-            rwnx_radar_detection_enable(&rwnx_hw->radar,
-                                        RWNX_RADAR_DETECT_REPORT,
-                                        RWNX_RADAR_RIU);
-        spin_unlock_bh(&rwnx_hw->cb_lock);
-    } else {
-        return -EIO;
-    }
+	if (cfm.status == CO_OK) {
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_chanctx_link(rwnx_vif, cfm.ch_idx, chandef);
+		if (rwnx_hw->cur_chanctx == rwnx_vif->ch_index)
+			rwnx_radar_detection_enable(&rwnx_hw->radar,
+						    RWNX_RADAR_DETECT_REPORT,
+						    RWNX_RADAR_RIU);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+	} else {
+		return -EIO;
+	}
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -5830,26 +4856,26 @@ int rwnx_cfg80211_start_radar_detection(struct wiphy *wiphy,
  *	driver. If the SME is in the driver/firmware, this information can be
  *	used in building Authentication and Reassociation Request frames.
  */
-static
-int rwnx_cfg80211_update_ft_ies(struct wiphy *wiphy,
-                            struct net_device *dev,
-                            struct cfg80211_update_ft_ies_params *ftie)
+static int
+rwnx_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_update_ft_ies_params *ftie)
 {
-    return 0;
+	return 0;
 }
 
 /**
  * @set_cqm_rssi_config: Configure connection quality monitor RSSI threshold.
  */
-static
-int rwnx_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
-                                  struct net_device *dev,
-                                  int32_t rssi_thold, uint32_t rssi_hyst)
+static int rwnx_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     int32_t rssi_thold,
+					     uint32_t rssi_hyst)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 
-    return rwnx_send_cfg_rssi_req(rwnx_hw, rwnx_vif->vif_index, rssi_thold, rssi_hyst);
+	return rwnx_send_cfg_rssi_req(rwnx_hw, rwnx_vif->vif_index, rssi_thold,
+				      rssi_hyst);
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
@@ -5862,106 +4888,107 @@ int rwnx_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
  *	everything. It should do it's best to verify requests and reject them
  *	as soon as possible.
  */
-int rwnx_cfg80211_channel_switch(struct wiphy *wiphy,
-                                 struct net_device *dev,
-                                 struct cfg80211_csa_settings *params)
+int rwnx_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_csa_settings *params)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct rwnx_ipc_elem_var elem;
-    struct rwnx_bcn *bcn, *bcn_after;
-    struct rwnx_csa *csa;
-    u16 csa_oft[BCN_MAX_CSA_CPT];
-    u8 *buf;
-    int i, error = 0;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_ipc_elem_var elem;
+	struct rwnx_bcn *bcn, *bcn_after;
+	struct rwnx_csa *csa;
+	u16 csa_oft[BCN_MAX_CSA_CPT];
+	u8 *buf;
+	int i, error = 0;
 
 	//elem init
 	elem.dma_addr = 0;
 
-    if (vif->ap.csa)
-        return -EBUSY;
+	if (vif->ap.csa)
+		return -EBUSY;
 
-    if (params->n_counter_offsets_beacon > BCN_MAX_CSA_CPT)
-        return -EINVAL;
+	if (params->n_counter_offsets_beacon > BCN_MAX_CSA_CPT)
+		return -EINVAL;
 
-    /* Build the new beacon with CSA IE */
-    bcn = &vif->ap.bcn;
-    buf = rwnx_build_bcn(bcn, &params->beacon_csa);
-    if (!buf)
-        return -ENOMEM;
+	/* Build the new beacon with CSA IE */
+	bcn = &vif->ap.bcn;
+	buf = rwnx_build_bcn(bcn, &params->beacon_csa);
+	if (!buf)
+		return -ENOMEM;
 
-    memset(csa_oft, 0, sizeof(csa_oft));
-    for (i = 0; i < params->n_counter_offsets_beacon; i++)
-    {
-        csa_oft[i] = params->counter_offsets_beacon[i] + bcn->head_len +
-            bcn->tim_len;
-    }
+	memset(csa_oft, 0, sizeof(csa_oft));
+	for (i = 0; i < params->n_counter_offsets_beacon; i++) {
+		csa_oft[i] = params->counter_offsets_beacon[i] + bcn->head_len +
+			     bcn->tim_len;
+	}
 
-    /* If count is set to 0 (i.e anytime after this beacon) force it to 2 */
-    if (params->count == 0) {
-        params->count = 2;
-        for (i = 0; i < params->n_counter_offsets_beacon; i++)
-        {
-            buf[csa_oft[i]] = 2;
-        }
-    }
+	/* If count is set to 0 (i.e anytime after this beacon) force it to 2 */
+	if (params->count == 0) {
+		params->count = 2;
+		for (i = 0; i < params->n_counter_offsets_beacon; i++) {
+			buf[csa_oft[i]] = 2;
+		}
+	}
 
-    #if 0
+#if 0
     if ((error = rwnx_ipc_elem_var_allocs(rwnx_hw, &elem, bcn->len,
                                           DMA_TO_DEVICE, buf, NULL, NULL))) {
         goto end;
     }
-    #else
-    error = rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, bcn->len);
-    if (error) {
-        goto end;
-    }
-    #endif
+#else
+	error = rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, bcn->len);
+	if (error) {
+		goto end;
+	}
+#endif
 
-    /* Build the beacon to use after CSA. It will only be sent to fw once
+	/* Build the beacon to use after CSA. It will only be sent to fw once
        CSA is over, but do it before sending the beacon as it must be ready
        when CSA is finished. */
-    csa = kzalloc(sizeof(struct rwnx_csa), GFP_KERNEL);
-    if (!csa) {
-        error = -ENOMEM;
-        goto end;
-    }
+	csa = kzalloc(sizeof(struct rwnx_csa), GFP_KERNEL);
+	if (!csa) {
+		error = -ENOMEM;
+		goto end;
+	}
 
-    bcn_after = &csa->bcn;
-    buf = rwnx_build_bcn(bcn_after, &params->beacon_after);
-    if (!buf) {
-        error = -ENOMEM;
-        rwnx_del_csa(vif);
-        goto end;
-    }
+	bcn_after = &csa->bcn;
+	buf = rwnx_build_bcn(bcn_after, &params->beacon_after);
+	if (!buf) {
+		error = -ENOMEM;
+		rwnx_del_csa(vif);
+		goto end;
+	}
 
-    vif->ap.csa = csa;
-    csa->vif = vif;
-    csa->chandef = params->chandef;
+	vif->ap.csa = csa;
+	csa->vif = vif;
+	csa->chandef = params->chandef;
 
-    /* Send new Beacon. FW will extract channel and count from the beacon */
-    error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index, elem.dma_addr,
-                                 bcn->len, bcn->head_len, bcn->tim_len, csa_oft);
+	/* Send new Beacon. FW will extract channel and count from the beacon */
+	error = rwnx_send_bcn_change(rwnx_hw, vif->vif_index, elem.dma_addr,
+				     bcn->len, bcn->head_len, bcn->tim_len,
+				     csa_oft);
 
-    if (error) {
-        rwnx_del_csa(vif);
-        goto end;
-    } else {
-        INIT_WORK(&csa->work, rwnx_csa_finish);
+	if (error) {
+		rwnx_del_csa(vif);
+		goto end;
+	} else {
+		INIT_WORK(&csa->work, rwnx_csa_finish);
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION4
-		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0,
+						  params->count, false, 0);
 #elif LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false);
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0,
+						  params->count, false);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count, params->block_tx);
+		cfg80211_ch_switch_started_notify(
+			dev, &csa->chandef, params->count, params->block_tx);
 #else
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count);
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef,
+						  params->count);
 #endif
+	}
 
-    }
-
-  end:
-    return error;
+end:
+	return error;
 }
 #endif
 
@@ -5990,12 +5017,12 @@ rwnx_cfg80211_tdls_mgmt(struct wiphy *wiphy,
 	const u8 *buf,
 	size_t len)
 {
-    #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
     u32 peer_capability = 0;
-    #endif
-    #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
     bool initiator = false;
-    #endif
+#endif
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *rwnx_vif = netdev_priv(dev);
     int ret = 0;
@@ -6198,30 +5225,28 @@ rwnx_cfg80211_tdls_cancel_channel_switch(struct wiphy *wiphy,
  * @change_bss: Modify parameters for a given BSS (mainly for AP mode).
  */
 int rwnx_cfg80211_change_bss(struct wiphy *wiphy, struct net_device *dev,
-                             struct bss_parameters *params)
+			     struct bss_parameters *params)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    int res =  -EOPNOTSUPP;
-
-    if (((RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP) ||
-         (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)) &&
-        (params->ap_isolate > -1)) {
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	int res = -EOPNOTSUPP;
 
-        if (params->ap_isolate)
-            rwnx_vif->ap.flags |= RWNX_AP_ISOLATE;
-        else
-            rwnx_vif->ap.flags &= ~RWNX_AP_ISOLATE;
+	if (((RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP) ||
+	     (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)) &&
+	    (params->ap_isolate > -1)) {
+		if (params->ap_isolate)
+			rwnx_vif->ap.flags |= RWNX_AP_ISOLATE;
+		else
+			rwnx_vif->ap.flags &= ~RWNX_AP_ISOLATE;
 
-        res = 0;
-    }
+		res = 0;
+	}
 
-    return res;
+	return res;
 }
 
 static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
-                                  struct station_info *sinfo)
+				  struct station_info *sinfo)
 {
-
 	struct rwnx_sta_stats *stats = &sta->stats;
 	struct rx_vector_1 *rx_vect1 = &stats->last_rx.rx_vect1;
 	union rwnx_rate_ctrl_info *rate_info;
@@ -6231,29 +5256,34 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	sinfo->tx_failed = cfm.txfailed;
 	rate_info = (union rwnx_rate_ctrl_info *)&cfm.rate_info;
 
-
-	AICWFDBG(LOGDEBUG, "%s ModTx:%d TxIndex:%d ModRx:%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n", __func__,
-		rate_info->formatModTx, rate_info->mcsIndexTx, rx_vect1->format_mod,
-		rx_vect1->ht.mcs,
-		rx_vect1->vht.mcs,
-		rx_vect1->he.mcs,
+	AICWFDBG(
+		LOGDEBUG,
+		"%s ModTx(%d):%d TxIndex:%d ModRx(%d):%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n",
+		__func__, rate_info->bwTx, rate_info->formatModTx,
+		rate_info->mcsIndexTx, rx_vect1->ch_bw, rx_vect1->format_mod,
+		rx_vect1->ht.mcs, rx_vect1->vht.mcs, rx_vect1->he.mcs,
 		(s8)cfm.rssi);
 
-
 	switch (rate_info->formatModTx) {
 	case FORMATMOD_NON_HT:
 	case FORMATMOD_NON_HT_DUP_OFDM:
 		sinfo->txrate.flags = 0;
-		sinfo->txrate.legacy = tx_legrates_lut_rate[rate_info->mcsIndexTx];
+		sinfo->txrate.legacy =
+			tx_legrates_lut_rate[rate_info->mcsIndexTx];
+		sinfo->txrate.nss = 1;
 		break;
 	case FORMATMOD_HT_MF:
 	case FORMATMOD_HT_GF:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 3) & 0x7) + 1;
+		if (rate_info->giAndPreTypeTx)
+			sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		break;
 	case FORMATMOD_VHT:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	case FORMATMOD_HE_MU:
@@ -6261,6 +5291,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_ER:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_HE_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #else
 	//kernel not support he
@@ -6268,11 +5299,12 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-        if(rate_info->mcsIndexTx > 9){
-            sinfo->txrate.mcs = 9;
-        }else{
-		    sinfo->txrate.mcs = rate_info->mcsIndexTx;
-        }
+		if (rate_info->mcsIndexTx > 9) {
+			sinfo->txrate.mcs = 9;
+		} else {
+			sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		}
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #endif
 	default:
@@ -6303,16 +5335,16 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	}
 #endif
 
-	sinfo->txrate.nss = 1;
-	sinfo->filled |= (BIT(NL80211_STA_INFO_TX_BITRATE) | BIT(NL80211_STA_INFO_TX_FAILED));
+	sinfo->filled |= (BIT(NL80211_STA_INFO_TX_BITRATE) |
+			  BIT(NL80211_STA_INFO_TX_FAILED));
 
-	sinfo->inactive_time = jiffies_to_msecs(jiffies - vif->rwnx_hw->stats.last_tx);
+	sinfo->inactive_time =
+		jiffies_to_msecs(jiffies - vif->rwnx_hw->stats.last_tx);
 	sinfo->rx_bytes = vif->net_stats.rx_bytes;
 	sinfo->tx_bytes = vif->net_stats.tx_bytes;
 	sinfo->tx_packets = vif->net_stats.tx_packets;
 	sinfo->rx_packets = vif->net_stats.rx_packets;
 	sinfo->signal = (s8)cfm.rssi;
-	sinfo->rxrate.nss = 1;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
 	switch (rx_vect1->ch_bw) {
@@ -6342,7 +5374,8 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_NON_HT:
 	case FORMATMOD_NON_HT_DUP_OFDM:
 		sinfo->rxrate.flags = 0;
-		sinfo->rxrate.legacy = legrates_lut_rate[legrates_lut[rx_vect1->leg_rate]];
+		sinfo->rxrate.legacy = legrates_lut[rx_vect1->leg_rate].rate;
+		sinfo->rxrate.nss = 1;
 		break;
 	case FORMATMOD_HT_MF:
 	case FORMATMOD_HT_GF:
@@ -6350,12 +5383,14 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 		if (rx_vect1->ht.short_gi)
 			sinfo->rxrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		sinfo->rxrate.mcs = rx_vect1->ht.mcs;
+		sinfo->rxrate.nss = rx_vect1->ht.num_extn_ss + 1;
 		break;
 	case FORMATMOD_VHT:
 		sinfo->rxrate.flags = RATE_INFO_FLAGS_VHT_MCS;
 		if (rx_vect1->vht.short_gi)
 			sinfo->rxrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		sinfo->rxrate.mcs = rx_vect1->vht.mcs;
+		sinfo->rxrate.nss = rx_vect1->vht.nss + 1;
 		break;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	case FORMATMOD_HE_MU:
@@ -6366,6 +5401,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 		sinfo->rxrate.mcs = rx_vect1->he.mcs;
 		sinfo->rxrate.he_gi = rx_vect1->he.gi_type;
 		sinfo->rxrate.he_dcm = rx_vect1->he.dcm;
+		sinfo->rxrate.nss = rx_vect1->he.nss + 1;
 		break;
 #else
 	//kernel not support he
@@ -6373,143 +5409,137 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->rxrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-        if(rx_vect1->he.mcs > 9){
-            sinfo->rxrate.mcs = 9;
-        }else{
-            sinfo->rxrate.mcs = rx_vect1->he.mcs;
-        }
+		if (rx_vect1->he.mcs > 9) {
+			sinfo->rxrate.mcs = 9;
+		} else {
+			sinfo->rxrate.mcs = rx_vect1->he.mcs;
+		}
+		sinfo->rxrate.mcs =
+			(rx_vect1->he.mcs > 9 ? 9 : rx_vect1->he.mcs);
+		sinfo->rxrate.nss = rx_vect1->he.nss + 1;
 		break;
 #endif
 	default:
 		return -EINVAL;
 	}
 
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
-	sinfo->filled |= (STATION_INFO_INACTIVE_TIME |
-					 STATION_INFO_RX_BYTES64 |
-					 STATION_INFO_TX_BYTES64 |
-					 STATION_INFO_RX_PACKETS |
-					 STATION_INFO_TX_PACKETS |
-					 STATION_INFO_SIGNAL |
-					 STATION_INFO_RX_BITRATE);
+	sinfo->filled |= (STATION_INFO_INACTIVE_TIME | STATION_INFO_RX_BYTES64 |
+			  STATION_INFO_TX_BYTES64 | STATION_INFO_RX_PACKETS |
+			  STATION_INFO_TX_PACKETS | STATION_INFO_SIGNAL |
+			  STATION_INFO_RX_BITRATE);
 #else
 	sinfo->filled |= (BIT(NL80211_STA_INFO_INACTIVE_TIME) |
-					 BIT(NL80211_STA_INFO_RX_BYTES64)    |
-					 BIT(NL80211_STA_INFO_TX_BYTES64)    |
-					 BIT(NL80211_STA_INFO_RX_PACKETS)    |
-					 BIT(NL80211_STA_INFO_TX_PACKETS)    |
-					 BIT(NL80211_STA_INFO_SIGNAL)        |
-					 BIT(NL80211_STA_INFO_RX_BITRATE));
+			  BIT(NL80211_STA_INFO_RX_BYTES64) |
+			  BIT(NL80211_STA_INFO_TX_BYTES64) |
+			  BIT(NL80211_STA_INFO_RX_PACKETS) |
+			  BIT(NL80211_STA_INFO_TX_PACKETS) |
+			  BIT(NL80211_STA_INFO_SIGNAL) |
+			  BIT(NL80211_STA_INFO_RX_BITRATE));
 #endif
 
 	return 0;
 }
 
-
 /**
  * @get_station: get station information for the station identified by @mac
  */
 static int rwnx_cfg80211_get_station(struct wiphy *wiphy,
-	struct net_device *dev,
+				     struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-	u8 *mac,
+				     u8 *mac,
 #else
-	const u8 *mac,
+				     const u8 *mac,
 #endif
-	struct station_info *sinfo)
+				     struct station_info *sinfo)
 {
-    struct rwnx_vif *vif = netdev_priv(dev);
-    struct rwnx_sta *sta = NULL;
-
-    if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MONITOR)
-        return -EINVAL;
-    else if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_STATION) ||
-             (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_P2P_CLIENT)) {
-        if (vif->sta.ap && ether_addr_equal(vif->sta.ap->mac_addr, mac))
-            sta = vif->sta.ap;
-    }
-    else
-    {
-        struct rwnx_sta *sta_iter;
+	struct rwnx_vif *vif = netdev_priv(dev);
+	struct rwnx_sta *sta = NULL;
+
+	if (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_MONITOR)
+		return -EINVAL;
+	else if ((RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_STATION) ||
+		 (RWNX_VIF_TYPE(vif) == NL80211_IFTYPE_P2P_CLIENT)) {
+		if (vif->sta.ap && ether_addr_equal(vif->sta.ap->mac_addr, mac))
+			sta = vif->sta.ap;
+	} else {
+		struct rwnx_sta *sta_iter;
 		spin_lock_bh(&vif->rwnx_hw->cb_lock);
-        list_for_each_entry(sta_iter, &vif->ap.sta_list, list) {
-            if (sta_iter->valid && ether_addr_equal(sta_iter->mac_addr, mac)) {
-                sta = sta_iter;
-                break;
-            }
-        }
+		list_for_each_entry(sta_iter, &vif->ap.sta_list, list) {
+			if (sta_iter->valid &&
+			    ether_addr_equal(sta_iter->mac_addr, mac)) {
+				sta = sta_iter;
+				break;
+			}
+		}
 		spin_unlock_bh(&vif->rwnx_hw->cb_lock);
-    }
+	}
 
-    if (sta)
-        return rwnx_fill_station_info(sta, vif, sinfo);
+	if (sta)
+		return rwnx_fill_station_info(sta, vif, sinfo);
 
-    return -ENOENT;
+	return -ENOENT;
 }
 
-
 /**
  * @dump_station: dump station callback -- resume dump at index @idx
  */
-static int rwnx_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
-                                      int idx, u8 *mac, struct station_info *sinfo)
+static int rwnx_cfg80211_dump_station(struct wiphy *wiphy,
+				      struct net_device *dev, int idx, u8 *mac,
+				      struct station_info *sinfo)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_sta *sta_iter, *sta = NULL;
-    struct mesh_peer_info_cfm peer_info_cfm;
-    int i = 0;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_sta *sta_iter, *sta = NULL;
+	struct mesh_peer_info_cfm peer_info_cfm;
+	int i = 0;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    list_for_each_entry(sta_iter, &rwnx_vif->ap.sta_list, list) {
-        if (i < idx) {
-            i++;
-            continue;
-        }
+	list_for_each_entry(sta_iter, &rwnx_vif->ap.sta_list, list) {
+		if (i < idx) {
+			i++;
+			continue;
+		}
 
-        sta = sta_iter;
-        break;
-    }
+		sta = sta_iter;
+		break;
+	}
 
-    if (sta == NULL)
-        return -ENOENT;
+	if (sta == NULL)
+		return -ENOENT;
 
-    /* Forward the information to the UMAC */
-    if (rwnx_send_mesh_peer_info_req(rwnx_hw, rwnx_vif, sta->sta_idx,
-                                     &peer_info_cfm))
-        return -ENOMEM;
+	/* Forward the information to the UMAC */
+	if (rwnx_send_mesh_peer_info_req(rwnx_hw, rwnx_vif, sta->sta_idx,
+					 &peer_info_cfm))
+		return -ENOMEM;
 
-    /* Copy peer MAC address */
-    memcpy(mac, &sta->mac_addr, ETH_ALEN);
+	/* Copy peer MAC address */
+	memcpy(mac, &sta->mac_addr, ETH_ALEN);
 
-    /* Fill station information */
-    sinfo->llid = peer_info_cfm.local_link_id;
-    sinfo->plid = peer_info_cfm.peer_link_id;
-    sinfo->plink_state = peer_info_cfm.link_state;
-    sinfo->local_pm = peer_info_cfm.local_ps_mode;
-    sinfo->peer_pm = peer_info_cfm.peer_ps_mode;
-    sinfo->nonpeer_pm = peer_info_cfm.non_peer_ps_mode;
+	/* Fill station information */
+	sinfo->llid = peer_info_cfm.local_link_id;
+	sinfo->plid = peer_info_cfm.peer_link_id;
+	sinfo->plink_state = peer_info_cfm.link_state;
+	sinfo->local_pm = peer_info_cfm.local_ps_mode;
+	sinfo->peer_pm = peer_info_cfm.peer_ps_mode;
+	sinfo->nonpeer_pm = peer_info_cfm.non_peer_ps_mode;
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
-    sinfo->filled = (STATION_INFO_LLID |
-                     STATION_INFO_PLID |
-                     STATION_INFO_PLINK_STATE |
-                     STATION_INFO_LOCAL_PM |
-                     STATION_INFO_PEER_PM |
-                     STATION_INFO_NONPEER_PM);
+	sinfo->filled = (STATION_INFO_LLID | STATION_INFO_PLID |
+			 STATION_INFO_PLINK_STATE | STATION_INFO_LOCAL_PM |
+			 STATION_INFO_PEER_PM | STATION_INFO_NONPEER_PM);
 #else
-    sinfo->filled = (BIT(NL80211_STA_INFO_LLID) |
-                     BIT(NL80211_STA_INFO_PLID) |
-                     BIT(NL80211_STA_INFO_PLINK_STATE) |
-                     BIT(NL80211_STA_INFO_LOCAL_PM) |
-                     BIT(NL80211_STA_INFO_PEER_PM) |
-                     BIT(NL80211_STA_INFO_NONPEER_PM));
+	sinfo->filled =
+		(BIT(NL80211_STA_INFO_LLID) | BIT(NL80211_STA_INFO_PLID) |
+		 BIT(NL80211_STA_INFO_PLINK_STATE) |
+		 BIT(NL80211_STA_INFO_LOCAL_PM) |
+		 BIT(NL80211_STA_INFO_PEER_PM) |
+		 BIT(NL80211_STA_INFO_NONPEER_PM));
 #endif
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -6517,22 +5547,21 @@ static int rwnx_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *de
  */
 static int rwnx_cfg80211_add_mpath(struct wiphy *wiphy, struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-	u8 *dst,
-	u8 *next_hop
+				   u8 *dst, u8 *next_hop
 #else
-	const u8 *dst,
-	const u8 *next_hop
+				   const u8 *dst, const u8 *next_hop
 #endif
 )
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct mesh_path_update_cfm cfm;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct mesh_path_update_cfm cfm;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, next_hop, &cfm);
+	return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, next_hop,
+					      &cfm);
 }
 
 /**
@@ -6540,120 +5569,122 @@ static int rwnx_cfg80211_add_mpath(struct wiphy *wiphy, struct net_device *dev,
  */
 static int rwnx_cfg80211_del_mpath(struct wiphy *wiphy, struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-	u8 *dst
+				   u8 *dst
 #else
-	const u8 *dst
+				   const u8 *dst
 #endif
 )
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct mesh_path_update_cfm cfm;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct mesh_path_update_cfm cfm;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, NULL, &cfm);
+	return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, NULL,
+					      &cfm);
 }
 
 /**
  * @change_mpath: change a given mesh path
  */
-static int rwnx_cfg80211_change_mpath(struct wiphy *wiphy, struct net_device *dev,
+static int rwnx_cfg80211_change_mpath(struct wiphy *wiphy,
+				      struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 16, 0))
-		u8 *dst,
-		u8 *next_hop
+				      u8 *dst, u8 *next_hop
 #else
-		const u8 *dst,
-		const u8 *next_hop
+				      const u8 *dst, const u8 *next_hop
 #endif
 )
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct mesh_path_update_cfm cfm;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct mesh_path_update_cfm cfm;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, next_hop, &cfm);
+	return rwnx_send_mesh_path_update_req(rwnx_hw, rwnx_vif, dst, next_hop,
+					      &cfm);
 }
 
 /**
  * @get_mpath: get a mesh path for the given parameters
  */
 static int rwnx_cfg80211_get_mpath(struct wiphy *wiphy, struct net_device *dev,
-                                   u8 *dst, u8 *next_hop, struct mpath_info *pinfo)
+				   u8 *dst, u8 *next_hop,
+				   struct mpath_info *pinfo)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_mesh_path *mesh_path = NULL;
-    struct rwnx_mesh_path *cur;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_mesh_path *mesh_path = NULL;
+	struct rwnx_mesh_path *cur;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    list_for_each_entry(cur, &rwnx_vif->ap.mpath_list, list) {
-        /* Compare the path target address and the provided destination address */
-        if (memcmp(dst, &cur->tgt_mac_addr, ETH_ALEN)) {
-            continue;
-        }
+	list_for_each_entry(cur, &rwnx_vif->ap.mpath_list, list) {
+		/* Compare the path target address and the provided destination address */
+		if (memcmp(dst, &cur->tgt_mac_addr, ETH_ALEN)) {
+			continue;
+		}
 
-        mesh_path = cur;
-        break;
-    }
+		mesh_path = cur;
+		break;
+	}
 
-    if (mesh_path == NULL)
-        return -ENOENT;
+	if (mesh_path == NULL)
+		return -ENOENT;
 
-    /* Copy next HOP MAC address */
-    if (mesh_path->p_nhop_sta)
-        memcpy(next_hop, &mesh_path->p_nhop_sta->mac_addr, ETH_ALEN);
+	/* Copy next HOP MAC address */
+	if (mesh_path->p_nhop_sta)
+		memcpy(next_hop, &mesh_path->p_nhop_sta->mac_addr, ETH_ALEN);
 
-    /* Fill path information */
-    pinfo->filled = 0;
-    pinfo->generation = rwnx_vif->ap.generation;
+	/* Fill path information */
+	pinfo->filled = 0;
+	pinfo->generation = rwnx_vif->ap.generation;
 
-    return 0;
+	return 0;
 }
 
 /**
  * @dump_mpath: dump mesh path callback -- resume dump at index @idx
  */
 static int rwnx_cfg80211_dump_mpath(struct wiphy *wiphy, struct net_device *dev,
-                                    int idx, u8 *dst, u8 *next_hop,
-                                    struct mpath_info *pinfo)
+				    int idx, u8 *dst, u8 *next_hop,
+				    struct mpath_info *pinfo)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_mesh_path *mesh_path = NULL;
-    struct rwnx_mesh_path *cur;
-    int i = 0;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_mesh_path *mesh_path = NULL;
+	struct rwnx_mesh_path *cur;
+	int i = 0;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    list_for_each_entry(cur, &rwnx_vif->ap.mpath_list, list) {
-        if (i < idx) {
-            i++;
-            continue;
-        }
+	list_for_each_entry(cur, &rwnx_vif->ap.mpath_list, list) {
+		if (i < idx) {
+			i++;
+			continue;
+		}
 
-        mesh_path = cur;
-        break;
-    }
+		mesh_path = cur;
+		break;
+	}
 
-    if (mesh_path == NULL)
-        return -ENOENT;
+	if (mesh_path == NULL)
+		return -ENOENT;
 
-    /* Copy target and next hop MAC address */
-    memcpy(dst, &mesh_path->tgt_mac_addr, ETH_ALEN);
-    if (mesh_path->p_nhop_sta)
-        memcpy(next_hop, &mesh_path->p_nhop_sta->mac_addr, ETH_ALEN);
+	/* Copy target and next hop MAC address */
+	memcpy(dst, &mesh_path->tgt_mac_addr, ETH_ALEN);
+	if (mesh_path->p_nhop_sta)
+		memcpy(next_hop, &mesh_path->p_nhop_sta->mac_addr, ETH_ALEN);
 
-    /* Fill path information */
-    pinfo->filled = 0;
-    pinfo->generation = rwnx_vif->ap.generation;
+	/* Fill path information */
+	pinfo->filled = 0;
+	pinfo->generation = rwnx_vif->ap.generation;
 
-    return 0;
+	return 0;
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
@@ -6661,132 +5692,136 @@ static int rwnx_cfg80211_dump_mpath(struct wiphy *wiphy, struct net_device *dev,
  * @get_mpp: get a mesh proxy path for the given parameters
  */
 static int rwnx_cfg80211_get_mpp(struct wiphy *wiphy, struct net_device *dev,
-                                 u8 *dst, u8 *mpp, struct mpath_info *pinfo)
+				 u8 *dst, u8 *mpp, struct mpath_info *pinfo)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_mesh_proxy *mesh_proxy = NULL;
-    struct rwnx_mesh_proxy *cur;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_mesh_proxy *mesh_proxy = NULL;
+	struct rwnx_mesh_proxy *cur;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    list_for_each_entry(cur, &rwnx_vif->ap.proxy_list, list) {
-        if (cur->local) {
-            continue;
-        }
+	list_for_each_entry(cur, &rwnx_vif->ap.proxy_list, list) {
+		if (cur->local) {
+			continue;
+		}
 
-        /* Compare the path target address and the provided destination address */
-        if (memcmp(dst, &cur->ext_sta_addr, ETH_ALEN)) {
-            continue;
-        }
+		/* Compare the path target address and the provided destination address */
+		if (memcmp(dst, &cur->ext_sta_addr, ETH_ALEN)) {
+			continue;
+		}
 
-        mesh_proxy = cur;
-        break;
-    }
+		mesh_proxy = cur;
+		break;
+	}
 
-    if (mesh_proxy == NULL)
-        return -ENOENT;
+	if (mesh_proxy == NULL)
+		return -ENOENT;
 
-    memcpy(mpp, &mesh_proxy->proxy_addr, ETH_ALEN);
+	memcpy(mpp, &mesh_proxy->proxy_addr, ETH_ALEN);
 
-    /* Fill path information */
-    pinfo->filled = 0;
-    pinfo->generation = rwnx_vif->ap.generation;
+	/* Fill path information */
+	pinfo->filled = 0;
+	pinfo->generation = rwnx_vif->ap.generation;
 
-    return 0;
+	return 0;
 }
 
 /**
  * @dump_mpp: dump mesh proxy path callback -- resume dump at index @idx
  */
 static int rwnx_cfg80211_dump_mpp(struct wiphy *wiphy, struct net_device *dev,
-                                  int idx, u8 *dst, u8 *mpp, struct mpath_info *pinfo)
+				  int idx, u8 *dst, u8 *mpp,
+				  struct mpath_info *pinfo)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_mesh_proxy *mesh_proxy = NULL;
-    struct rwnx_mesh_proxy *cur;
-    int i = 0;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_mesh_proxy *mesh_proxy = NULL;
+	struct rwnx_mesh_proxy *cur;
+	int i = 0;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    list_for_each_entry(cur, &rwnx_vif->ap.proxy_list, list) {
-        if (cur->local) {
-            continue;
-        }
+	list_for_each_entry(cur, &rwnx_vif->ap.proxy_list, list) {
+		if (cur->local) {
+			continue;
+		}
 
-        if (i < idx) {
-            i++;
-            continue;
-        }
+		if (i < idx) {
+			i++;
+			continue;
+		}
 
-        mesh_proxy = cur;
-        break;
-    }
+		mesh_proxy = cur;
+		break;
+	}
 
-    if (mesh_proxy == NULL)
-        return -ENOENT;
+	if (mesh_proxy == NULL)
+		return -ENOENT;
 
-    /* Copy target MAC address */
-    memcpy(dst, &mesh_proxy->ext_sta_addr, ETH_ALEN);
-    memcpy(mpp, &mesh_proxy->proxy_addr, ETH_ALEN);
+	/* Copy target MAC address */
+	memcpy(dst, &mesh_proxy->ext_sta_addr, ETH_ALEN);
+	memcpy(mpp, &mesh_proxy->proxy_addr, ETH_ALEN);
 
-    /* Fill path information */
-    pinfo->filled = 0;
-    pinfo->generation = rwnx_vif->ap.generation;
+	/* Fill path information */
+	pinfo->filled = 0;
+	pinfo->generation = rwnx_vif->ap.generation;
 
-    return 0;
+	return 0;
 }
 #endif /* version >= 3.19 */
 
 /**
  * @get_mesh_config: Get the current mesh configuration
  */
-static int rwnx_cfg80211_get_mesh_config(struct wiphy *wiphy, struct net_device *dev,
-                                         struct mesh_config *conf)
+static int rwnx_cfg80211_get_mesh_config(struct wiphy *wiphy,
+					 struct net_device *dev,
+					 struct mesh_config *conf)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    return 0;
+	return 0;
 }
 
 /**
  * @update_mesh_config: Update mesh parameters on a running mesh.
  */
-static int rwnx_cfg80211_update_mesh_config(struct wiphy *wiphy, struct net_device *dev,
-                                            u32 mask, const struct mesh_config *nconf)
+static int rwnx_cfg80211_update_mesh_config(struct wiphy *wiphy,
+					    struct net_device *dev, u32 mask,
+					    const struct mesh_config *nconf)
 {
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct mesh_update_cfm cfm;
-    int status;
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct mesh_update_cfm cfm;
+	int status;
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    if (mask & CO_BIT(NL80211_MESHCONF_POWER_MODE - 1)) {
-        rwnx_vif->ap.next_mesh_pm = nconf->power_mode;
+	if (mask & CO_BIT(NL80211_MESHCONF_POWER_MODE - 1)) {
+		rwnx_vif->ap.next_mesh_pm = nconf->power_mode;
 
-        if (!list_empty(&rwnx_vif->ap.sta_list)) {
-            // If there are mesh links we don't want to update the power mode
-            // It will be updated with rwnx_update_mesh_power_mode() when the
-            // ps mode of a link is updated or when a new link is added/removed
-            mask &= ~BIT(NL80211_MESHCONF_POWER_MODE - 1);
+		if (!list_empty(&rwnx_vif->ap.sta_list)) {
+			// If there are mesh links we don't want to update the power mode
+			// It will be updated with rwnx_update_mesh_power_mode() when the
+			// ps mode of a link is updated or when a new link is added/removed
+			mask &= ~BIT(NL80211_MESHCONF_POWER_MODE - 1);
 
-            if (!mask)
-                return 0;
-        }
-    }
+			if (!mask)
+				return 0;
+		}
+	}
 
-    status = rwnx_send_mesh_update_req(rwnx_hw, rwnx_vif, mask, nconf, &cfm);
+	status =
+		rwnx_send_mesh_update_req(rwnx_hw, rwnx_vif, mask, nconf, &cfm);
 
-    if (!status && (cfm.status != 0))
-        status = -EINVAL;
+	if (!status && (cfm.status != 0))
+		status = -EINVAL;
 
-    return status;
+	return status;
 }
 
 /**
@@ -6794,83 +5829,86 @@ static int rwnx_cfg80211_update_mesh_config(struct wiphy *wiphy, struct net_devi
  * (invoked with the wireless_dev mutex held)
  */
 static int rwnx_cfg80211_join_mesh(struct wiphy *wiphy, struct net_device *dev,
-                                   const struct mesh_config *conf, const struct mesh_setup *setup)
+				   const struct mesh_config *conf,
+				   const struct mesh_setup *setup)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct mesh_start_cfm mesh_start_cfm;
-    int error = 0;
-    u8 txq_status = 0;
-    /* STA for BC/MC traffic */
-    struct rwnx_sta *sta;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct mesh_start_cfm mesh_start_cfm;
+	int error = 0;
+	u8 txq_status = 0;
+	/* STA for BC/MC traffic */
+	struct rwnx_sta *sta;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
-        return -ENOTSUPP;
+	if (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_MESH_POINT)
+		return -ENOTSUPP;
 
-    /* Forward the information to the UMAC */
-    if ((error = rwnx_send_mesh_start_req(rwnx_hw, rwnx_vif, conf, setup, &mesh_start_cfm))) {
-        return error;
-    }
+	/* Forward the information to the UMAC */
+	if ((error = rwnx_send_mesh_start_req(rwnx_hw, rwnx_vif, conf, setup,
+					      &mesh_start_cfm))) {
+		return error;
+	}
+
+	/* Check the status */
+	switch (mesh_start_cfm.status) {
+	case CO_OK:
+		rwnx_vif->ap.bcmc_index = mesh_start_cfm.bcmc_idx;
+		rwnx_vif->ap.flags = 0;
+		rwnx_vif->use_4addr = true;
+		rwnx_vif->user_mpm = setup->user_mpm;
+
+		sta = &rwnx_hw->sta_table[mesh_start_cfm.bcmc_idx];
+		sta->valid = true;
+		sta->aid = 0;
+		sta->sta_idx = mesh_start_cfm.bcmc_idx;
+		sta->ch_idx = mesh_start_cfm.ch_idx;
+		sta->vif_idx = rwnx_vif->vif_index;
+		sta->qos = true;
+		sta->acm = 0;
+		sta->ps.active = false;
+		rwnx_mu_group_sta_init(sta, NULL);
+		spin_lock_bh(&rwnx_hw->cb_lock);
+		rwnx_chanctx_link(
+			rwnx_vif, mesh_start_cfm.ch_idx,
+			(struct cfg80211_chan_def *)(&setup->chandef));
+		if (rwnx_hw->cur_chanctx != mesh_start_cfm.ch_idx) {
+			txq_status = RWNX_TXQ_STOP_CHAN;
+		}
+		rwnx_txq_vif_init(rwnx_hw, rwnx_vif, txq_status);
+		spin_unlock_bh(&rwnx_hw->cb_lock);
+
+		netif_tx_start_all_queues(dev);
+		netif_carrier_on(dev);
 
-    /* Check the status */
-    switch (mesh_start_cfm.status) {
-        case CO_OK:
-            rwnx_vif->ap.bcmc_index = mesh_start_cfm.bcmc_idx;
-            rwnx_vif->ap.flags = 0;
-            rwnx_vif->use_4addr = true;
-            rwnx_vif->user_mpm = setup->user_mpm;
-
-            sta = &rwnx_hw->sta_table[mesh_start_cfm.bcmc_idx];
-            sta->valid = true;
-            sta->aid = 0;
-            sta->sta_idx = mesh_start_cfm.bcmc_idx;
-            sta->ch_idx = mesh_start_cfm.ch_idx;
-            sta->vif_idx = rwnx_vif->vif_index;
-            sta->qos = true;
-            sta->acm = 0;
-            sta->ps.active = false;
-            rwnx_mu_group_sta_init(sta, NULL);
-            spin_lock_bh(&rwnx_hw->cb_lock);
-            rwnx_chanctx_link(rwnx_vif, mesh_start_cfm.ch_idx,
-                              (struct cfg80211_chan_def *)(&setup->chandef));
-            if (rwnx_hw->cur_chanctx != mesh_start_cfm.ch_idx) {
-                txq_status = RWNX_TXQ_STOP_CHAN;
-            }
-            rwnx_txq_vif_init(rwnx_hw, rwnx_vif, txq_status);
-            spin_unlock_bh(&rwnx_hw->cb_lock);
-
-            netif_tx_start_all_queues(dev);
-            netif_carrier_on(dev);
-
-            /* If the AP channel is already the active, we probably skip radar
+		/* If the AP channel is already the active, we probably skip radar
                activation on MM_CHANNEL_SWITCH_IND (unless another vif use this
                ctxt). In anycase retest if radar detection must be activated
              */
-            if (rwnx_hw->cur_chanctx == mesh_start_cfm.ch_idx) {
-                rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
-            }
-            break;
-
-        case CO_BUSY:
-            error = -EINPROGRESS;
-            break;
-
-        default:
-            error = -EIO;
-            break;
-    }
+		if (rwnx_hw->cur_chanctx == mesh_start_cfm.ch_idx) {
+			rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
+		}
+		break;
 
-    /* Print information about the operation */
-    if (error) {
-        netdev_info(dev, "Failed to start MP (%d)", error);
-    } else {
-        netdev_info(dev, "MP started: ch=%d, bcmc_idx=%d",
-                    rwnx_vif->ch_index, rwnx_vif->ap.bcmc_index);
-    }
+	case CO_BUSY:
+		error = -EINPROGRESS;
+		break;
+
+	default:
+		error = -EIO;
+		break;
+	}
 
-    return error;
+	/* Print information about the operation */
+	if (error) {
+		netdev_info(dev, "Failed to start MP (%d)", error);
+	} else {
+		netdev_info(dev, "MP started: ch=%d, bcmc_idx=%d",
+			    rwnx_vif->ch_index, rwnx_vif->ap.bcmc_index);
+	}
+
+	return error;
 }
 
 /**
@@ -6879,211 +5917,208 @@ static int rwnx_cfg80211_join_mesh(struct wiphy *wiphy, struct net_device *dev,
  */
 static int rwnx_cfg80211_leave_mesh(struct wiphy *wiphy, struct net_device *dev)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
-    struct rwnx_vif *rwnx_vif = netdev_priv(dev);
-    struct mesh_stop_cfm mesh_stop_cfm;
-    int error = 0;
-
-    error = rwnx_send_mesh_stop_req(rwnx_hw, rwnx_vif, &mesh_stop_cfm);
-
-    if (error == 0) {
-        /* Check the status */
-        switch (mesh_stop_cfm.status) {
-            case CO_OK:
-                spin_lock_bh(&rwnx_hw->cb_lock);
-                rwnx_chanctx_unlink(rwnx_vif);
-                rwnx_radar_cancel_cac(&rwnx_hw->radar);
-                spin_unlock_bh(&rwnx_hw->cb_lock);
-                /* delete BC/MC STA */
-                rwnx_txq_vif_deinit(rwnx_hw, rwnx_vif);
-                rwnx_del_bcn(&rwnx_vif->ap.bcn);
-
-                netif_tx_stop_all_queues(dev);
-                netif_carrier_off(dev);
-
-                break;
-
-            default:
-                error = -EIO;
-                break;
-        }
-    }
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	struct mesh_stop_cfm mesh_stop_cfm;
+	int error = 0;
 
-    if (error) {
-        netdev_info(dev, "Failed to stop MP");
-    } else {
-        netdev_info(dev, "MP Stopped");
-    }
+	error = rwnx_send_mesh_stop_req(rwnx_hw, rwnx_vif, &mesh_stop_cfm);
 
-    return 0;
+	if (error == 0) {
+		/* Check the status */
+		switch (mesh_stop_cfm.status) {
+		case CO_OK:
+			spin_lock_bh(&rwnx_hw->cb_lock);
+			rwnx_chanctx_unlink(rwnx_vif);
+			rwnx_radar_cancel_cac(&rwnx_hw->radar);
+			spin_unlock_bh(&rwnx_hw->cb_lock);
+			/* delete BC/MC STA */
+			rwnx_txq_vif_deinit(rwnx_hw, rwnx_vif);
+			rwnx_del_bcn(&rwnx_vif->ap.bcn);
+
+			netif_tx_stop_all_queues(dev);
+			netif_carrier_off(dev);
+
+			break;
+
+		default:
+			error = -EIO;
+			break;
+		}
+	}
+
+	if (error) {
+		netdev_info(dev, "Failed to stop MP");
+	} else {
+		netdev_info(dev, "MP Stopped");
+	}
+
+	return 0;
 }
 
 static struct cfg80211_ops rwnx_cfg80211_ops = {
-    .add_virtual_intf = rwnx_cfg80211_add_iface,
-    .del_virtual_intf = rwnx_cfg80211_del_iface,
-    .change_virtual_intf = rwnx_cfg80211_change_iface,
-    .start_p2p_device = rwnx_cfgp2p_start_p2p_device,
-    .stop_p2p_device = rwnx_cfgp2p_stop_p2p_device,
-    .scan = rwnx_cfg80211_scan,
-    .connect = rwnx_cfg80211_connect,
-    .disconnect = rwnx_cfg80211_disconnect,
-    .add_key = rwnx_cfg80211_add_key,
-    .get_key = rwnx_cfg80211_get_key,
-    .del_key = rwnx_cfg80211_del_key,
-    .set_default_key = rwnx_cfg80211_set_default_key,
-    .set_default_mgmt_key = rwnx_cfg80211_set_default_mgmt_key,
-    .add_station = rwnx_cfg80211_add_station,
-    .del_station = rwnx_cfg80211_del_station_compat,
-    .change_station = rwnx_cfg80211_change_station,
-    .mgmt_tx = rwnx_cfg80211_mgmt_tx,
-    .start_ap = rwnx_cfg80211_start_ap,
-    .change_beacon = rwnx_cfg80211_change_beacon,
-    .stop_ap = rwnx_cfg80211_stop_ap,
-    .set_monitor_channel = rwnx_cfg80211_set_monitor_channel,
-    .probe_client = rwnx_cfg80211_probe_client,
-//    .mgmt_frame_register = rwnx_cfg80211_mgmt_frame_register,
-    .set_wiphy_params = rwnx_cfg80211_set_wiphy_params,
-    .set_txq_params = rwnx_cfg80211_set_txq_params,
-    .set_tx_power = rwnx_cfg80211_set_tx_power,
-//    .get_tx_power = rwnx_cfg80211_get_tx_power,
-    .set_power_mgmt = rwnx_cfg80211_set_power_mgmt,
-    .get_station = rwnx_cfg80211_get_station,
-    .remain_on_channel = rwnx_cfg80211_remain_on_channel,
-    .cancel_remain_on_channel = rwnx_cfg80211_cancel_remain_on_channel,
-    .dump_survey = rwnx_cfg80211_dump_survey,
-    .get_channel = rwnx_cfg80211_get_channel,
-    .start_radar_detection = rwnx_cfg80211_start_radar_detection,
-    .update_ft_ies = rwnx_cfg80211_update_ft_ies,
-    .set_cqm_rssi_config = rwnx_cfg80211_set_cqm_rssi_config,
+	.add_virtual_intf = rwnx_cfg80211_add_iface,
+	.del_virtual_intf = rwnx_cfg80211_del_iface,
+	.change_virtual_intf = rwnx_cfg80211_change_iface,
+	.start_p2p_device = rwnx_cfgp2p_start_p2p_device,
+	.stop_p2p_device = rwnx_cfgp2p_stop_p2p_device,
+	.scan = rwnx_cfg80211_scan,
+	.connect = rwnx_cfg80211_connect,
+	.disconnect = rwnx_cfg80211_disconnect,
+	.add_key = rwnx_cfg80211_add_key,
+	.get_key = rwnx_cfg80211_get_key,
+	.del_key = rwnx_cfg80211_del_key,
+	.set_default_key = rwnx_cfg80211_set_default_key,
+	.set_default_mgmt_key = rwnx_cfg80211_set_default_mgmt_key,
+	.add_station = rwnx_cfg80211_add_station,
+	.del_station = rwnx_cfg80211_del_station_compat,
+	.change_station = rwnx_cfg80211_change_station,
+	.mgmt_tx = rwnx_cfg80211_mgmt_tx,
+	.start_ap = rwnx_cfg80211_start_ap,
+	.change_beacon = rwnx_cfg80211_change_beacon,
+	.stop_ap = rwnx_cfg80211_stop_ap,
+	.set_monitor_channel = rwnx_cfg80211_set_monitor_channel,
+	.probe_client = rwnx_cfg80211_probe_client,
+	//    .mgmt_frame_register = rwnx_cfg80211_mgmt_frame_register,
+	.set_wiphy_params = rwnx_cfg80211_set_wiphy_params,
+	.set_txq_params = rwnx_cfg80211_set_txq_params,
+	.set_tx_power = rwnx_cfg80211_set_tx_power,
+	//    .get_tx_power = rwnx_cfg80211_get_tx_power,
+	.set_power_mgmt = rwnx_cfg80211_set_power_mgmt,
+	.get_station = rwnx_cfg80211_get_station,
+	.remain_on_channel = rwnx_cfg80211_remain_on_channel,
+	.cancel_remain_on_channel = rwnx_cfg80211_cancel_remain_on_channel,
+	.dump_survey = rwnx_cfg80211_dump_survey,
+	.get_channel = rwnx_cfg80211_get_channel,
+	.start_radar_detection = rwnx_cfg80211_start_radar_detection,
+	.update_ft_ies = rwnx_cfg80211_update_ft_ies,
+	.set_cqm_rssi_config = rwnx_cfg80211_set_cqm_rssi_config,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
-    .channel_switch = rwnx_cfg80211_channel_switch,
+	.channel_switch = rwnx_cfg80211_channel_switch,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-    //.tdls_channel_switch = rwnx_cfg80211_tdls_channel_switch,
-    //.tdls_cancel_channel_switch = rwnx_cfg80211_tdls_cancel_channel_switch,
+//.tdls_channel_switch = rwnx_cfg80211_tdls_channel_switch,
+//.tdls_cancel_channel_switch = rwnx_cfg80211_tdls_cancel_channel_switch,
 #endif
-    //.tdls_mgmt = rwnx_cfg80211_tdls_mgmt,
-    //.tdls_oper = rwnx_cfg80211_tdls_oper,
-    .change_bss = rwnx_cfg80211_change_bss,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
-    .external_auth = rwnx_cfg80211_external_auth,
+	//.tdls_mgmt = rwnx_cfg80211_tdls_mgmt,
+	//.tdls_oper = rwnx_cfg80211_tdls_oper,
+	.change_bss = rwnx_cfg80211_change_bss,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || \
+	defined(CONFIG_WPA3_FOR_OLD_KERNEL)
+	.external_auth = rwnx_cfg80211_external_auth,
 #endif
 #ifdef CONFIG_SCHED_SCAN
-    .sched_scan_start = rwnx_cfg80211_sched_scan_start,
-    .sched_scan_stop = rwnx_cfg80211_sched_scan_stop,
+	.sched_scan_start = rwnx_cfg80211_sched_scan_start,
+	.sched_scan_stop = rwnx_cfg80211_sched_scan_stop,
 #endif
 
 };
 
-
 /*********************************************************************
  * Init/Exit functions
  *********************************************************************/
 static void rwnx_wdev_unregister(struct rwnx_hw *rwnx_hw)
 {
-    struct rwnx_vif *rwnx_vif, *tmp;
-
-    rtnl_lock();
-    list_for_each_entry_safe(rwnx_vif, tmp, &rwnx_hw->vifs, list) {
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
-        rwnx_cfg80211_del_iface(rwnx_hw->wiphy, &rwnx_vif->wdev);
-    #else
-        rwnx_cfg80211_del_iface(rwnx_hw->wiphy, rwnx_vif->ndev);
-    #endif
-    }
-    rtnl_unlock();
+	struct rwnx_vif *rwnx_vif, *tmp;
+
+	rtnl_lock();
+	list_for_each_entry_safe(rwnx_vif, tmp, &rwnx_hw->vifs, list) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		rwnx_cfg80211_del_iface(rwnx_hw->wiphy, &rwnx_vif->wdev);
+#else
+		rwnx_cfg80211_del_iface(rwnx_hw->wiphy, rwnx_vif->ndev);
+#endif
+	}
+	rtnl_unlock();
 }
 
 static void rwnx_set_vers(struct rwnx_hw *rwnx_hw)
 {
-    u32 vers = rwnx_hw->version_cfm.version_lmac;
+	u32 vers = rwnx_hw->version_cfm.version_lmac;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
-    snprintf(rwnx_hw->wiphy->fw_version,
-             sizeof(rwnx_hw->wiphy->fw_version), "%d.%d.%d.%d",
-             (vers & (0xff << 24)) >> 24, (vers & (0xff << 16)) >> 16,
-             (vers & (0xff <<  8)) >>  8, (vers & (0xff <<  0)) >>  0);
+	snprintf(rwnx_hw->wiphy->fw_version, sizeof(rwnx_hw->wiphy->fw_version),
+		 "%d.%d.%d.%d", (vers & (0xff << 24)) >> 24,
+		 (vers & (0xff << 16)) >> 16, (vers & (0xff << 8)) >> 8,
+		 (vers & (0xff << 0)) >> 0);
 }
 
 static void rwnx_reg_notifier(struct wiphy *wiphy,
-                              struct regulatory_request *request)
+			      struct regulatory_request *request)
 {
-    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 
-    printk("%s Enter\r\n", __func__);
+	printk("%s Enter\r\n", __func__);
 
-    // For now trust all initiator
-    rwnx_radar_set_domain(&rwnx_hw->radar, request->dfs_region);
+	// For now trust all initiator
+	rwnx_radar_set_domain(&rwnx_hw->radar, request->dfs_region);
 
 	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
-		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		 rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)){
-    		rwnx_send_me_chan_config_req(rwnx_hw);
-		}
+	    ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	     testmode == 0)) {
+		rwnx_send_me_chan_config_req(rwnx_hw);
+	}
 }
 
 static void rwnx_enable_mesh(struct rwnx_hw *rwnx_hw)
 {
-    struct wiphy *wiphy = rwnx_hw->wiphy;
+	struct wiphy *wiphy = rwnx_hw->wiphy;
 
-    if (!rwnx_mod_params.mesh)
-        return;
+	if (!rwnx_mod_params.mesh)
+		return;
 
-    rwnx_cfg80211_ops.get_station = rwnx_cfg80211_get_station;
-    rwnx_cfg80211_ops.dump_station = rwnx_cfg80211_dump_station;
-    rwnx_cfg80211_ops.add_mpath = rwnx_cfg80211_add_mpath;
-    rwnx_cfg80211_ops.del_mpath = rwnx_cfg80211_del_mpath;
-    rwnx_cfg80211_ops.change_mpath = rwnx_cfg80211_change_mpath;
-    rwnx_cfg80211_ops.get_mpath = rwnx_cfg80211_get_mpath;
-    rwnx_cfg80211_ops.dump_mpath = rwnx_cfg80211_dump_mpath;
+	rwnx_cfg80211_ops.get_station = rwnx_cfg80211_get_station;
+	rwnx_cfg80211_ops.dump_station = rwnx_cfg80211_dump_station;
+	rwnx_cfg80211_ops.add_mpath = rwnx_cfg80211_add_mpath;
+	rwnx_cfg80211_ops.del_mpath = rwnx_cfg80211_del_mpath;
+	rwnx_cfg80211_ops.change_mpath = rwnx_cfg80211_change_mpath;
+	rwnx_cfg80211_ops.get_mpath = rwnx_cfg80211_get_mpath;
+	rwnx_cfg80211_ops.dump_mpath = rwnx_cfg80211_dump_mpath;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-    rwnx_cfg80211_ops.get_mpp = rwnx_cfg80211_get_mpp;
-    rwnx_cfg80211_ops.dump_mpp = rwnx_cfg80211_dump_mpp;
+	rwnx_cfg80211_ops.get_mpp = rwnx_cfg80211_get_mpp;
+	rwnx_cfg80211_ops.dump_mpp = rwnx_cfg80211_dump_mpp;
 #endif
-    rwnx_cfg80211_ops.get_mesh_config = rwnx_cfg80211_get_mesh_config;
-    rwnx_cfg80211_ops.update_mesh_config = rwnx_cfg80211_update_mesh_config;
-    rwnx_cfg80211_ops.join_mesh = rwnx_cfg80211_join_mesh;
-    rwnx_cfg80211_ops.leave_mesh = rwnx_cfg80211_leave_mesh;
+	rwnx_cfg80211_ops.get_mesh_config = rwnx_cfg80211_get_mesh_config;
+	rwnx_cfg80211_ops.update_mesh_config = rwnx_cfg80211_update_mesh_config;
+	rwnx_cfg80211_ops.join_mesh = rwnx_cfg80211_join_mesh;
+	rwnx_cfg80211_ops.leave_mesh = rwnx_cfg80211_leave_mesh;
 
-    wiphy->flags |= (WIPHY_FLAG_MESH_AUTH | WIPHY_FLAG_IBSS_RSN);
-    wiphy->features |= NL80211_FEATURE_USERSPACE_MPM;
-    wiphy->interface_modes |= BIT(NL80211_IFTYPE_MESH_POINT);
+	wiphy->flags |= (WIPHY_FLAG_MESH_AUTH | WIPHY_FLAG_IBSS_RSN);
+	wiphy->features |= NL80211_FEATURE_USERSPACE_MPM;
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_MESH_POINT);
 
-    rwnx_limits[0].types |= BIT(NL80211_IFTYPE_MESH_POINT);
-    rwnx_limits_dfs[0].types |= BIT(NL80211_IFTYPE_MESH_POINT);
+	rwnx_limits[0].types |= BIT(NL80211_IFTYPE_MESH_POINT);
+	rwnx_limits_dfs[0].types |= BIT(NL80211_IFTYPE_MESH_POINT);
 }
 
 extern int rwnx_init_aic(struct rwnx_hw *rwnx_hw);
 #ifdef AICWF_USB_SUPPORT
-u32 patch_tbl[][2] =
-{
-    {0x0044, 0x00000002}, //hosttype
-    {0x0048, 0x00000060},
-    {0x004c, 0x00000046},
-    {0x0050, 0x00000000}, //ipc base
-    {0x0054, 0x001a0000}, //buf base
-    {0x0058, 0x001a0140}, //desc base
-    {0x005c, 0x00001020}, //desc size
-    {0x0060, 0x001a1020}, //pkt base
-    {0x0064, 0x000207e0}, //pkt size
-    {0x0068, 0x00000008},
-    {0x006c, 0x00000040},
-    {0x0070, 0x00000040},
-    {0x0074, 0x00000020},
-    {0x0078, 0x00000000},
-    {0x007c, 0x00000040},
-    {0x0080, 0x00190000},
-    {0x0084, 0x0000fc00},//63kB
-    {0x0088, 0x0019fc00},
-    #ifdef USE_5G
-    {0x00b4, 0xf3010001},
-    #else
-    {0x00b4, 0xf3010000},
-    #endif
-    //{0x00b8, 0x0f010a01}, //tx enhanced en, tx enhanced lo rate
-    //{0x00bc, 0x00000008}, //tx enhanced hi rate
+u32 patch_tbl[][2] = {
+	{ 0x0044, 0x00000002 }, //hosttype
+	{ 0x0048, 0x00000060 }, { 0x004c, 0x00000046 },
+	{ 0x0050, 0x00000000 }, //ipc base
+	{ 0x0054, 0x001a0000 }, //buf base
+	{ 0x0058, 0x001a0140 }, //desc base
+	{ 0x005c, 0x00001020 }, //desc size
+	{ 0x0060, 0x001a1020 }, //pkt base
+	{ 0x0064, 0x000207e0 }, //pkt size
+	{ 0x0068, 0x00000008 }, { 0x006c, 0x00000040 },
+	{ 0x0070, 0x00000040 }, { 0x0074, 0x00000020 },
+	{ 0x0078, 0x00000000 }, { 0x007c, 0x00000040 },
+	{ 0x0080, 0x00190000 }, { 0x0084, 0x0000fc00 }, //63kB
+	{ 0x0088, 0x0019fc00 },
+#ifdef USE_5G
+	{ 0x00b4, 0xf3010001 },
+#else
+	{ 0x00b4, 0xf3010000 },
+#endif
+	//{0x00b8, 0x0f010a01}, //tx enhanced en, tx enhanced lo rate
+	//{0x00bc, 0x00000008}, //tx enhanced hi rate
 };
 #else
 //#ifdef CONFIG_ROM_PATCH_EN
@@ -7100,1929 +6135,492 @@ u32 patch_tbl[][2] =
     {0x0088, 0x0019fc00}
 };
 #else
-u32 patch_tbl[][2] =
-{
-    #ifdef USE_5G
-    {0x00b4, 0xf3010001},
-    #else
-    {0x00b4, 0xf3010000},
-    #endif
+u32 patch_tbl[][2] = {
+#ifdef USE_5G
+	{ 0x00b4, 0xf3010001 },
+#else
+	{ 0x00b4, 0xf3010000 },
+#endif
 };
 #endif
 #endif
 
-u32 patch_tbl_1[14][2] =
-{
-    {0x171b24, 0x1c4021}, //61
-    {0x171c00, 0x1c40b1}, //116
-    {0x172124, 0x1c43ed}, //12*8 + 1720c4
-    {0x171bfc, 0x1c4849}, //115,  171a30 + 115 * 4
-    {0x171ee4, 0x1c4941}, //301
-    {0x171ee8, 0x1c4b09}, //302
-    {0x172134, 0x1c4d65}, //14/15/16/17/18 * 8 + 1720c4{0x172134, 0x1c4d65},
-    {0x17213c, 0x1c4d65},
-    {0x172144, 0x1c4d65},
-    {0x17214c, 0x1c4d65},
-    {0x172154, 0x1c4d65},
-    {0x1721d0, 0x1c53dd}, // 1721c4 + 1*8 + 4
-    {0x1721f0, 0x1c5415}, // 1721c4 + 5*8 + 4
-    {0x171eb0, 0x1c54a1}, // 288
+u32 patch_tbl_1[14][2] = {
+	{ 0x171b24, 0x1c4021 }, //61
+	{ 0x171c00, 0x1c40b1 }, //116
+	{ 0x172124, 0x1c43ed }, //12*8 + 1720c4
+	{ 0x171bfc, 0x1c4849 }, //115,  171a30 + 115 * 4
+	{ 0x171ee4, 0x1c4941 }, //301
+	{ 0x171ee8, 0x1c4b09 }, //302
+	{ 0x172134, 0x1c4d65 }, //14/15/16/17/18 * 8 + 1720c4{0x172134, 0x1c4d65},
+	{ 0x17213c, 0x1c4d65 }, { 0x172144, 0x1c4d65 }, { 0x17214c, 0x1c4d65 },
+	{ 0x172154, 0x1c4d65 }, { 0x1721d0, 0x1c53dd }, // 1721c4 + 1*8 + 4
+	{ 0x1721f0, 0x1c5415 }, // 1721c4 + 5*8 + 4
+	{ 0x171eb0, 0x1c54a1 }, // 288
 };
 
-u32 func_tbl[1721] =
-{
-    0x8cc88cc3,
-    0xd8084283,
-    0x1ac0d205,
-    0xbfcc283f,
-    0x20012000,
-    0x20014770,
-    0x20004770,
-    0xbf004770,
-    0x481d4a1c,
-    0xb538491d,
-    0x68056913,
-    0xf8b16914,
-    0xf8b100b0,
-    0xf5a310b2,
-    0xeb0363fa,
-    0x1b1b1345,
-    0x1a5b1a1b,
-    0xdb1a2b00,
-    0x681b4b15,
-    0x68dcb143,
-    0x1ae36913,
-    0x63faf5a3,
-    0x1a5b1a1b,
-    0xdb012b00,
-    0xbd382001,
-    0x681b4b0f,
-    0x3000f9b3,
-    0xda062b00,
-    0x1ae46913,
-    0x549cf504,
-    0x2c003408,
-    0x2000db01,
-    0x4909bd38,
-    0xf44f4809,
-    0xf66b7202,
-    0x2000fad9,
-    0xbf00bd38,
-    0x40501000,
-    0x40328040,
-    0x0017192c,
-    0x00178bf0,
-    0x00173250,
-    0x001c5a3c,
-    0x001c56b4,
-    0x4ff0e92d,
-    0x8c05461c,
-    0x3062f893,
-    0x9020f8d2,
-    0xf8d06987,
-    0xb089b01c,
-    0x02ad4616,
-    0x2012e9dd,
-    0xf8b4b9d3,
-    0xf1bcc068,
-    0xd0150f00,
-    0x6ab38b52,
-    0xf202fb0c,
-    0x07189205,
-    0xf20cfb05,
-    0xd0199206,
-    0xebb72300,
-    0xf44f0a09,
-    0x930776fa,
-    0xf5039b05,
-    0xe9c473c8,
-    0xe071a31f,
-    0xf0402800,
-    0x950680ba,
-    0x0a01f04f,
-    0x6ab28b50,
-    0xf000fb0a,
-    0x90050712,
-    0x8122f040,
-    0xf8df6af2,
-    0xf8dfc2bc,
-    0xf8dc82bc,
-    0x48983000,
-    0x1203f3c2,
-    0x037ff023,
-    0x2002f818,
-    0xf8cc4313,
-    0x6ab33000,
-    0xf3c34a93,
-    0xea4113c0,
-    0xf04f5103,
-    0x60014300,
-    0xf3bf6013,
-    0xbf008f4f,
-    0x00586813,
-    0x4b8dd5fc,
-    0xf9b16819,
-    0x29001000,
-    0x80aef2c0,
-    0x68124a88,
-    0xfa82fa1f,
-    0x07126ab2,
-    0x809df040,
-    0xf8df6af2,
-    0x4882c25c,
-    0x1000f8dc,
-    0x1203f3c2,
-    0x017ff021,
-    0x2002f818,
-    0xf8cc430a,
-    0x6ab22000,
-    0xf3c2497c,
-    0x051212c0,
-    0x0218f042,
-    0x4600f04f,
-    0x600e6002,
-    0x8f4ff3bf,
-    0x680abf00,
-    0xd5fc0056,
-    0xf9b3681b,
-    0x2b003000,
-    0x4a72db6e,
-    0x3062f894,
-    0x22006816,
-    0xebaab2b6,
-    0x92070a06,
-    0x0909ebb7,
-    0x0a0aeb19,
-    0xd0872b00,
-    0x79e5ea4f,
-    0x464b462a,
-    0x46594638,
-    0xfc50f679,
-    0x92021bba,
-    0xfb009a07,
-    0xeb6bf309,
-    0xfb050202,
-    0x92033301,
-    0x0105fba0,
-    0xe9dd4419,
-    0x42992302,
-    0x4290bf08,
-    0xe9cdbf38,
-    0x4b5e0102,
-    0x6702e9dd,
-    0x9b066819,
-    0x018918f6,
-    0x9905d430,
-    0xf5a11a71,
-    0x4b597ac8,
-    0x69194a59,
-    0x691b6812,
-    0x44511a89,
-    0xf5a31acb,
-    0x3b1453a5,
-    0x6a632b00,
-    0x1949bfb8,
-    0xd022428b,
-    0x6a1a4b52,
-    0xd04142a2,
-    0xf1044d51,
-    0xf8d50018,
-    0x479831e0,
-    0x30a8f8d5,
-    0xb0094620,
-    0x4ff0e8bd,
-    0xf8904718,
-    0xf1baa002,
-    0xd1010f00,
-    0xa003f890,
-    0xf00afb05,
-    0xe73d9006,
-    0x98054946,
-    0xeba11a09,
-    0x44b20a0a,
-    0xb009e7cb,
-    0x8ff0e8bd,
-    0x0058680b,
-    0x4941d48d,
-    0xf44f4841,
-    0xf66b72ae,
-    0x2200f98f,
-    0x3062f894,
-    0xf5aa9207,
-    0xf44f7afa,
-    0xe78776fa,
-    0x00516812,
-    0xaf4ef53f,
-    0x48384937,
-    0x72aef44f,
-    0xf97cf66b,
-    0x7afaf44f,
-    0xe7474b2c,
-    0x62614a2c,
-    0x01926812,
-    0x4a32d4b8,
-    0x68124d32,
-    0x1024f893,
-    0x4207f3c2,
-    0x2d23f885,
-    0x4a2fbb61,
-    0x6812492f,
-    0x20016809,
-    0xf885b2d2,
-    0xf8832d24,
-    0x780b0024,
-    0xd1054283,
-    0x4a2b492a,
-    0x6813600b,
-    0x60134303,
-    0x2d23f895,
-    0x3d24f895,
-    0xd21b429a,
-    0x681b4b17,
-    0x3000f9b3,
-    0xda0d2b00,
-    0x2d23f895,
-    0x3d24f895,
-    0xd307429a,
-    0x48214920,
-    0xf44f4d15,
-    0xf66b7221,
-    0xe787f96f,
-    0xe7854d12,
-    0xf44f2200,
-    0x920776fa,
-    0xe7354692,
-    0x4b124814,
-    0x1d23f895,
-    0x2d24f895,
-    0x6806681b,
-    0xb2f64816,
-    0x96000c1b,
-    0xff82f66a,
-    0xbf00e7d4,
-    0x40328160,
-    0x4032816c,
-    0x00173250,
-    0x4032004c,
-    0x40501000,
-    0x403280a4,
-    0x00178d3c,
-    0x00171a30,
-    0xfffffe70,
-    0x001c5a20,
-    0x001c56e0,
-    0x40328044,
-    0x001e4000,
-    0x40320090,
-    0x00173270,
-    0x40328070,
-    0x40328074,
-    0x001c5a58,
-    0x001c5718,
-    0x001c5704,
-    0x40328164,
-    0x00041830,
-    0x4ff0e92d,
-    0x9354f8df,
-    0xb020f8d9,
-    0xf44fb083,
-    0xf6692000,
-    0xf1bbfd9b,
-    0xf0000f00,
-    0x4cb480f1,
-    0xa33cf8df,
-    0x4fb37fa1,
-    0x8338f8df,
-    0x29004eb2,
-    0x80e6f000,
-    0xd50e0708,
-    0xf8db4bb0,
-    0x681b0070,
-    0x2010f8da,
-    0x4403685b,
-    0x2b001a9b,
-    0x80c7f2c0,
-    0x01f7f001,
-    0x074a77a1,
-    0x8095f100,
-    0xd515078b,
-    0x3004f8db,
-    0x0302f023,
-    0x3004f8cb,
-    0x301df899,
-    0xd1082b05,
-    0x48a34da2,
-    0x31d8f8d5,
-    0x23004798,
-    0xf8897fa1,
-    0xf001301d,
-    0x77a101fd,
-    0xd52d07cd,
-    0x01586833,
-    0x809ff140,
-    0x0c096831,
-    0x7f7cf411,
-    0x80a6f000,
-    0x4b983910,
-    0x01fff001,
-    0x1281eb01,
-    0x03c2eb03,
-    0x2021f893,
-    0xf0002a00,
-    0x4a93809d,
-    0x68137f99,
-    0xf9b34a92,
-    0xf44f3000,
-    0xfb0060a4,
-    0x2b002201,
-    0xf2c09200,
-    0x683b809c,
-    0x2fe0f413,
-    0x80a5f000,
-    0xf0017fa1,
-    0x77a101fe,
-    0xd59e068a,
-    0x49894e88,
-    0xf3c56835,
-    0x463a1741,
-    0xf66a2002,
-    0x2300ff23,
-    0x1547f3c5,
-    0x3078f88b,
-    0xf0402f00,
-    0x4e7b80af,
-    0x4d824a81,
-    0xf4236813,
-    0x60137300,
-    0x3004f8db,
-    0x21d8f8d6,
-    0x0301f023,
-    0x3004f8cb,
-    0x0028f10b,
-    0x682a4790,
-    0x2b027813,
-    0x8114f000,
-    0x680b4974,
-    0x0301f023,
-    0x7813600b,
-    0xd1122b01,
-    0x41fff501,
-    0x4a733134,
-    0x3010f8da,
-    0xf8b26808,
-    0xf8d610b2,
-    0xeb0321e0,
-    0x1a591340,
-    0x0018f10b,
-    0x682b4790,
-    0x2b02781b,
-    0x80b4f000,
-    0xf0017fa1,
-    0x77a101df,
-    0x4968e74f,
-    0x20024d5d,
-    0xfedcf66a,
-    0x68634966,
-    0xf022680a,
-    0x600a0204,
-    0xf4436822,
-    0x431a7300,
-    0xf8d5614a,
-    0x60631498,
-    0x0063f89b,
-    0x3494f8d5,
-    0x4798465a,
-    0x7fa1683b,
-    0x737cf023,
-    0xf8d8603b,
-    0xf0013000,
-    0xf44301fb,
-    0xf8c80380,
-    0x77a13000,
-    0x4856e742,
-    0xfe66f66a,
-    0x2200e782,
-    0x006cf89b,
-    0xf6584611,
-    0xb160fd17,
-    0xe72f7fa1,
-    0xf66a4850,
-    0xe775fe59,
-    0xf66a484f,
-    0xe771fe55,
-    0xe8bdb003,
-    0xf8da8ff0,
-    0x7fa13010,
-    0x3070f8cb,
-    0x4593e71e,
-    0xaf61f43f,
-    0x48494948,
-    0x22e6f240,
-    0xf818f66b,
-    0xf413683b,
-    0xf47f2fe0,
-    0x6832af5b,
-    0x49446833,
-    0xf3c30fd0,
-    0x46057380,
-    0x20024602,
-    0xf66a9301,
-    0x9b01fe81,
-    0x0205ea53,
-    0xf43f4628,
-    0x4d2baf49,
-    0x46199a00,
-    0x323cf8d5,
-    0x68334798,
-    0x4300f023,
-    0x68336033,
-    0x4380f023,
-    0xe7396033,
-    0x2010f8da,
-    0x529cf502,
-    0x32084631,
-    0xf8dae005,
-    0x1ad33010,
-    0xf2c02b00,
-    0x680b80b2,
-    0xd5f6071b,
-    0x8080f8df,
-    0x3000f8d8,
-    0x0308f023,
-    0x3000f8c8,
-    0x3000f8d8,
-    0xd51206de,
-    0x49274e15,
-    0xf66a2002,
-    0xf8d6fe4b,
-    0xf005323c,
-    0x08780101,
-    0x4798465a,
-    0x3000f8d8,
-    0x0310f023,
-    0x3000f8c8,
-    0x4b1fe722,
-    0x4e0b491f,
-    0x601d2501,
-    0xf66a2002,
-    0x4b1dfe35,
-    0xe717601d,
-    0x22304b1c,
-    0xf657601a,
-    0xe745fddb,
-    0x00178bb8,
-    0x40320074,
-    0x40320070,
-    0x00173244,
-    0x00171a30,
-    0x00178d48,
-    0x00175aa8,
-    0x00173250,
-    0x00177738,
-    0x4032008c,
-    0x001c57ec,
-    0x4033b390,
-    0x00173270,
-    0x0017192c,
-    0x001c578c,
-    0x4032004c,
-    0x001c5790,
-    0x001c57a8,
-    0x001c57bc,
-    0x001c5a70,
-    0x001c57d0,
-    0x001c57e0,
-    0x001c580c,
-    0x40328564,
-    0x001c5818,
-    0x40328568,
-    0x40320038,
-    0x00178d3c,
-    0x40501000,
-    0x4032006c,
-    0x8310f3ef,
-    0xd40307d8,
-    0x4b31b672,
-    0x601a2201,
-    0x4f314b30,
-    0x3201681a,
-    0x2100601a,
-    0x6039683a,
-    0x080ff002,
-    0x2010f8da,
-    0x46164631,
-    0xf247460a,
-    0xe0045030,
-    0x1010f8da,
-    0x42811b89,
-    0x6839d81b,
-    0xd1f70709,
-    0x49264825,
-    0xc000f8d0,
-    0x4616680f,
-    0x2010f8da,
-    0x0f00f1b8,
-    0x4a22d11a,
-    0x60112104,
-    0xb132681a,
-    0x3a01491a,
-    0x680b601a,
-    0xb103b90a,
-    0x682ab662,
-    0x491ce6b0,
-    0x20029200,
-    0xfdb0f66a,
-    0x9a004b14,
-    0x4919e7d3,
-    0xf66a2002,
-    0xe74bfda9,
-    0x070cea07,
-    0xd4e0077f,
-    0x1600e9cd,
-    0x46164680,
-    0x077ae001,
-    0x9a00d412,
-    0x7000f8d8,
-    0xf8da6812,
-    0xf2471010,
-    0x1b895030,
-    0xea074281,
-    0xd9f00702,
-    0x2002490b,
-    0xfd8cf66a,
-    0xe7ea4b02,
-    0xe7c49e01,
-    0x0017569c,
-    0x00172600,
-    0x40320038,
-    0x4032806c,
-    0x40328074,
-    0x40328070,
-    0x001c5828,
-    0x001c57f8,
-    0x001c5834,
-    0xf890b5f8,
-    0x2b003064,
-    0xf890d03a,
-    0x4604308a,
-    0xd1362b00,
-    0xf8944e32,
-    0x4a32306c,
-    0x6a674932,
-    0xeb036a09,
-    0xeb021383,
-    0x42a103c3,
-    0x443d685d,
-    0xf8d6d044,
-    0x462931e0,
-    0x0018f104,
-    0x46204798,
-    0xfafaf65e,
-    0x1080f8d4,
-    0x3214f8d6,
-    0x46204439,
-    0xf8d64798,
-    0x462a30a4,
-    0x46204639,
-    0xb9784798,
-    0x3078f894,
-    0x49216862,
-    0xb2db3301,
-    0x0201f042,
-    0xf8846809,
-    0x60623078,
-    0x4293780a,
-    0xd029d811,
-    0x3b01bdf8,
-    0x2b01b2db,
-    0x308af880,
-    0x2b02d912,
-    0xd1c04e13,
-    0x0063f890,
-    0x31c0f8d6,
-    0x47982100,
-    0xf8d6e7b9,
-    0xf8941164,
-    0x4622006c,
-    0x40f8e8bd,
-    0xbb84f658,
-    0x40f8e8bd,
-    0xbb3af65e,
-    0x62654b0c,
-    0x30b5f893,
-    0xd1ba2b00,
-    0x681b4b0a,
-    0x2b02781b,
-    0xe7b4d1af,
-    0xe8bd4620,
-    0xf66540f8,
-    0xbf00b8d1,
-    0x00171a30,
-    0x00175aa8,
-    0x00178d3c,
-    0x00173244,
-    0x0017192c,
-    0x00173270,
-    0x4c5cb538,
-    0x68224b5c,
-    0xf002495c,
-    0x701a020f,
-    0xf66a2002,
-    0x6823fcef,
-    0xd02e0718,
-    0x4a594958,
-    0x2000680b,
-    0x4300f023,
-    0x6020600b,
-    0x07596813,
-    0x4b55d5fc,
-    0x4a554952,
-    0x60182004,
-    0xf043680b,
-    0x600b4300,
-    0xf0436813,
-    0x60136300,
-    0x20024950,
-    0xfcd0f66a,
-    0x4a4f4b47,
-    0x494f4847,
-    0x601c2420,
-    0x24016813,
-    0x0310f043,
-    0x70446013,
-    0x781b680b,
-    0xd0382b03,
-    0xd0062b01,
-    0x4a44bd38,
-    0xf0236813,
-    0x60136300,
-    0x4a45e7e2,
-    0x035b6813,
-    0x4a44d5fc,
-    0x311c6911,
-    0x1acb6913,
-    0xdafb2b00,
-    0x681c4b41,
-    0x4b41b174,
-    0xf9b3681b,
-    0x2b003000,
-    0x4a3fdb4e,
-    0xf8b268e3,
-    0x4a3a10b2,
-    0x21041a5b,
-    0x60916313,
-    0x4a3c493b,
-    0xf443680b,
-    0x600b4300,
-    0xf4436d13,
-    0x65134300,
-    0xf0236dd3,
-    0xf0430303,
-    0xf0434300,
-    0x65d30301,
-    0x4b2fbd38,
-    0xb174681c,
-    0x681b4b2e,
-    0x3000f9b3,
-    0xdb152b00,
-    0x68e34a2c,
-    0x10b2f8b2,
-    0x1a5b4a27,
-    0x63132104,
-    0x4b2b6091,
-    0xf042681a,
-    0x601a0201,
-    0x075a681b,
-    0x4b28d5ae,
-    0x7200f44f,
-    0xbd38601a,
-    0x4d214b1e,
-    0x68e3691a,
-    0x10b2f8b5,
-    0x1a521a9a,
-    0xdae32a00,
-    0x48224921,
-    0x32dbf240,
-    0xfddef66a,
-    0xf8b568e3,
-    0xe7d910b2,
-    0x69124d17,
-    0xf8b568e3,
-    0x1a9a10b2,
-    0x2a001a52,
-    0x4918daab,
-    0xf2404818,
-    0xf66a32e9,
-    0x68e3fdcb,
-    0x10b2f8b5,
-    0xbf00e7a1,
-    0x40320038,
-    0x00172604,
-    0x001c5844,
-    0x40328074,
-    0x4032806c,
-    0x40328070,
-    0x40328048,
-    0x001c584c,
-    0x40580010,
-    0x00173274,
-    0x40041020,
-    0x40501000,
-    0x00178bf0,
-    0x00173250,
-    0x0017192c,
-    0x40240014,
-    0x40506000,
-    0x40044084,
-    0x40044100,
-    0x001c5a8c,
-    0x001c5854,
-    0xf890b380,
-    0xb36b3064,
-    0x47f0e92d,
-    0x4a7b4b7a,
-    0xf8df4e7b,
-    0xf8df920c,
-    0x4d7a8240,
-    0x460c487a,
-    0x2702497a,
-    0xc470f8d1,
-    0x7180f8c3,
-    0x49786892,
-    0xc044f8c2,
-    0x601f2201,
-    0xf8d97032,
-    0x680b2010,
-    0xf0236072,
-    0x600b0302,
-    0x1000f8d8,
-    0xc0b2f8b5,
-    0x68018f8b,
-    0xebb34463,
-    0xea4f1f41,
-    0xd3021a41,
-    0x87f0e8bd,
-    0x496b4770,
-    0xf66a4638,
-    0xf8d9fbdf,
-    0x68f32010,
-    0x2b001a9b,
-    0xf2804b67,
-    0xf89380a2,
-    0xf8932d23,
-    0x2a012d24,
-    0xf893d90a,
-    0x68612d23,
-    0xf0002a00,
-    0xf893809e,
-    0x3a012d23,
-    0xaa02fb01,
-    0x3d23f893,
-    0x4652495d,
-    0xf66a2002,
-    0xf8d8fbbf,
-    0xf8b53000,
-    0x8f9a00b2,
-    0x4b594955,
-    0xc178f8df,
-    0x680b691c,
-    0xebaa4402,
-    0xf0220202,
-    0xf0030703,
-    0x433b0303,
-    0x600b4f53,
-    0x60b2683b,
-    0x0301f043,
-    0xf8dc603b,
-    0xf8dc3000,
-    0xf3c31000,
-    0xf4210309,
-    0xf043717f,
-    0xf0210301,
-    0x430b0103,
-    0x3000f8cc,
-    0x4422683b,
-    0x60f2075b,
-    0x4b47d503,
-    0x7200f44f,
-    0x4a46601a,
-    0x68134c46,
-    0xf043493d,
-    0x60130308,
-    0xf0436823,
-    0x60230302,
-    0xf5a2680b,
-    0x3a1022fe,
-    0x0301f043,
-    0x6911600b,
-    0x7196f501,
-    0x1a5b6913,
-    0xdbfb2b00,
-    0x681b4b3b,
-    0x2b01781b,
-    0x493ad188,
-    0x6a4b4c3a,
-    0xf0236824,
-    0xf04303ff,
-    0x624b03df,
-    0xf4236a4b,
-    0xf443437f,
-    0x624b435f,
-    0x4b34b194,
-    0xf9b3681b,
-    0x2b003000,
-    0x68e2db31,
-    0x48316861,
-    0xfb04f66a,
-    0x10b2f8b5,
-    0x4a2568e3,
-    0x21041a5b,
-    0x60916313,
-    0x4a28492c,
-    0xf443680b,
-    0x600b4300,
-    0xf4436d13,
-    0x65134300,
-    0xf0236dd3,
-    0xf0430303,
-    0xf0434300,
-    0x65d30301,
-    0xf4436813,
-    0x60135380,
-    0x4922e74e,
-    0x3d23f893,
-    0x46524638,
-    0xfb2ef66a,
-    0xf893e76d,
-    0x3a012d24,
-    0xaa02fb01,
-    0x6913e760,
-    0x1ad368e2,
-    0x28001a18,
-    0x4919dac8,
-    0xf2404819,
-    0xf66a4231,
-    0xe7c0fca1,
-    0xe000e100,
-    0xe000ed00,
-    0x00173254,
-    0x0017192c,
-    0x40328040,
-    0x00171a30,
-    0x40320084,
-    0x001c589c,
-    0x001e4000,
-    0x001c58b8,
-    0x40501000,
-    0x40044084,
-    0x40044100,
-    0x40580010,
-    0x40580018,
-    0x00173274,
-    0x40506000,
-    0x00178bf0,
-    0x00173250,
-    0x001c58c8,
-    0x40240014,
-    0x001c58a4,
-    0x001c5aac,
-    0x001c5854,
-    0x00173244,
-    0x4ff0e92d,
-    0x4abd4bbc,
-    0xf852681b,
-    0xf9b34020,
-    0x4abb3000,
-    0x8b02ed2d,
-    0x02c0eb02,
-    0xee082b00,
-    0xb08b2a10,
-    0xea4f4683,
-    0xf2c005c0,
-    0x462082c4,
-    0xf8d0f669,
-    0xf8534bb2,
-    0xf1b9903b,
-    0xf0000f00,
-    0x230080e5,
-    0x3303e9cd,
-    0xf5059302,
-    0x9301629e,
-    0xf10b469a,
-    0x9208039e,
-    0x464c9305,
-    0xf898e079,
-    0x06df3004,
-    0x80d2f140,
-    0xf4226932,
-    0x9a010900,
-    0x9010f8c6,
-    0x065d3201,
-    0xf1009201,
-    0x4fa180e0,
-    0xf8d74620,
-    0x47983418,
-    0xf4036b63,
-    0xf5b31360,
-    0xbf081f20,
-    0xf3ef46a2,
-    0x07d98310,
-    0xb672d403,
-    0x22014b99,
-    0x4d99601a,
-    0xee18682b,
-    0x33010a10,
-    0xf669602b,
-    0x6b63f951,
-    0x1360f403,
-    0x1f60f5b3,
-    0x80a9f000,
-    0xb133682b,
-    0x3b014a8f,
-    0x602b6812,
-    0xb102b90b,
-    0xf8dfb662,
-    0xf8d88240,
-    0x78193000,
-    0xf419b391,
-    0xd1050300,
-    0x002ef9b4,
-    0x28008de2,
-    0x817ef2c0,
-    0x302cf894,
-    0x202af894,
-    0xf8b44884,
-    0xeb03c008,
-    0x441303c3,
-    0x530ef203,
-    0xf8502901,
-    0xeba22023,
-    0xf840020c,
-    0xf0002023,
-    0x6ce080d5,
-    0xf650b138,
-    0xf8d8fd4f,
-    0x781e3000,
-    0xf0002e01,
-    0x4621810f,
-    0xf66a4658,
-    0x6b63fc95,
-    0x1360f403,
-    0x1f60f5b3,
-    0x80eaf000,
-    0xf8534b6d,
-    0x2c00403b,
-    0xf8d4d05c,
-    0x6d268048,
-    0x0f00f1b8,
-    0xaf7ff47f,
-    0x8310f3ef,
-    0xd40307d9,
-    0x4b67b672,
-    0x601a2201,
-    0x682b4d66,
-    0x0a10ee18,
-    0x602b3301,
-    0xf8ecf669,
-    0xb133682b,
-    0x3b014a60,
-    0x602b6812,
-    0xb102b90b,
-    0x4f5cb662,
-    0x9178f8df,
-    0x817cf8df,
-    0xf6764620,
-    0xf8d7ff21,
-    0x46203418,
-    0xf8d74798,
-    0x220033ac,
-    0xf18bfa5f,
-    0x47984620,
-    0x302cf894,
-    0x102af894,
-    0xeb038922,
-    0x440b03c3,
-    0x530ef203,
-    0x1023f859,
-    0xf8491a8a,
-    0xf8d82023,
-    0x781b3000,
-    0xd0642b01,
-    0xd0532b02,
-    0xd1082b03,
-    0x3054f894,
-    0xf0002b01,
-    0x8de381db,
-    0xf10007d9,
-    0x4621814c,
-    0xf66a4658,
-    0x4b3ffc31,
-    0x403bf853,
-    0xd1a22c00,
-    0xecbdb00b,
-    0xe8bd8b02,
-    0x4b388ff0,
-    0xf9b3681b,
-    0x2b003000,
-    0x808bf2c0,
-    0xe9dd4650,
-    0xf6761201,
-    0x4640fee7,
-    0xfbeef659,
-    0xe9cd2300,
-    0x469a3301,
-    0xf8d8e742,
-    0xb1b220dc,
-    0x8ce38811,
-    0x1311eba3,
-    0x030bf3c3,
-    0x71fef240,
-    0xd816428b,
-    0xea4f2b3f,
-    0xd8121113,
-    0x0241eb02,
-    0x030ff003,
-    0xfa428852,
-    0x07d8f303,
-    0x9b02d509,
-    0x93023301,
-    0x0304f44f,
-    0x0903ea49,
-    0x9010f8c6,
-    0xf44fe6fb,
-    0xe7f72380,
-    0x3054f894,
-    0xf0002b01,
-    0x8de38117,
-    0xd5ae07da,
-    0xf6682080,
-    0xf8d8ff75,
-    0x781b3000,
-    0xf894e79c,
-    0x2b013054,
-    0x80f7f000,
-    0x07db8de3,
-    0x2080d59f,
-    0xff66f668,
-    0x3000f8d8,
-    0xe78b781b,
-    0x3054f894,
-    0xf47f2b01,
-    0xf890af26,
-    0xf0433f20,
-    0xf1060302,
-    0xf8800110,
-    0x22043f20,
-    0xf6512012,
-    0x8ba1fd2b,
-    0x46224809,
-    0xf91ef66a,
-    0xbf00e713,
-    0x00173250,
-    0x0003fc40,
-    0x00175980,
-    0x00171a30,
-    0x0017569c,
-    0x00172600,
-    0x00173278,
-    0x001c5904,
-    0x00173274,
-    0x2b009b03,
-    0x808bf040,
-    0xf48bfa5f,
-    0xf6682080,
-    0x4620ff2f,
-    0xfebef659,
-    0x93032300,
-    0xf1bae706,
-    0xf47f0f00,
-    0x49aaaf71,
-    0xf24048aa,
-    0xf66a42e7,
-    0xe769fac7,
-    0xe9d34ba8,
-    0x69130201,
-    0x46804798,
-    0xf43f2800,
-    0xf650aee8,
-    0x4603fd49,
-    0xf0002800,
-    0x22008096,
-    0x600249a1,
-    0x605a6808,
-    0x609a4440,
-    0xf3ef6018,
-    0x07d28210,
-    0x812ef140,
-    0x6829489c,
-    0x31016802,
-    0x0201f042,
-    0x60026029,
-    0x68124a98,
-    0xd4fb0790,
-    0x68124a97,
-    0xf0002a00,
-    0x4e968116,
-    0x2a006872,
-    0x8149f000,
-    0x4a926053,
-    0x681289b0,
-    0x4b906073,
-    0x30013201,
-    0x601a81b0,
-    0x68134a8c,
-    0x0301f023,
-    0x29006013,
-    0xaeadf43f,
-    0x39014b8b,
-    0x6029681b,
-    0xf47f2900,
-    0x2b00aea6,
-    0xaea3f43f,
-    0xe6a0b662,
-    0x49866d20,
-    0x64a36503,
-    0xf8946103,
-    0x63e3502b,
-    0xf3c29b05,
-    0x20a4020e,
-    0x0201f042,
-    0x3005fb10,
-    0x63a4f44f,
-    0x1305fb03,
-    0xeb0185e2,
-    0x4a7c00c0,
-    0x46219304,
-    0xffe2f668,
-    0xf4036b63,
-    0xf5b31360,
-    0xd0021f60,
-    0x93032301,
-    0x9804e686,
-    0xfd60f656,
-    0xf43f2800,
-    0x4d73af6f,
-    0x31fff895,
-    0xf47f2b00,
-    0x9b04af69,
-    0xf8cd9a08,
-    0xfa5fb00c,
-    0xf8ddf48b,
-    0x46d39014,
-    0x4698189e,
-    0xe00946ba,
-    0xff74f668,
-    0x3424f8da,
-    0x46214638,
-    0xf8954798,
-    0xb92331ff,
-    0x7039f858,
-    0x2f004630,
-    0x46dad1f0,
-    0xb00cf8dd,
-    0x2080e74a,
-    0xfe7af668,
-    0x4640e6af,
-    0xfb92f650,
-    0xf899e647,
-    0x22043f20,
-    0x0302f043,
-    0x0110f106,
-    0xf8892012,
-    0xf6513f20,
-    0x8de3fc43,
-    0xf53f07da,
-    0xe6fdaefc,
-    0xf6539306,
-    0x9b06f95d,
-    0x28009007,
-    0x80c0f000,
-    0x4b509309,
-    0x2a00681a,
-    0x80c2f000,
-    0xf6684618,
-    0x9b07ff39,
-    0xf04f2204,
-    0x21120e00,
-    0x70994684,
-    0xf883701a,
-    0xf883e001,
-    0xf106e003,
-    0x18980110,
-    0xc018f8cd,
-    0xfdc4f678,
-    0x8a194b42,
-    0xf5b19b09,
-    0xd85a7fc3,
-    0xb29b1c4b,
-    0x00ca9309,
-    0x4b3e9806,
-    0x68188181,
-    0x4b3d9907,
-    0x0c02eb00,
-    0x0e01f04f,
-    0x1004f8cc,
-    0x400b5881,
-    0x6380f043,
-    0x0308f043,
-    0xf8995083,
-    0x4a333782,
-    0x82119909,
-    0xf8894473,
-    0x9b063782,
-    0x22082100,
-    0xc004f8c3,
-    0xe00ef883,
-    0x609a6019,
-    0x8310f3ef,
-    0xd40307db,
-    0x4b25b672,
-    0xe000f8c3,
-    0x482a682b,
-    0x33019906,
-    0xf668602b,
-    0xf8d7fea5,
-    0x47983444,
-    0xb133682b,
-    0x3b014a1d,
-    0x602b6812,
-    0xb102b90b,
-    0x8de3b662,
-    0xf53f07d8,
-    0xe67cae7b,
-    0x69324b1f,
-    0x601a681b,
-    0xffaef64e,
-    0x4b1de61d,
-    0x421c681b,
-    0xad37f47f,
-    0x481b490a,
-    0x6293f44f,
-    0xf988f66a,
-    0x2200e52f,
-    0x46119309,
-    0x4a17e7a4,
-    0xbb6a6812,
-    0x4e094a15,
-    0xe6e86013,
-    0x4a08b672,
-    0xe6cd6016,
-    0x001c5ad0,
-    0x001c58ec,
-    0x001755b4,
-    0x001719e4,
-    0x40240060,
-    0x40240064,
-    0x0017559c,
-    0x0017569c,
-    0x00177738,
-    0x001c4001,
-    0x00175780,
-    0x0017469c,
-    0x001755d4,
-    0x31ff0000,
-    0x001746a4,
-    0x00180000,
-    0x0017a5a0,
-    0x001c58d4,
-    0x40240068,
-    0x9306480b,
-    0xff78f669,
-    0x9b066829,
-    0x4809e7ca,
-    0xf6699306,
-    0x6829ff71,
-    0xe6b09b06,
-    0xb00b4806,
-    0x8b02ecbd,
-    0x4ff0e8bd,
-    0xbcdef64f,
-    0xe7f64803,
-    0x001c591c,
-    0x001c5924,
-    0x001c5938,
-    0x001c594c,
-    0xf240b530,
-    0xb0834003,
-    0x4619460d,
-    0xf6682308,
-    0xe9d5f98d,
-    0x46043200,
-    0x3200e9c0,
-    0xe9cd4611,
-    0x48042200,
-    0xff48f669,
-    0xf6684620,
-    0x2000f9af,
-    0xbd30b003,
-    0x001c5970,
-    0x460cb570,
-    0x4619b084,
-    0x4012f240,
-    0xf6682308,
-    0x6822f971,
-    0x429a4b12,
-    0xd0104605,
-    0x686168a3,
-    0xe9c54810,
-    0xe9cd2300,
-    0x92003301,
-    0xf669461a,
-    0x4628ff27,
-    0xf98ef668,
-    0xb0042000,
-    0xe9d4bd70,
-    0x68116301,
-    0x404b4808,
-    0x404b4033,
-    0xe9d46013,
-    0x680a1300,
-    0x68a29200,
-    0xff12f669,
-    0xe7dd6822,
-    0x40344058,
-    0x001c59cc,
-    0x001c59b0,
-    0xbf002332,
-    0xf0133b01,
-    0xd1fa03ff,
-    0xbf004770,
-    0xbf0023c8,
-    0xf0133b01,
-    0xd1fa03ff,
-    0xbf004770,
-    0x49724a71,
-    0xf8df6813,
-    0xf023c208,
-    0xb5f00302,
-    0x680b6013,
-    0x4c6f4a6e,
-    0xf4234f6f,
-    0x600b6300,
-    0x496e6813,
-    0xf4232800,
-    0xbf1c7380,
-    0x468c4627,
-    0x20326013,
-    0x3801bf00,
-    0x00fff010,
-    0xf8dfd1fa,
-    0x4a63e18c,
-    0x3000f8de,
-    0xf4234e65,
-    0xf8ce5380,
-    0x68133000,
-    0x7300f423,
-    0xf8de6013,
-    0xf4433000,
-    0xf8ce6380,
-    0xf8de3000,
-    0xf4433000,
-    0xf8ce6300,
-    0x46723000,
-    0x1cc125ff,
-    0x4664b2c9,
-    0xf0236813,
-    0x430b03ff,
-    0xf8546013,
-    0x60333b04,
-    0xf4436813,
-    0x60137380,
-    0xbf00bf00,
-    0xbf00bf00,
-    0x049b6813,
-    0x3901d5fc,
-    0x428db2c9,
-    0x3004d1e8,
-    0x28803504,
-    0xf10cb2ed,
-    0xd1de0c10,
-    0x3000f8de,
-    0x6380f423,
-    0x3000f8ce,
-    0xbf0023c8,
-    0xf0133b01,
-    0xd1fa03ff,
-    0x493f4c3e,
-    0x48436822,
-    0x6200f422,
-    0x680a6022,
-    0x0280f042,
-    0x680a600a,
-    0x7280f442,
-    0x600a3f04,
-    0xf022680a,
-    0x431a021f,
-    0xf857600a,
-    0x60022f04,
-    0xf042680a,
-    0x600a0220,
-    0xbf00bf00,
-    0xbf00bf00,
-    0x0552680a,
-    0x3301d5fc,
-    0xd1e92b10,
-    0xf023680b,
-    0x600b0380,
-    0xbf0023c8,
-    0xf0133b01,
-    0xd1fa03ff,
-    0x4a2d4927,
-    0xf423680b,
-    0x600b7380,
-    0xf4436813,
-    0x60131300,
-    0xbf002332,
-    0xf0133b01,
-    0xd1fa03ff,
-    0x4a1f4b1e,
-    0x4d256819,
-    0x48264c25,
-    0xf4414e26,
-    0x60195180,
-    0xf4416811,
-    0x60117100,
-    0xf4416819,
-    0x60196100,
-    0x4b216811,
-    0x7180f441,
-    0x682a6011,
-    0xf442491f,
-    0x602a5280,
-    0xf4226822,
-    0x60222280,
-    0xf0226802,
-    0x60025200,
-    0x60306818,
-    0x45bbf5a5,
-    0x685c3d78,
-    0x689d602c,
-    0x4a16600d,
-    0x601568dd,
-    0x691d4815,
-    0xe9d36005,
-    0x4c145005,
-    0x602569db,
-    0x61136108,
-    0xbf00bdf0,
-    0x40580018,
-    0x40344060,
-    0x4034406c,
-    0x001718a4,
-    0x00171824,
-    0x00171624,
-    0x40344064,
-    0x40344070,
-    0x40344058,
-    0x40342014,
-    0x40342018,
-    0x4034201c,
-    0x4033c218,
-    0x001718e4,
-    0x4033c220,
-    0x4033c224,
-    0x4033c228,
-    0x4033c22c,
-    0x00171324,
-    0x6c616821,
-    0x6e6f615f,
-    0x656d6974,
-    0x69745f72,
-    0x705f656d,
-    0x28747361,
-    0x656d6974,
-    0x743e2d72,
-    0x20656d69,
-    0x3035202b,
-    0x00293030,
-    0x616d786e,
-    0x69745f63,
-    0x6f5f656d,
-    0x69615f6e,
-    0x61765f72,
-    0x5f64696c,
-    0x66746567,
-    0x21202928,
-    0x0030203d,
-    0x6d697464,
-    0x2c64253a,
-    0x252c6425,
-    0x64252c64,
-    0x00000a0d,
-    0x6f76282a,
-    0x6974616c,
-    0x7520656c,
-    0x38746e69,
-    0x2a20745f,
-    0x5f672629,
-    0x5f6e6f61,
-    0x72616873,
-    0x642e6465,
-    0x5f6d6974,
-    0x5f746e63,
-    0x736e6f61,
-    0x65726168,
-    0x203c2064,
-    0x6f76282a,
-    0x6974616c,
-    0x7520656c,
-    0x38746e69,
-    0x2a20745f,
-    0x5f672629,
-    0x5f6e6f61,
-    0x72616873,
-    0x642e6465,
-    0x5f6d6974,
-    0x69726570,
-    0x615f646f,
-    0x68736e6f,
-    0x64657261,
-    0x00000000,
-    0x00002c4c,
-    0x654b849b,
-    0x78646979,
-    0x766e6920,
-    0x64696c61,
-    0x3230252c,
-    0x00000a58,
-    0x6e49849b,
-    0x696c6176,
-    0x656b2064,
-    0x78646979,
-    0x0000000a,
-    0x6e49849b,
-    0x696c6176,
-    0x54532064,
-    0x64253a41,
-    0x0000000a,
-    0x5f666976,
-    0x20617473,
-    0x76203d3d,
-    0x00006669,
-    0x64253d54,
-    0x0d64252c,
-    0x0000000a,
-    0x3a4e4342,
-    0x0a0d6425,
-    0x00000000,
-    0x206e6362,
-    0x656e6f64,
-    0x6d697420,
-    0x74756f65,
-    0x00000a0d,
-    0x20736366,
-    0x0a0d6b6f,
-    0x00000000,
-    0x20736366,
-    0x20746f6e,
-    0x0a0d6b6f,
-    0x00000000,
-    0x656c6469,
-    0x72726520,
-    0x00000a0d,
-    0x656c6469,
-    0x746e6920,
-    0x72726520,
-    0x00000a0d,
-    0x2c642564,
-    0x00000000,
-    0x0a0d6564,
-    0x00000000,
-    0x6c616821,
-    0x63616d5f,
-    0x745f7768,
-    0x5f656d69,
-    0x74736170,
-    0x6d697428,
-    0x3e2d7265,
-    0x656d6974,
-    0x67202d20,
-    0x6669775f,
-    0x65735f69,
-    0x6e697474,
-    0x702e7367,
-    0x6f5f7277,
-    0x5f6e6570,
-    0x64737973,
-    0x79616c65,
-    0x00000029,
-    0x78253d74,
-    0x00000a0d,
-    0x20746f6e,
-    0x74736170,
-    0x6425203a,
-    0x0d64252c,
-    0x0000000a,
-    0x73736170,
-    0x6425203a,
-    0x0d64252c,
-    0x0000000a,
-    0x3a706c73,
-    0x252c7825,
-    0x000a0d78,
-    0x655f656b,
-    0x675f7476,
-    0x29287465,
-    0x65202620,
-    0x625f7476,
-    0x00007469,
-    0x65647874,
-    0x665f6373,
-    0x74737269,
-    0x203d2120,
-    0x4c4c554e,
-    0x00000000,
-    0x73212121,
-    0x20646e65,
-    0x206d6663,
-    0x78253a31,
-    0x0d78252c,
-    0x0000000a,
-    0x0d677562,
-    0x0000000a,
-    0x6f696473,
-    0x69617420,
-    0x7265206c,
-    0x0d726f72,
-    0x0000000a,
-    0x3a727265,
-    0x206f6e20,
-    0x2067736d,
-    0x21746b70,
-    0x00000a0d,
-    0x21727265,
-    0x74202121,
-    0x63206c78,
-    0x6e206d66,
-    0x7562206f,
-    0x72656666,
-    0x726f6620,
-    0x62737520,
-    0x00000a0d,
-    0x4244819d,
-    0x57203a47,
-    0x69746972,
-    0x6d20676e,
-    0x726f6d65,
-    0x69772079,
-    0x30206874,
-    0x38302578,
-    0x202f2078,
-    0x203a6425,
-    0x2578305b,
-    0x5d783830,
-    0x30203d20,
-    0x38302578,
-    0x202f2078,
-    0x000a6425,
-    0x6b73616d,
-    0x69727720,
-    0x253a6574,
-    0x78252c78,
-    0x2c78252c,
-    0x0a0d7825,
-    0x00000000,
-    0x4244819d,
-    0x57203a47,
-    0x69746972,
-    0x6d20676e,
-    0x726f6d65,
-    0x69772079,
-    0x6d206874,
-    0x3a6b7361,
-    0x30257830,
-    0x202c7838,
-    0x61746164,
-    0x2578303a,
-    0x20783830,
-    0x6425202f,
-    0x305b203a,
-    0x38302578,
-    0x3d205d78,
-    0x25783020,
-    0x20783830,
-    0x6425202f,
-    0x0000000a,
-    0x5f6c6168,
-    0x6863616d,
-    0x78725f77,
-    0x6e63625f,
-    0x7275645f,
-    0x6f697461,
-    0x0000006e,
-    0x5f6c6168,
-    0x6863616d,
-    0x6c735f77,
-    0x5f706565,
-    0x63656863,
-    0x61705f6b,
-    0x00686374,
-    0x745f6d6d,
-    0x5f747462,
-    0x706d6f63,
-    0x5f657475,
-    0x63746170,
-    0x00000068,
-    0x735f6d6d,
-    0x7065656c,
-    0x6f666e69,
-    0x5f78725f,
-    0x5f747665,
-    0x63746170,
-    0x00000068,
-    0x786e7772,
-    0x656c735f,
-    0x635f7065,
-    0x61676b6c,
-    0x635f6574,
-    0x69666e6f,
-    0x61705f67,
-    0x00686374,
-    0x786e7772,
-    0x656c735f,
-    0x645f7065,
-    0x73706565,
-    0x7065656c,
-    0x6e6f635f,
-    0x5f676966,
-    0x63746170,
-    0x00000068,
-    0x5f6c7874,
-    0x5f6d6663,
-    0x5f747665,
-    0x63746170,
-    0x00000068,
+u32 func_tbl[1721] = {
+	0x8cc88cc3, 0xd8084283, 0x1ac0d205, 0xbfcc283f, 0x20012000, 0x20014770,
+	0x20004770, 0xbf004770, 0x481d4a1c, 0xb538491d, 0x68056913, 0xf8b16914,
+	0xf8b100b0, 0xf5a310b2, 0xeb0363fa, 0x1b1b1345, 0x1a5b1a1b, 0xdb1a2b00,
+	0x681b4b15, 0x68dcb143, 0x1ae36913, 0x63faf5a3, 0x1a5b1a1b, 0xdb012b00,
+	0xbd382001, 0x681b4b0f, 0x3000f9b3, 0xda062b00, 0x1ae46913, 0x549cf504,
+	0x2c003408, 0x2000db01, 0x4909bd38, 0xf44f4809, 0xf66b7202, 0x2000fad9,
+	0xbf00bd38, 0x40501000, 0x40328040, 0x0017192c, 0x00178bf0, 0x00173250,
+	0x001c5a3c, 0x001c56b4, 0x4ff0e92d, 0x8c05461c, 0x3062f893, 0x9020f8d2,
+	0xf8d06987, 0xb089b01c, 0x02ad4616, 0x2012e9dd, 0xf8b4b9d3, 0xf1bcc068,
+	0xd0150f00, 0x6ab38b52, 0xf202fb0c, 0x07189205, 0xf20cfb05, 0xd0199206,
+	0xebb72300, 0xf44f0a09, 0x930776fa, 0xf5039b05, 0xe9c473c8, 0xe071a31f,
+	0xf0402800, 0x950680ba, 0x0a01f04f, 0x6ab28b50, 0xf000fb0a, 0x90050712,
+	0x8122f040, 0xf8df6af2, 0xf8dfc2bc, 0xf8dc82bc, 0x48983000, 0x1203f3c2,
+	0x037ff023, 0x2002f818, 0xf8cc4313, 0x6ab33000, 0xf3c34a93, 0xea4113c0,
+	0xf04f5103, 0x60014300, 0xf3bf6013, 0xbf008f4f, 0x00586813, 0x4b8dd5fc,
+	0xf9b16819, 0x29001000, 0x80aef2c0, 0x68124a88, 0xfa82fa1f, 0x07126ab2,
+	0x809df040, 0xf8df6af2, 0x4882c25c, 0x1000f8dc, 0x1203f3c2, 0x017ff021,
+	0x2002f818, 0xf8cc430a, 0x6ab22000, 0xf3c2497c, 0x051212c0, 0x0218f042,
+	0x4600f04f, 0x600e6002, 0x8f4ff3bf, 0x680abf00, 0xd5fc0056, 0xf9b3681b,
+	0x2b003000, 0x4a72db6e, 0x3062f894, 0x22006816, 0xebaab2b6, 0x92070a06,
+	0x0909ebb7, 0x0a0aeb19, 0xd0872b00, 0x79e5ea4f, 0x464b462a, 0x46594638,
+	0xfc50f679, 0x92021bba, 0xfb009a07, 0xeb6bf309, 0xfb050202, 0x92033301,
+	0x0105fba0, 0xe9dd4419, 0x42992302, 0x4290bf08, 0xe9cdbf38, 0x4b5e0102,
+	0x6702e9dd, 0x9b066819, 0x018918f6, 0x9905d430, 0xf5a11a71, 0x4b597ac8,
+	0x69194a59, 0x691b6812, 0x44511a89, 0xf5a31acb, 0x3b1453a5, 0x6a632b00,
+	0x1949bfb8, 0xd022428b, 0x6a1a4b52, 0xd04142a2, 0xf1044d51, 0xf8d50018,
+	0x479831e0, 0x30a8f8d5, 0xb0094620, 0x4ff0e8bd, 0xf8904718, 0xf1baa002,
+	0xd1010f00, 0xa003f890, 0xf00afb05, 0xe73d9006, 0x98054946, 0xeba11a09,
+	0x44b20a0a, 0xb009e7cb, 0x8ff0e8bd, 0x0058680b, 0x4941d48d, 0xf44f4841,
+	0xf66b72ae, 0x2200f98f, 0x3062f894, 0xf5aa9207, 0xf44f7afa, 0xe78776fa,
+	0x00516812, 0xaf4ef53f, 0x48384937, 0x72aef44f, 0xf97cf66b, 0x7afaf44f,
+	0xe7474b2c, 0x62614a2c, 0x01926812, 0x4a32d4b8, 0x68124d32, 0x1024f893,
+	0x4207f3c2, 0x2d23f885, 0x4a2fbb61, 0x6812492f, 0x20016809, 0xf885b2d2,
+	0xf8832d24, 0x780b0024, 0xd1054283, 0x4a2b492a, 0x6813600b, 0x60134303,
+	0x2d23f895, 0x3d24f895, 0xd21b429a, 0x681b4b17, 0x3000f9b3, 0xda0d2b00,
+	0x2d23f895, 0x3d24f895, 0xd307429a, 0x48214920, 0xf44f4d15, 0xf66b7221,
+	0xe787f96f, 0xe7854d12, 0xf44f2200, 0x920776fa, 0xe7354692, 0x4b124814,
+	0x1d23f895, 0x2d24f895, 0x6806681b, 0xb2f64816, 0x96000c1b, 0xff82f66a,
+	0xbf00e7d4, 0x40328160, 0x4032816c, 0x00173250, 0x4032004c, 0x40501000,
+	0x403280a4, 0x00178d3c, 0x00171a30, 0xfffffe70, 0x001c5a20, 0x001c56e0,
+	0x40328044, 0x001e4000, 0x40320090, 0x00173270, 0x40328070, 0x40328074,
+	0x001c5a58, 0x001c5718, 0x001c5704, 0x40328164, 0x00041830, 0x4ff0e92d,
+	0x9354f8df, 0xb020f8d9, 0xf44fb083, 0xf6692000, 0xf1bbfd9b, 0xf0000f00,
+	0x4cb480f1, 0xa33cf8df, 0x4fb37fa1, 0x8338f8df, 0x29004eb2, 0x80e6f000,
+	0xd50e0708, 0xf8db4bb0, 0x681b0070, 0x2010f8da, 0x4403685b, 0x2b001a9b,
+	0x80c7f2c0, 0x01f7f001, 0x074a77a1, 0x8095f100, 0xd515078b, 0x3004f8db,
+	0x0302f023, 0x3004f8cb, 0x301df899, 0xd1082b05, 0x48a34da2, 0x31d8f8d5,
+	0x23004798, 0xf8897fa1, 0xf001301d, 0x77a101fd, 0xd52d07cd, 0x01586833,
+	0x809ff140, 0x0c096831, 0x7f7cf411, 0x80a6f000, 0x4b983910, 0x01fff001,
+	0x1281eb01, 0x03c2eb03, 0x2021f893, 0xf0002a00, 0x4a93809d, 0x68137f99,
+	0xf9b34a92, 0xf44f3000, 0xfb0060a4, 0x2b002201, 0xf2c09200, 0x683b809c,
+	0x2fe0f413, 0x80a5f000, 0xf0017fa1, 0x77a101fe, 0xd59e068a, 0x49894e88,
+	0xf3c56835, 0x463a1741, 0xf66a2002, 0x2300ff23, 0x1547f3c5, 0x3078f88b,
+	0xf0402f00, 0x4e7b80af, 0x4d824a81, 0xf4236813, 0x60137300, 0x3004f8db,
+	0x21d8f8d6, 0x0301f023, 0x3004f8cb, 0x0028f10b, 0x682a4790, 0x2b027813,
+	0x8114f000, 0x680b4974, 0x0301f023, 0x7813600b, 0xd1122b01, 0x41fff501,
+	0x4a733134, 0x3010f8da, 0xf8b26808, 0xf8d610b2, 0xeb0321e0, 0x1a591340,
+	0x0018f10b, 0x682b4790, 0x2b02781b, 0x80b4f000, 0xf0017fa1, 0x77a101df,
+	0x4968e74f, 0x20024d5d, 0xfedcf66a, 0x68634966, 0xf022680a, 0x600a0204,
+	0xf4436822, 0x431a7300, 0xf8d5614a, 0x60631498, 0x0063f89b, 0x3494f8d5,
+	0x4798465a, 0x7fa1683b, 0x737cf023, 0xf8d8603b, 0xf0013000, 0xf44301fb,
+	0xf8c80380, 0x77a13000, 0x4856e742, 0xfe66f66a, 0x2200e782, 0x006cf89b,
+	0xf6584611, 0xb160fd17, 0xe72f7fa1, 0xf66a4850, 0xe775fe59, 0xf66a484f,
+	0xe771fe55, 0xe8bdb003, 0xf8da8ff0, 0x7fa13010, 0x3070f8cb, 0x4593e71e,
+	0xaf61f43f, 0x48494948, 0x22e6f240, 0xf818f66b, 0xf413683b, 0xf47f2fe0,
+	0x6832af5b, 0x49446833, 0xf3c30fd0, 0x46057380, 0x20024602, 0xf66a9301,
+	0x9b01fe81, 0x0205ea53, 0xf43f4628, 0x4d2baf49, 0x46199a00, 0x323cf8d5,
+	0x68334798, 0x4300f023, 0x68336033, 0x4380f023, 0xe7396033, 0x2010f8da,
+	0x529cf502, 0x32084631, 0xf8dae005, 0x1ad33010, 0xf2c02b00, 0x680b80b2,
+	0xd5f6071b, 0x8080f8df, 0x3000f8d8, 0x0308f023, 0x3000f8c8, 0x3000f8d8,
+	0xd51206de, 0x49274e15, 0xf66a2002, 0xf8d6fe4b, 0xf005323c, 0x08780101,
+	0x4798465a, 0x3000f8d8, 0x0310f023, 0x3000f8c8, 0x4b1fe722, 0x4e0b491f,
+	0x601d2501, 0xf66a2002, 0x4b1dfe35, 0xe717601d, 0x22304b1c, 0xf657601a,
+	0xe745fddb, 0x00178bb8, 0x40320074, 0x40320070, 0x00173244, 0x00171a30,
+	0x00178d48, 0x00175aa8, 0x00173250, 0x00177738, 0x4032008c, 0x001c57ec,
+	0x4033b390, 0x00173270, 0x0017192c, 0x001c578c, 0x4032004c, 0x001c5790,
+	0x001c57a8, 0x001c57bc, 0x001c5a70, 0x001c57d0, 0x001c57e0, 0x001c580c,
+	0x40328564, 0x001c5818, 0x40328568, 0x40320038, 0x00178d3c, 0x40501000,
+	0x4032006c, 0x8310f3ef, 0xd40307d8, 0x4b31b672, 0x601a2201, 0x4f314b30,
+	0x3201681a, 0x2100601a, 0x6039683a, 0x080ff002, 0x2010f8da, 0x46164631,
+	0xf247460a, 0xe0045030, 0x1010f8da, 0x42811b89, 0x6839d81b, 0xd1f70709,
+	0x49264825, 0xc000f8d0, 0x4616680f, 0x2010f8da, 0x0f00f1b8, 0x4a22d11a,
+	0x60112104, 0xb132681a, 0x3a01491a, 0x680b601a, 0xb103b90a, 0x682ab662,
+	0x491ce6b0, 0x20029200, 0xfdb0f66a, 0x9a004b14, 0x4919e7d3, 0xf66a2002,
+	0xe74bfda9, 0x070cea07, 0xd4e0077f, 0x1600e9cd, 0x46164680, 0x077ae001,
+	0x9a00d412, 0x7000f8d8, 0xf8da6812, 0xf2471010, 0x1b895030, 0xea074281,
+	0xd9f00702, 0x2002490b, 0xfd8cf66a, 0xe7ea4b02, 0xe7c49e01, 0x0017569c,
+	0x00172600, 0x40320038, 0x4032806c, 0x40328074, 0x40328070, 0x001c5828,
+	0x001c57f8, 0x001c5834, 0xf890b5f8, 0x2b003064, 0xf890d03a, 0x4604308a,
+	0xd1362b00, 0xf8944e32, 0x4a32306c, 0x6a674932, 0xeb036a09, 0xeb021383,
+	0x42a103c3, 0x443d685d, 0xf8d6d044, 0x462931e0, 0x0018f104, 0x46204798,
+	0xfafaf65e, 0x1080f8d4, 0x3214f8d6, 0x46204439, 0xf8d64798, 0x462a30a4,
+	0x46204639, 0xb9784798, 0x3078f894, 0x49216862, 0xb2db3301, 0x0201f042,
+	0xf8846809, 0x60623078, 0x4293780a, 0xd029d811, 0x3b01bdf8, 0x2b01b2db,
+	0x308af880, 0x2b02d912, 0xd1c04e13, 0x0063f890, 0x31c0f8d6, 0x47982100,
+	0xf8d6e7b9, 0xf8941164, 0x4622006c, 0x40f8e8bd, 0xbb84f658, 0x40f8e8bd,
+	0xbb3af65e, 0x62654b0c, 0x30b5f893, 0xd1ba2b00, 0x681b4b0a, 0x2b02781b,
+	0xe7b4d1af, 0xe8bd4620, 0xf66540f8, 0xbf00b8d1, 0x00171a30, 0x00175aa8,
+	0x00178d3c, 0x00173244, 0x0017192c, 0x00173270, 0x4c5cb538, 0x68224b5c,
+	0xf002495c, 0x701a020f, 0xf66a2002, 0x6823fcef, 0xd02e0718, 0x4a594958,
+	0x2000680b, 0x4300f023, 0x6020600b, 0x07596813, 0x4b55d5fc, 0x4a554952,
+	0x60182004, 0xf043680b, 0x600b4300, 0xf0436813, 0x60136300, 0x20024950,
+	0xfcd0f66a, 0x4a4f4b47, 0x494f4847, 0x601c2420, 0x24016813, 0x0310f043,
+	0x70446013, 0x781b680b, 0xd0382b03, 0xd0062b01, 0x4a44bd38, 0xf0236813,
+	0x60136300, 0x4a45e7e2, 0x035b6813, 0x4a44d5fc, 0x311c6911, 0x1acb6913,
+	0xdafb2b00, 0x681c4b41, 0x4b41b174, 0xf9b3681b, 0x2b003000, 0x4a3fdb4e,
+	0xf8b268e3, 0x4a3a10b2, 0x21041a5b, 0x60916313, 0x4a3c493b, 0xf443680b,
+	0x600b4300, 0xf4436d13, 0x65134300, 0xf0236dd3, 0xf0430303, 0xf0434300,
+	0x65d30301, 0x4b2fbd38, 0xb174681c, 0x681b4b2e, 0x3000f9b3, 0xdb152b00,
+	0x68e34a2c, 0x10b2f8b2, 0x1a5b4a27, 0x63132104, 0x4b2b6091, 0xf042681a,
+	0x601a0201, 0x075a681b, 0x4b28d5ae, 0x7200f44f, 0xbd38601a, 0x4d214b1e,
+	0x68e3691a, 0x10b2f8b5, 0x1a521a9a, 0xdae32a00, 0x48224921, 0x32dbf240,
+	0xfddef66a, 0xf8b568e3, 0xe7d910b2, 0x69124d17, 0xf8b568e3, 0x1a9a10b2,
+	0x2a001a52, 0x4918daab, 0xf2404818, 0xf66a32e9, 0x68e3fdcb, 0x10b2f8b5,
+	0xbf00e7a1, 0x40320038, 0x00172604, 0x001c5844, 0x40328074, 0x4032806c,
+	0x40328070, 0x40328048, 0x001c584c, 0x40580010, 0x00173274, 0x40041020,
+	0x40501000, 0x00178bf0, 0x00173250, 0x0017192c, 0x40240014, 0x40506000,
+	0x40044084, 0x40044100, 0x001c5a8c, 0x001c5854, 0xf890b380, 0xb36b3064,
+	0x47f0e92d, 0x4a7b4b7a, 0xf8df4e7b, 0xf8df920c, 0x4d7a8240, 0x460c487a,
+	0x2702497a, 0xc470f8d1, 0x7180f8c3, 0x49786892, 0xc044f8c2, 0x601f2201,
+	0xf8d97032, 0x680b2010, 0xf0236072, 0x600b0302, 0x1000f8d8, 0xc0b2f8b5,
+	0x68018f8b, 0xebb34463, 0xea4f1f41, 0xd3021a41, 0x87f0e8bd, 0x496b4770,
+	0xf66a4638, 0xf8d9fbdf, 0x68f32010, 0x2b001a9b, 0xf2804b67, 0xf89380a2,
+	0xf8932d23, 0x2a012d24, 0xf893d90a, 0x68612d23, 0xf0002a00, 0xf893809e,
+	0x3a012d23, 0xaa02fb01, 0x3d23f893, 0x4652495d, 0xf66a2002, 0xf8d8fbbf,
+	0xf8b53000, 0x8f9a00b2, 0x4b594955, 0xc178f8df, 0x680b691c, 0xebaa4402,
+	0xf0220202, 0xf0030703, 0x433b0303, 0x600b4f53, 0x60b2683b, 0x0301f043,
+	0xf8dc603b, 0xf8dc3000, 0xf3c31000, 0xf4210309, 0xf043717f, 0xf0210301,
+	0x430b0103, 0x3000f8cc, 0x4422683b, 0x60f2075b, 0x4b47d503, 0x7200f44f,
+	0x4a46601a, 0x68134c46, 0xf043493d, 0x60130308, 0xf0436823, 0x60230302,
+	0xf5a2680b, 0x3a1022fe, 0x0301f043, 0x6911600b, 0x7196f501, 0x1a5b6913,
+	0xdbfb2b00, 0x681b4b3b, 0x2b01781b, 0x493ad188, 0x6a4b4c3a, 0xf0236824,
+	0xf04303ff, 0x624b03df, 0xf4236a4b, 0xf443437f, 0x624b435f, 0x4b34b194,
+	0xf9b3681b, 0x2b003000, 0x68e2db31, 0x48316861, 0xfb04f66a, 0x10b2f8b5,
+	0x4a2568e3, 0x21041a5b, 0x60916313, 0x4a28492c, 0xf443680b, 0x600b4300,
+	0xf4436d13, 0x65134300, 0xf0236dd3, 0xf0430303, 0xf0434300, 0x65d30301,
+	0xf4436813, 0x60135380, 0x4922e74e, 0x3d23f893, 0x46524638, 0xfb2ef66a,
+	0xf893e76d, 0x3a012d24, 0xaa02fb01, 0x6913e760, 0x1ad368e2, 0x28001a18,
+	0x4919dac8, 0xf2404819, 0xf66a4231, 0xe7c0fca1, 0xe000e100, 0xe000ed00,
+	0x00173254, 0x0017192c, 0x40328040, 0x00171a30, 0x40320084, 0x001c589c,
+	0x001e4000, 0x001c58b8, 0x40501000, 0x40044084, 0x40044100, 0x40580010,
+	0x40580018, 0x00173274, 0x40506000, 0x00178bf0, 0x00173250, 0x001c58c8,
+	0x40240014, 0x001c58a4, 0x001c5aac, 0x001c5854, 0x00173244, 0x4ff0e92d,
+	0x4abd4bbc, 0xf852681b, 0xf9b34020, 0x4abb3000, 0x8b02ed2d, 0x02c0eb02,
+	0xee082b00, 0xb08b2a10, 0xea4f4683, 0xf2c005c0, 0x462082c4, 0xf8d0f669,
+	0xf8534bb2, 0xf1b9903b, 0xf0000f00, 0x230080e5, 0x3303e9cd, 0xf5059302,
+	0x9301629e, 0xf10b469a, 0x9208039e, 0x464c9305, 0xf898e079, 0x06df3004,
+	0x80d2f140, 0xf4226932, 0x9a010900, 0x9010f8c6, 0x065d3201, 0xf1009201,
+	0x4fa180e0, 0xf8d74620, 0x47983418, 0xf4036b63, 0xf5b31360, 0xbf081f20,
+	0xf3ef46a2, 0x07d98310, 0xb672d403, 0x22014b99, 0x4d99601a, 0xee18682b,
+	0x33010a10, 0xf669602b, 0x6b63f951, 0x1360f403, 0x1f60f5b3, 0x80a9f000,
+	0xb133682b, 0x3b014a8f, 0x602b6812, 0xb102b90b, 0xf8dfb662, 0xf8d88240,
+	0x78193000, 0xf419b391, 0xd1050300, 0x002ef9b4, 0x28008de2, 0x817ef2c0,
+	0x302cf894, 0x202af894, 0xf8b44884, 0xeb03c008, 0x441303c3, 0x530ef203,
+	0xf8502901, 0xeba22023, 0xf840020c, 0xf0002023, 0x6ce080d5, 0xf650b138,
+	0xf8d8fd4f, 0x781e3000, 0xf0002e01, 0x4621810f, 0xf66a4658, 0x6b63fc95,
+	0x1360f403, 0x1f60f5b3, 0x80eaf000, 0xf8534b6d, 0x2c00403b, 0xf8d4d05c,
+	0x6d268048, 0x0f00f1b8, 0xaf7ff47f, 0x8310f3ef, 0xd40307d9, 0x4b67b672,
+	0x601a2201, 0x682b4d66, 0x0a10ee18, 0x602b3301, 0xf8ecf669, 0xb133682b,
+	0x3b014a60, 0x602b6812, 0xb102b90b, 0x4f5cb662, 0x9178f8df, 0x817cf8df,
+	0xf6764620, 0xf8d7ff21, 0x46203418, 0xf8d74798, 0x220033ac, 0xf18bfa5f,
+	0x47984620, 0x302cf894, 0x102af894, 0xeb038922, 0x440b03c3, 0x530ef203,
+	0x1023f859, 0xf8491a8a, 0xf8d82023, 0x781b3000, 0xd0642b01, 0xd0532b02,
+	0xd1082b03, 0x3054f894, 0xf0002b01, 0x8de381db, 0xf10007d9, 0x4621814c,
+	0xf66a4658, 0x4b3ffc31, 0x403bf853, 0xd1a22c00, 0xecbdb00b, 0xe8bd8b02,
+	0x4b388ff0, 0xf9b3681b, 0x2b003000, 0x808bf2c0, 0xe9dd4650, 0xf6761201,
+	0x4640fee7, 0xfbeef659, 0xe9cd2300, 0x469a3301, 0xf8d8e742, 0xb1b220dc,
+	0x8ce38811, 0x1311eba3, 0x030bf3c3, 0x71fef240, 0xd816428b, 0xea4f2b3f,
+	0xd8121113, 0x0241eb02, 0x030ff003, 0xfa428852, 0x07d8f303, 0x9b02d509,
+	0x93023301, 0x0304f44f, 0x0903ea49, 0x9010f8c6, 0xf44fe6fb, 0xe7f72380,
+	0x3054f894, 0xf0002b01, 0x8de38117, 0xd5ae07da, 0xf6682080, 0xf8d8ff75,
+	0x781b3000, 0xf894e79c, 0x2b013054, 0x80f7f000, 0x07db8de3, 0x2080d59f,
+	0xff66f668, 0x3000f8d8, 0xe78b781b, 0x3054f894, 0xf47f2b01, 0xf890af26,
+	0xf0433f20, 0xf1060302, 0xf8800110, 0x22043f20, 0xf6512012, 0x8ba1fd2b,
+	0x46224809, 0xf91ef66a, 0xbf00e713, 0x00173250, 0x0003fc40, 0x00175980,
+	0x00171a30, 0x0017569c, 0x00172600, 0x00173278, 0x001c5904, 0x00173274,
+	0x2b009b03, 0x808bf040, 0xf48bfa5f, 0xf6682080, 0x4620ff2f, 0xfebef659,
+	0x93032300, 0xf1bae706, 0xf47f0f00, 0x49aaaf71, 0xf24048aa, 0xf66a42e7,
+	0xe769fac7, 0xe9d34ba8, 0x69130201, 0x46804798, 0xf43f2800, 0xf650aee8,
+	0x4603fd49, 0xf0002800, 0x22008096, 0x600249a1, 0x605a6808, 0x609a4440,
+	0xf3ef6018, 0x07d28210, 0x812ef140, 0x6829489c, 0x31016802, 0x0201f042,
+	0x60026029, 0x68124a98, 0xd4fb0790, 0x68124a97, 0xf0002a00, 0x4e968116,
+	0x2a006872, 0x8149f000, 0x4a926053, 0x681289b0, 0x4b906073, 0x30013201,
+	0x601a81b0, 0x68134a8c, 0x0301f023, 0x29006013, 0xaeadf43f, 0x39014b8b,
+	0x6029681b, 0xf47f2900, 0x2b00aea6, 0xaea3f43f, 0xe6a0b662, 0x49866d20,
+	0x64a36503, 0xf8946103, 0x63e3502b, 0xf3c29b05, 0x20a4020e, 0x0201f042,
+	0x3005fb10, 0x63a4f44f, 0x1305fb03, 0xeb0185e2, 0x4a7c00c0, 0x46219304,
+	0xffe2f668, 0xf4036b63, 0xf5b31360, 0xd0021f60, 0x93032301, 0x9804e686,
+	0xfd60f656, 0xf43f2800, 0x4d73af6f, 0x31fff895, 0xf47f2b00, 0x9b04af69,
+	0xf8cd9a08, 0xfa5fb00c, 0xf8ddf48b, 0x46d39014, 0x4698189e, 0xe00946ba,
+	0xff74f668, 0x3424f8da, 0x46214638, 0xf8954798, 0xb92331ff, 0x7039f858,
+	0x2f004630, 0x46dad1f0, 0xb00cf8dd, 0x2080e74a, 0xfe7af668, 0x4640e6af,
+	0xfb92f650, 0xf899e647, 0x22043f20, 0x0302f043, 0x0110f106, 0xf8892012,
+	0xf6513f20, 0x8de3fc43, 0xf53f07da, 0xe6fdaefc, 0xf6539306, 0x9b06f95d,
+	0x28009007, 0x80c0f000, 0x4b509309, 0x2a00681a, 0x80c2f000, 0xf6684618,
+	0x9b07ff39, 0xf04f2204, 0x21120e00, 0x70994684, 0xf883701a, 0xf883e001,
+	0xf106e003, 0x18980110, 0xc018f8cd, 0xfdc4f678, 0x8a194b42, 0xf5b19b09,
+	0xd85a7fc3, 0xb29b1c4b, 0x00ca9309, 0x4b3e9806, 0x68188181, 0x4b3d9907,
+	0x0c02eb00, 0x0e01f04f, 0x1004f8cc, 0x400b5881, 0x6380f043, 0x0308f043,
+	0xf8995083, 0x4a333782, 0x82119909, 0xf8894473, 0x9b063782, 0x22082100,
+	0xc004f8c3, 0xe00ef883, 0x609a6019, 0x8310f3ef, 0xd40307db, 0x4b25b672,
+	0xe000f8c3, 0x482a682b, 0x33019906, 0xf668602b, 0xf8d7fea5, 0x47983444,
+	0xb133682b, 0x3b014a1d, 0x602b6812, 0xb102b90b, 0x8de3b662, 0xf53f07d8,
+	0xe67cae7b, 0x69324b1f, 0x601a681b, 0xffaef64e, 0x4b1de61d, 0x421c681b,
+	0xad37f47f, 0x481b490a, 0x6293f44f, 0xf988f66a, 0x2200e52f, 0x46119309,
+	0x4a17e7a4, 0xbb6a6812, 0x4e094a15, 0xe6e86013, 0x4a08b672, 0xe6cd6016,
+	0x001c5ad0, 0x001c58ec, 0x001755b4, 0x001719e4, 0x40240060, 0x40240064,
+	0x0017559c, 0x0017569c, 0x00177738, 0x001c4001, 0x00175780, 0x0017469c,
+	0x001755d4, 0x31ff0000, 0x001746a4, 0x00180000, 0x0017a5a0, 0x001c58d4,
+	0x40240068, 0x9306480b, 0xff78f669, 0x9b066829, 0x4809e7ca, 0xf6699306,
+	0x6829ff71, 0xe6b09b06, 0xb00b4806, 0x8b02ecbd, 0x4ff0e8bd, 0xbcdef64f,
+	0xe7f64803, 0x001c591c, 0x001c5924, 0x001c5938, 0x001c594c, 0xf240b530,
+	0xb0834003, 0x4619460d, 0xf6682308, 0xe9d5f98d, 0x46043200, 0x3200e9c0,
+	0xe9cd4611, 0x48042200, 0xff48f669, 0xf6684620, 0x2000f9af, 0xbd30b003,
+	0x001c5970, 0x460cb570, 0x4619b084, 0x4012f240, 0xf6682308, 0x6822f971,
+	0x429a4b12, 0xd0104605, 0x686168a3, 0xe9c54810, 0xe9cd2300, 0x92003301,
+	0xf669461a, 0x4628ff27, 0xf98ef668, 0xb0042000, 0xe9d4bd70, 0x68116301,
+	0x404b4808, 0x404b4033, 0xe9d46013, 0x680a1300, 0x68a29200, 0xff12f669,
+	0xe7dd6822, 0x40344058, 0x001c59cc, 0x001c59b0, 0xbf002332, 0xf0133b01,
+	0xd1fa03ff, 0xbf004770, 0xbf0023c8, 0xf0133b01, 0xd1fa03ff, 0xbf004770,
+	0x49724a71, 0xf8df6813, 0xf023c208, 0xb5f00302, 0x680b6013, 0x4c6f4a6e,
+	0xf4234f6f, 0x600b6300, 0x496e6813, 0xf4232800, 0xbf1c7380, 0x468c4627,
+	0x20326013, 0x3801bf00, 0x00fff010, 0xf8dfd1fa, 0x4a63e18c, 0x3000f8de,
+	0xf4234e65, 0xf8ce5380, 0x68133000, 0x7300f423, 0xf8de6013, 0xf4433000,
+	0xf8ce6380, 0xf8de3000, 0xf4433000, 0xf8ce6300, 0x46723000, 0x1cc125ff,
+	0x4664b2c9, 0xf0236813, 0x430b03ff, 0xf8546013, 0x60333b04, 0xf4436813,
+	0x60137380, 0xbf00bf00, 0xbf00bf00, 0x049b6813, 0x3901d5fc, 0x428db2c9,
+	0x3004d1e8, 0x28803504, 0xf10cb2ed, 0xd1de0c10, 0x3000f8de, 0x6380f423,
+	0x3000f8ce, 0xbf0023c8, 0xf0133b01, 0xd1fa03ff, 0x493f4c3e, 0x48436822,
+	0x6200f422, 0x680a6022, 0x0280f042, 0x680a600a, 0x7280f442, 0x600a3f04,
+	0xf022680a, 0x431a021f, 0xf857600a, 0x60022f04, 0xf042680a, 0x600a0220,
+	0xbf00bf00, 0xbf00bf00, 0x0552680a, 0x3301d5fc, 0xd1e92b10, 0xf023680b,
+	0x600b0380, 0xbf0023c8, 0xf0133b01, 0xd1fa03ff, 0x4a2d4927, 0xf423680b,
+	0x600b7380, 0xf4436813, 0x60131300, 0xbf002332, 0xf0133b01, 0xd1fa03ff,
+	0x4a1f4b1e, 0x4d256819, 0x48264c25, 0xf4414e26, 0x60195180, 0xf4416811,
+	0x60117100, 0xf4416819, 0x60196100, 0x4b216811, 0x7180f441, 0x682a6011,
+	0xf442491f, 0x602a5280, 0xf4226822, 0x60222280, 0xf0226802, 0x60025200,
+	0x60306818, 0x45bbf5a5, 0x685c3d78, 0x689d602c, 0x4a16600d, 0x601568dd,
+	0x691d4815, 0xe9d36005, 0x4c145005, 0x602569db, 0x61136108, 0xbf00bdf0,
+	0x40580018, 0x40344060, 0x4034406c, 0x001718a4, 0x00171824, 0x00171624,
+	0x40344064, 0x40344070, 0x40344058, 0x40342014, 0x40342018, 0x4034201c,
+	0x4033c218, 0x001718e4, 0x4033c220, 0x4033c224, 0x4033c228, 0x4033c22c,
+	0x00171324, 0x6c616821, 0x6e6f615f, 0x656d6974, 0x69745f72, 0x705f656d,
+	0x28747361, 0x656d6974, 0x743e2d72, 0x20656d69, 0x3035202b, 0x00293030,
+	0x616d786e, 0x69745f63, 0x6f5f656d, 0x69615f6e, 0x61765f72, 0x5f64696c,
+	0x66746567, 0x21202928, 0x0030203d, 0x6d697464, 0x2c64253a, 0x252c6425,
+	0x64252c64, 0x00000a0d, 0x6f76282a, 0x6974616c, 0x7520656c, 0x38746e69,
+	0x2a20745f, 0x5f672629, 0x5f6e6f61, 0x72616873, 0x642e6465, 0x5f6d6974,
+	0x5f746e63, 0x736e6f61, 0x65726168, 0x203c2064, 0x6f76282a, 0x6974616c,
+	0x7520656c, 0x38746e69, 0x2a20745f, 0x5f672629, 0x5f6e6f61, 0x72616873,
+	0x642e6465, 0x5f6d6974, 0x69726570, 0x615f646f, 0x68736e6f, 0x64657261,
+	0x00000000, 0x00002c4c, 0x654b849b, 0x78646979, 0x766e6920, 0x64696c61,
+	0x3230252c, 0x00000a58, 0x6e49849b, 0x696c6176, 0x656b2064, 0x78646979,
+	0x0000000a, 0x6e49849b, 0x696c6176, 0x54532064, 0x64253a41, 0x0000000a,
+	0x5f666976, 0x20617473, 0x76203d3d, 0x00006669, 0x64253d54, 0x0d64252c,
+	0x0000000a, 0x3a4e4342, 0x0a0d6425, 0x00000000, 0x206e6362, 0x656e6f64,
+	0x6d697420, 0x74756f65, 0x00000a0d, 0x20736366, 0x0a0d6b6f, 0x00000000,
+	0x20736366, 0x20746f6e, 0x0a0d6b6f, 0x00000000, 0x656c6469, 0x72726520,
+	0x00000a0d, 0x656c6469, 0x746e6920, 0x72726520, 0x00000a0d, 0x2c642564,
+	0x00000000, 0x0a0d6564, 0x00000000, 0x6c616821, 0x63616d5f, 0x745f7768,
+	0x5f656d69, 0x74736170, 0x6d697428, 0x3e2d7265, 0x656d6974, 0x67202d20,
+	0x6669775f, 0x65735f69, 0x6e697474, 0x702e7367, 0x6f5f7277, 0x5f6e6570,
+	0x64737973, 0x79616c65, 0x00000029, 0x78253d74, 0x00000a0d, 0x20746f6e,
+	0x74736170, 0x6425203a, 0x0d64252c, 0x0000000a, 0x73736170, 0x6425203a,
+	0x0d64252c, 0x0000000a, 0x3a706c73, 0x252c7825, 0x000a0d78, 0x655f656b,
+	0x675f7476, 0x29287465, 0x65202620, 0x625f7476, 0x00007469, 0x65647874,
+	0x665f6373, 0x74737269, 0x203d2120, 0x4c4c554e, 0x00000000, 0x73212121,
+	0x20646e65, 0x206d6663, 0x78253a31, 0x0d78252c, 0x0000000a, 0x0d677562,
+	0x0000000a, 0x6f696473, 0x69617420, 0x7265206c, 0x0d726f72, 0x0000000a,
+	0x3a727265, 0x206f6e20, 0x2067736d, 0x21746b70, 0x00000a0d, 0x21727265,
+	0x74202121, 0x63206c78, 0x6e206d66, 0x7562206f, 0x72656666, 0x726f6620,
+	0x62737520, 0x00000a0d, 0x4244819d, 0x57203a47, 0x69746972, 0x6d20676e,
+	0x726f6d65, 0x69772079, 0x30206874, 0x38302578, 0x202f2078, 0x203a6425,
+	0x2578305b, 0x5d783830, 0x30203d20, 0x38302578, 0x202f2078, 0x000a6425,
+	0x6b73616d, 0x69727720, 0x253a6574, 0x78252c78, 0x2c78252c, 0x0a0d7825,
+	0x00000000, 0x4244819d, 0x57203a47, 0x69746972, 0x6d20676e, 0x726f6d65,
+	0x69772079, 0x6d206874, 0x3a6b7361, 0x30257830, 0x202c7838, 0x61746164,
+	0x2578303a, 0x20783830, 0x6425202f, 0x305b203a, 0x38302578, 0x3d205d78,
+	0x25783020, 0x20783830, 0x6425202f, 0x0000000a, 0x5f6c6168, 0x6863616d,
+	0x78725f77, 0x6e63625f, 0x7275645f, 0x6f697461, 0x0000006e, 0x5f6c6168,
+	0x6863616d, 0x6c735f77, 0x5f706565, 0x63656863, 0x61705f6b, 0x00686374,
+	0x745f6d6d, 0x5f747462, 0x706d6f63, 0x5f657475, 0x63746170, 0x00000068,
+	0x735f6d6d, 0x7065656c, 0x6f666e69, 0x5f78725f, 0x5f747665, 0x63746170,
+	0x00000068, 0x786e7772, 0x656c735f, 0x635f7065, 0x61676b6c, 0x635f6574,
+	0x69666e6f, 0x61705f67, 0x00686374, 0x786e7772, 0x656c735f, 0x645f7065,
+	0x73706565, 0x7065656c, 0x6e6f635f, 0x5f676966, 0x63746170, 0x00000068,
+	0x5f6c7874, 0x5f6d6663, 0x5f747665, 0x63746170, 0x00000068,
 
 };
 
 struct aic_feature_t {
 	int hwinfo;
-    int fwlog_en;
+	int fwlog_en;
 };
 
-#define CHIP_REV_U02        0x3
-#define CHIP_REV_U03        0x7
-#define CHIP_SUB_REV_U04    0x20
+#define CHIP_REV_U02 0x3
+#define CHIP_REV_U03 0x7
+#define CHIP_SUB_REV_U04 0x20
 u8 chip_id = 0;
 u8 chip_sub_id = 0; // rom_id for 8800dc
 u8 chip_mcu_id = 0;
 
 #ifdef CONFIG_PMIC_SETTING
 u32 syscfg_tbl_pmic_u02[][2] = {
-    {0x40040000, 0x00001AC8}, // 1) fix panic
-    {0x40040084, 0x00011580},
-    {0x40040080, 0x00000001},
-    {0x40100058, 0x00000000},
+	{ 0x40040000, 0x00001AC8 }, // 1) fix panic
+	{ 0x40040084, 0x00011580 },
+	{ 0x40040080, 0x00000001 },
+	{ 0x40100058, 0x00000000 },
 };
 #endif /* CONFIG_PMIC_SETTING */
 
 u32 syscfg_tbl_u04[][2] = {
-    {0x40040000, 0x0000042C}, // protect usb replenish rxq / flush rxq, skip flush rxq before start_app
-    {0x40040004, 0x0000DD44},
-    {0x40040008, 0x00000448},
-    {0x4004000C, 0x0000044C},
-    {0x0019B800, 0xB9F0F19B},
-    {0x0019B804, 0x0019B81D},
-    {0x0019B808, 0xBF00FA79},
-    {0x0019B80C, 0xF007BF00},
-    {0x0019B810, 0x4605B672}, // code
-    {0x0019B814, 0x21E0F04F},
-    {0x0019B818, 0xBE0BF664},
-    {0x0019B81C, 0xF665B510},
-    {0x0019B820, 0x4804FC9D},
-    {0x0019B824, 0xFA9EF66C},
-    {0x0019B828, 0xFCA8F665},
-    {0x0019B82C, 0x4010E8BD},
-    {0x0019B830, 0xBAC6F66C},
-    {0x0019B834, 0x0019A0C4},
-    {0x40040084, 0x0019B800}, // out base
-    {0x40040080, 0x0000000F},
-    {0x40100058, 0x00000000},
+	{ 0x40040000, 0x0000042C }, // protect usb replenish rxq / flush rxq, skip flush rxq before start_app
+	{ 0x40040004, 0x0000DD44 }, { 0x40040008, 0x00000448 },
+	{ 0x4004000C, 0x0000044C }, { 0x0019B800, 0xB9F0F19B },
+	{ 0x0019B804, 0x0019B81D }, { 0x0019B808, 0xBF00FA79 },
+	{ 0x0019B80C, 0xF007BF00 }, { 0x0019B810, 0x4605B672 }, // code
+	{ 0x0019B814, 0x21E0F04F }, { 0x0019B818, 0xBE0BF664 },
+	{ 0x0019B81C, 0xF665B510 }, { 0x0019B820, 0x4804FC9D },
+	{ 0x0019B824, 0xFA9EF66C }, { 0x0019B828, 0xFCA8F665 },
+	{ 0x0019B82C, 0x4010E8BD }, { 0x0019B830, 0xBAC6F66C },
+	{ 0x0019B834, 0x0019A0C4 }, { 0x40040084, 0x0019B800 }, // out base
+	{ 0x40040080, 0x0000000F }, { 0x40100058, 0x00000000 },
 };
 
 u32 syscfg_tbl[][2] = {
-    {0x40500014, 0x00000101}, // 1)
-    {0x40500018, 0x0000010D}, // 2)
-    {0x40500004, 0x00000010}, // 3) the order should not be changed
-    #ifdef CONFIG_PMIC_SETTING
-    {0x50000000, 0x03220204}, // 2) pmic interface init
-    {0x50019150, 0x00000002}, // 3) for 26m xtal, set div1
-    {0x50017008, 0x00000000}, // 4) stop wdg
-    #endif /* CONFIG_PMIC_SETTING */
+	{ 0x40500014, 0x00000101 }, // 1)
+	{ 0x40500018, 0x0000010D }, // 2)
+	{ 0x40500004, 0x00000010 }, // 3) the order should not be changed
+#ifdef CONFIG_PMIC_SETTING
+	{ 0x50000000, 0x03220204 }, // 2) pmic interface init
+	{ 0x50019150, 0x00000002 }, // 3) for 26m xtal, set div1
+	{ 0x50017008, 0x00000000 }, // 4) stop wdg
+#endif /* CONFIG_PMIC_SETTING */
 };
 
 u32 syscfg_tbl_masked[][3] = {
-    {0x40506024, 0x000000FF, 0x000000DF}, // for clk gate lp_level
-    #ifdef CONFIG_PMIC_SETTING
-    //{0x50017008, 0x00000002, 0x00000000}, // stop wdg
-    #endif /* CONFIG_PMIC_SETTING */
+	{ 0x40506024, 0x000000FF, 0x000000DF }, // for clk gate lp_level
+#ifdef CONFIG_PMIC_SETTING
+//{0x50017008, 0x00000002, 0x00000000}, // stop wdg
+#endif /* CONFIG_PMIC_SETTING */
 };
 
-
 u32 rf_tbl_masked[][3] = {
-    {0x40344058, 0x00800000, 0x00000000},// pll trx
+	{ 0x40344058, 0x00800000, 0x00000000 }, // pll trx
 };
 
 u32 wdt_tbl_masked[][3] = {
-    {0x4010300c, 0x00000001, 0x00000001},
+	{ 0x4010300c, 0x00000001, 0x00000001 },
 };
 
-static void system_config_8800(struct rwnx_hw *rwnx_hw){
-    int syscfg_num;
-    int ret, cnt;
-    const u32 mem_addr = 0x40500000;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
+static void system_config_8800(struct rwnx_hw *rwnx_hw)
+{
+	int syscfg_num;
+	int ret, cnt;
+	const u32 mem_addr = 0x40500000;
+	struct dbg_mem_read_cfm rd_mem_addr_cfm;
+	ret = rwnx_send_dbg_mem_read_req(rwnx_hw, mem_addr, &rd_mem_addr_cfm);
+	if (ret) {
 		AICWFDBG(LOGERROR, "%x rd fail: %d\n", mem_addr, ret);
-        return;
-    }
-    chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
-    //printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x00000004, &rd_mem_addr_cfm);
-    if (ret) {
+		return;
+	}
+	chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
+	//printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x00000004, &rd_mem_addr_cfm);
+	if (ret) {
 		AICWFDBG(LOGERROR, "[0x00000004] rd fail: %d\n", ret);
-        return;
-    }
-    chip_sub_id = (u8)(rd_mem_addr_cfm.memdata >> 4);
-    //printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+		return;
+	}
+	chip_sub_id = (u8)(rd_mem_addr_cfm.memdata >> 4);
+	//printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
 	AICWFDBG(LOGINFO, "chip_id=%x, chip_sub_id=%x\n", chip_id, chip_sub_id);
 
-
 #ifdef CONFIG_PMIC_SETTING
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
-	    if (chip_id == CHIP_REV_U02) {
-	        syscfg_num = sizeof(syscfg_tbl_pmic_u02) / sizeof(u32) / 2;
-	        for (cnt = 0; cnt < syscfg_num; cnt++) {
-	            ret = rwnx_send_dbg_mem_write_req(rwnx_hw, syscfg_tbl_pmic_u02[cnt][0], syscfg_tbl_pmic_u02[cnt][1]);
-	            if (ret) {
-					AICWFDBG(LOGERROR, "%x write fail: %d\n", syscfg_tbl_pmic_u02[cnt][0], ret);
-	                return;
-	            }
-	        }
-	    }
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801) {
+		if (chip_id == CHIP_REV_U02) {
+			syscfg_num =
+				sizeof(syscfg_tbl_pmic_u02) / sizeof(u32) / 2;
+			for (cnt = 0; cnt < syscfg_num; cnt++) {
+				ret = rwnx_send_dbg_mem_write_req(
+					rwnx_hw, syscfg_tbl_pmic_u02[cnt][0],
+					syscfg_tbl_pmic_u02[cnt][1]);
+				if (ret) {
+					AICWFDBG(LOGERROR,
+						 "%x write fail: %d\n",
+						 syscfg_tbl_pmic_u02[cnt][0],
+						 ret);
+					return;
+				}
+			}
+		}
 	}
 #endif
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
-	    if ((chip_id == CHIP_REV_U03) && (chip_sub_id == CHIP_SUB_REV_U04)) {
-	        syscfg_num = sizeof(syscfg_tbl_u04) / sizeof(u32) / 2;
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801) {
+		if ((chip_id == CHIP_REV_U03) &&
+		    (chip_sub_id == CHIP_SUB_REV_U04)) {
+			syscfg_num = sizeof(syscfg_tbl_u04) / sizeof(u32) / 2;
 			AICWFDBG(LOGINFO, "cfg u04\n");
-	        for (cnt = 0; cnt < syscfg_num; cnt++) {
-	            ret = rwnx_send_dbg_mem_write_req(rwnx_hw, syscfg_tbl_u04[cnt][0], syscfg_tbl_u04[cnt][1]);
-	            if (ret) {
-					AICWFDBG(LOGERROR, "%x write fail: %d\n", syscfg_tbl_u04[cnt][0], ret);
-	                return;
-	            }
-	        }
-	    }
+			for (cnt = 0; cnt < syscfg_num; cnt++) {
+				ret = rwnx_send_dbg_mem_write_req(
+					rwnx_hw, syscfg_tbl_u04[cnt][0],
+					syscfg_tbl_u04[cnt][1]);
+				if (ret) {
+					AICWFDBG(LOGERROR,
+						 "%x write fail: %d\n",
+						 syscfg_tbl_u04[cnt][0], ret);
+					return;
+				}
+			}
+		}
 	}
 
 	syscfg_num = sizeof(syscfg_tbl) / sizeof(u32) / 2;
 
-    for (cnt = 0; cnt < syscfg_num; cnt++) {
-        ret = rwnx_send_dbg_mem_write_req(rwnx_hw, syscfg_tbl[cnt][0], syscfg_tbl[cnt][1]);
-        if (ret) {
-			AICWFDBG(LOGERROR, "%x write fail: %d\n", syscfg_tbl[cnt][0], ret);
-            return;
-        }
-    }
-    syscfg_num = sizeof(syscfg_tbl_masked) / sizeof(u32) / 3;
-    for (cnt = 0; cnt < syscfg_num; cnt++) {
-	    if (syscfg_tbl_masked[cnt][0] == 0x00000000) {
-            break;
-        }
-
-        ret = rwnx_send_dbg_mem_mask_write_req(rwnx_hw,
-            syscfg_tbl_masked[cnt][0], syscfg_tbl_masked[cnt][1], syscfg_tbl_masked[cnt][2]);
-        if (ret) {
-			AICWFDBG(LOGERROR, "%x mask write fail: %d\n", syscfg_tbl_masked[cnt][0], ret);
-            return;
-        }
-    }
-
+	for (cnt = 0; cnt < syscfg_num; cnt++) {
+		ret = rwnx_send_dbg_mem_write_req(rwnx_hw, syscfg_tbl[cnt][0],
+						  syscfg_tbl[cnt][1]);
+		if (ret) {
+			AICWFDBG(LOGERROR, "%x write fail: %d\n",
+				 syscfg_tbl[cnt][0], ret);
+			return;
+		}
+	}
+	syscfg_num = sizeof(syscfg_tbl_masked) / sizeof(u32) / 3;
+	for (cnt = 0; cnt < syscfg_num; cnt++) {
+		if (syscfg_tbl_masked[cnt][0] == 0x00000000) {
+			break;
+		}
 
+		ret = rwnx_send_dbg_mem_mask_write_req(
+			rwnx_hw, syscfg_tbl_masked[cnt][0],
+			syscfg_tbl_masked[cnt][1], syscfg_tbl_masked[cnt][2]);
+		if (ret) {
+			AICWFDBG(LOGERROR, "%x mask write fail: %d\n",
+				 syscfg_tbl_masked[cnt][0], ret);
+			return;
+		}
+	}
 }
 
-
 static void system_config(struct rwnx_hw *rwnx_hw)
 {
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801) {
 		system_config_8800(rwnx_hw);
-	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+		   rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
 		system_config_8800dc(rwnx_hw);
 	}
 }
 
 static int wdt_config(struct rwnx_hw *rwnx_hw)
 {
-    int ret = 0;
-    ret = rwnx_send_dbg_mem_mask_write_req(rwnx_hw,
-                wdt_tbl_masked[0][0], wdt_tbl_masked[0][1], wdt_tbl_masked[0][2]);
-    if (ret) {
-        printk("wdt config %x write fail: %d\n", wdt_tbl_masked[0][0], ret);
-    }
-    return ret;
+	int ret = 0;
+	ret = rwnx_send_dbg_mem_mask_write_req(rwnx_hw, wdt_tbl_masked[0][0],
+					       wdt_tbl_masked[0][1],
+					       wdt_tbl_masked[0][2]);
+	if (ret) {
+		printk("wdt config %x write fail: %d\n", wdt_tbl_masked[0][0],
+		       ret);
+	}
+	return ret;
 }
 #if 0
 static void rf_config(struct rwnx_hw *rwnx_hw)
@@ -9067,7 +6665,6 @@ static int start_from_bootrom(struct rwnx_hw *rwnx_hw)
  *
  */
 
-
 #ifdef CONFIG_GPIO_WAKEUP
 static const struct wiphy_wowlan_support aic_wowlan_support = {
 	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_MAGIC_PKT,
@@ -9078,40 +6675,43 @@ extern int get_hardware_info(void);
 
 #ifdef AICWF_USB_SUPPORT
 u32 usbcfg_tbl[][2] = {
-    {0x40200028, 0x0021047e},
-    {0x40200024, 0x0000011d},
+	{ 0x40200028, 0x0021047e },
+	{ 0x40200024, 0x0000011d },
 };
 
 static void aicwf_usb_config(struct rwnx_hw *rwnx_hw)
 {
-    int usbcfg_num = 0;
-    int ret = 0, cnt = 0;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-    const u32 mem_addr = 0x40200024;
+	int usbcfg_num = 0;
+	int ret = 0, cnt = 0;
+	struct dbg_mem_read_cfm rd_mem_addr_cfm;
+	const u32 mem_addr = 0x40200024;
 
-    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        AICWFDBG(LOGERROR, "%x rd fail: %d\n", mem_addr, ret);
-        return;
-    }
-    AICWFDBG(LOGINFO, "usb config read %x\n", rd_mem_addr_cfm.memdata);
-    if ((rd_mem_addr_cfm.memdata & 0xffff) == 0x119) {
-        cnt = 0;
-        usbcfg_num = sizeof(usbcfg_tbl) / sizeof(u32) / 2;
-        for (cnt = 0; cnt < usbcfg_num; cnt++) {
-            ret = rwnx_send_dbg_mem_write_req(rwnx_hw, usbcfg_tbl[cnt][0], usbcfg_tbl[cnt][1]);
-            if (ret) {
-                AICWFDBG(LOGERROR, "%x write fail: %d\n", usbcfg_tbl[cnt][0], ret);
-                return;
-            }
-        }
-    }
+	ret = rwnx_send_dbg_mem_read_req(rwnx_hw, mem_addr, &rd_mem_addr_cfm);
+	if (ret) {
+		AICWFDBG(LOGERROR, "%x rd fail: %d\n", mem_addr, ret);
+		return;
+	}
+	AICWFDBG(LOGINFO, "usb config read %x\n", rd_mem_addr_cfm.memdata);
+	if ((rd_mem_addr_cfm.memdata & 0xffff) == 0x119) {
+		cnt = 0;
+		usbcfg_num = sizeof(usbcfg_tbl) / sizeof(u32) / 2;
+		for (cnt = 0; cnt < usbcfg_num; cnt++) {
+			ret = rwnx_send_dbg_mem_write_req(rwnx_hw,
+							  usbcfg_tbl[cnt][0],
+							  usbcfg_tbl[cnt][1]);
+			if (ret) {
+				AICWFDBG(LOGERROR, "%x write fail: %d\n",
+					 usbcfg_tbl[cnt][0], ret);
+				return;
+			}
+		}
+	}
 }
 #endif // (AICWF_USB_SUPPORT)
 
 static int start_from_bootrom(struct rwnx_hw *rwnx_hw)
 {
-    int ret = 0;
+	int ret = 0;
 
 	/* memory access */
 #ifdef CONFIG_ROM_PATCH_EN
@@ -9121,19 +6721,20 @@ static int start_from_bootrom(struct rwnx_hw *rwnx_hw)
 	const u32 rd_addr = RAM_FMAC_FW_ADDR;
 	const u32 fw_addr = RAM_FMAC_FW_ADDR;
 #endif
-    u32 boot_type;
+	u32 boot_type;
 	struct dbg_mem_read_cfm rd_cfm;
 	AICWFDBG(LOGINFO, "Read FW mem: %08x\n", rd_addr);
 	if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, rd_addr, &rd_cfm))) {
 		return -1;
 	}
-	AICWFDBG(LOGINFO, "cfm: [%08x] = %08x\n", rd_cfm.memaddr, rd_cfm.memdata);
+	AICWFDBG(LOGINFO, "cfm: [%08x] = %08x\n", rd_cfm.memaddr,
+		 rd_cfm.memdata);
 
-    if (testmode == 0) {
-        boot_type = HOST_START_APP_DUMMY;
-    } else {
-        boot_type = HOST_START_APP_AUTO;
-    }
+	if (testmode == 0) {
+		boot_type = HOST_START_APP_DUMMY;
+	} else {
+		boot_type = HOST_START_APP_AUTO;
+	}
 	/* fw start */
 	AICWFDBG(LOGINFO, "Start app: %08x, %d\n", fw_addr, boot_type);
 	if ((ret = rwnx_send_dbg_start_app_req(rwnx_hw, fw_addr, boot_type))) {
@@ -9142,13 +6743,12 @@ static int start_from_bootrom(struct rwnx_hw *rwnx_hw)
 	return 0;
 }
 
-
-int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw){
-
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
+int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw)
+{
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801) {
 		system_config(rwnx_hw);
-	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+		   rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
 #ifdef AICWF_USB_SUPPORT
 		aicwf_usb_config(rwnx_hw);
 #endif
@@ -9157,23 +6757,32 @@ int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw){
 			return -1;
 
 #if defined(CONFIG_START_FROM_BOOTROM)
-        if (chip_sub_id < 2) {
-            if (wdt_config(rwnx_hw)) {
-                return -1;
-            }
-        }
+		if (chip_sub_id < 2) {
+			if (wdt_config(rwnx_hw)) {
+				return -1;
+			}
+		}
 		if (start_from_bootrom(rwnx_hw))
 			return -1;
 #endif
-	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) {
 		rwnx_plat_userconfig_load_8800d80(rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+		rwnx_plat_powerlimit_load_8800d80(rwnx_hw);
+#endif
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		   rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) {
+		rwnx_plat_userconfig_load_8800d80x2(rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+		rwnx_plat_powerlimit_load_8800d80x2(rwnx_hw);
+#endif
 	}
 
 	return 0;
 }
 
-
-int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
+int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw)
+{
 	struct mm_set_rf_calib_cfm cfm;
 	int ret = 0;
 #ifdef CONFIG_5M10M
@@ -9181,7 +6790,7 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 	int32_t param[1];
 	param[0] = BWMODE10M;
 #endif
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801) {
 		if ((ret = rwnx_send_txpwr_idx_req(rwnx_hw))) {
 			return -1;
 		}
@@ -9195,105 +6804,144 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 				return -1;
 		}
 
-	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+		   rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
 		if ((ret = aicwf_set_rf_config_8800dc(rwnx_hw, &cfm)))
 			return -1;
-	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) {
 		if ((ret = aicwf_set_rf_config_8800d80(rwnx_hw, &cfm)))
 			return -1;
+	} else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		   rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) {
+		if ((ret = aicwf_set_rf_config_8800d80x2(rwnx_hw, &cfm)))
+			return -1;
 	}
 #ifdef CONFIG_5M10M
-	rwnx_send_vendor_hwconfig_req(rwnx_hw, hwconfig_id, param);
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hwconfig_id, param, NULL);
 #endif
 	return 0;
 }
+void aic_ipc_setting(struct rwnx_vif *rwnx_vif)
+{
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	uint32_t hw_edca = 1;
+	uint32_t hw_cca = 3;
+	int32_t param[14];
+	int32_t cca[5] = { 0x10, 0, 0, 0, 0 };
+
+	param[0] = 0xFA522;
+	param[1] = 0xFA522;
+	param[2] = 0xFA522;
+	param[3] = 0xFA522;
+	param[4] = rwnx_vif->vif_index;
+	param[5] = 0x1e;
+	param[6] = 0;
+	param[7] = 0;
+	param[8] = 0;
+	param[9] = 0x2;
+	param[10] = 0x2;
+	param[11] = 0x7;
+	param[12] = 0;
+	;
+	param[13] = 1;
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_edca, param, NULL);
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_cca, cca, NULL);
+}
 
 extern void *aicwf_prealloc_txq_alloc(size_t size);
 extern int aicwf_vendor_init(struct wiphy *wiphy);
+#ifdef CONFIG_POWER_LIMIT
+extern char default_ccode[];
+extern char country_code[];
+#endif
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 {
-    struct rwnx_hw *rwnx_hw;
-    struct rwnx_conf_file init_conf;
-    int ret = 0;
-    struct wiphy *wiphy;
-    struct rwnx_vif *vif;
-    int i;
-    u8 dflt_mac[ETH_ALEN] = { 0x88, 0x00, 0x33, 0x77, 0x10, 0x99};
-    struct mm_get_fw_version_cfm fw_version;
-    u8_l mac_addr_efuse[ETH_ALEN];
+	struct rwnx_hw *rwnx_hw;
+	struct rwnx_conf_file init_conf;
+	int ret = 0;
+	struct wiphy *wiphy;
+	struct rwnx_vif *vif;
+	int i;
+	u8 dflt_mac[ETH_ALEN] = { 0x88, 0x00, 0x33, 0x77, 0x10, 0x99 };
+	struct mm_get_fw_version_cfm fw_version;
+	u8_l mac_addr_efuse[ETH_ALEN];
 #ifndef USE_5G
-    struct aic_feature_t feature;
+	struct aic_feature_t feature;
 #endif
-    struct mm_set_stack_start_cfm set_start_cfm;
+	struct mm_set_stack_start_cfm set_start_cfm;
 #ifdef CONFIG_TEMP_COMP
 	struct mm_set_vendor_swconfig_cfm swconfig_cfm;
 #endif
 
-    int nx_remote_sta_max = NX_REMOTE_STA_MAX;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
+	int nx_remote_sta_max = NX_REMOTE_STA_MAX;
 
-if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
-    ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-    g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
-        nx_remote_sta_max = NX_REMOTE_STA_MAX_FOR_OLD_IC;
-}
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
+	    ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) &&
+	     chip_id < 3)) {
+		nx_remote_sta_max = NX_REMOTE_STA_MAX_FOR_OLD_IC;
+	}
 
 //#ifndef CONFIG_RFTEST
 #ifdef CONFIG_MAC_RANDOM_IF_NO_MAC_IN_EFUSE
-    get_random_bytes(&dflt_mac[4], 2);
+	get_random_bytes(&dflt_mac[4], 2);
 #endif
 //#endif
-    /* create a new wiphy for use with cfg80211 */
-    AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__, (int)sizeof(struct rwnx_hw));
-    wiphy = wiphy_new(&rwnx_cfg80211_ops, sizeof(struct rwnx_hw));
-    //dev_set_name(&wiphy->dev,"aicphy%d",0);
-
-    if (!wiphy) {
-        dev_err(rwnx_platform_get_dev(rwnx_plat), "Failed to create new wiphy\n");
-        ret = -ENOMEM;
-        goto err_out;
-    }
+#ifdef CONFIG_POWER_LIMIT
+	memcpy(country_code, default_ccode, 4);
+#endif
+	/* create a new wiphy for use with cfg80211 */
+	AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__,
+		 (int)sizeof(struct rwnx_hw));
+	wiphy = wiphy_new(&rwnx_cfg80211_ops, sizeof(struct rwnx_hw));
+	//dev_set_name(&wiphy->dev,"aicphy%d",0);
+
+	if (!wiphy) {
+		dev_err(rwnx_platform_get_dev(rwnx_plat),
+			"Failed to create new wiphy\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
 
-    rwnx_hw = wiphy_priv(wiphy);
-    rwnx_hw->wiphy = wiphy;
-    rwnx_hw->plat = rwnx_plat;
-    rwnx_hw->dev = rwnx_platform_get_dev(rwnx_plat);
+	rwnx_hw = wiphy_priv(wiphy);
+	rwnx_hw->wiphy = wiphy;
+	rwnx_hw->plat = rwnx_plat;
+	rwnx_hw->dev = rwnx_platform_get_dev(rwnx_plat);
 #ifdef AICWF_SDIO_SUPPORT
-    rwnx_hw->sdiodev = rwnx_plat->sdiodev;
-    rwnx_plat->sdiodev->rwnx_hw = rwnx_hw;
-    rwnx_hw->cmd_mgr = &rwnx_plat->sdiodev->cmd_mgr;
+	rwnx_hw->sdiodev = rwnx_plat->sdiodev;
+	rwnx_plat->sdiodev->rwnx_hw = rwnx_hw;
+	rwnx_hw->cmd_mgr = &rwnx_plat->sdiodev->cmd_mgr;
 #else
-    rwnx_hw->usbdev = rwnx_plat->usbdev;
-    rwnx_plat->usbdev->rwnx_hw = rwnx_hw;
-    rwnx_hw->cmd_mgr = &rwnx_plat->usbdev->cmd_mgr;
+	rwnx_hw->usbdev = rwnx_plat->usbdev;
+	rwnx_plat->usbdev->rwnx_hw = rwnx_hw;
+	rwnx_hw->cmd_mgr = &rwnx_plat->usbdev->cmd_mgr;
 #endif
-    rwnx_hw->mod_params = &rwnx_mod_params;
-    rwnx_hw->tcp_pacing_shift = 7;
+	rwnx_hw->mod_params = &rwnx_mod_params;
+	rwnx_hw->tcp_pacing_shift = 7;
 
 #ifdef CONFIG_SCHED_SCAN
-    rwnx_hw->is_sched_scan = false;
-#endif//CONFIG_SCHED_SCAN
-
-    rwnx_init_aic(rwnx_hw);
-    /* set device pointer for wiphy */
-    set_wiphy_dev(wiphy, rwnx_hw->dev);
-
-    /* Create cache to allocate sw_txhdr */
-    rwnx_hw->sw_txhdr_cache = KMEM_CACHE(rwnx_sw_txhdr, 0);
-    if (!rwnx_hw->sw_txhdr_cache) {
-        wiphy_err(wiphy, "Cannot allocate cache for sw TX header\n");
-        ret = -ENOMEM;
-        goto err_cache;
-    }
+	rwnx_hw->is_sched_scan = false;
+#endif //CONFIG_SCHED_SCAN
+
+	aicwf_wakeup_lock_init(rwnx_hw);
 
+	rwnx_init_aic(rwnx_hw);
+	/* set device pointer for wiphy */
+	set_wiphy_dev(wiphy, rwnx_hw->dev);
+
+	/* Create cache to allocate sw_txhdr */
+	rwnx_hw->sw_txhdr_cache = KMEM_CACHE(rwnx_sw_txhdr, 0);
+	if (!rwnx_hw->sw_txhdr_cache) {
+		wiphy_err(wiphy, "Cannot allocate cache for sw TX header\n");
+		ret = -ENOMEM;
+		goto err_cache;
+	}
 
 #ifdef CONFIG_FILTER_TCP_ACK
-     AICWFDBG(LOGINFO, "%s: FILTER_TCP_ACK\n", __func__);
-    tcp_ack_init(rwnx_hw);
+	AICWFDBG(LOGINFO, "%s: FILTER_TCP_ACK\n", __func__);
+	tcp_ack_init(rwnx_hw);
 #endif
 
 #if 0
@@ -9302,277 +6950,301 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         goto err_config;
     }
 #else
-    memcpy(init_conf.mac_addr, dflt_mac, ETH_ALEN);
+	memcpy(init_conf.mac_addr, dflt_mac, ETH_ALEN);
 #endif
 
-    rwnx_hw->vif_started = 0;
-    rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
-    rwnx_hw->adding_sta = false;
+	rwnx_hw->vif_started = 0;
+	rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
+	rwnx_hw->adding_sta = false;
 
-    rwnx_hw->scan_ie.addr = NULL;
+	rwnx_hw->scan_ie.addr = NULL;
 
-    for (i = 0; i < NX_VIRT_DEV_MAX + nx_remote_sta_max; i++){
-        rwnx_hw->avail_idx_map |= BIT(i);
-    }
+	for (i = 0; i < NX_VIRT_DEV_MAX + nx_remote_sta_max; i++) {
+		rwnx_hw->avail_idx_map |= BIT(i);
+	}
 
-    rwnx_hwq_init(rwnx_hw);
+	rwnx_hwq_init(rwnx_hw);
 
 #ifdef CONFIG_PREALLOC_TXQ
-    rwnx_hw->txq = (struct rwnx_txq*)aicwf_prealloc_txq_alloc(sizeof(struct rwnx_txq)*NX_NB_TXQ);
+	rwnx_hw->txq = (struct rwnx_txq *)aicwf_prealloc_txq_alloc(
+		sizeof(struct rwnx_txq) * NX_NB_TXQ);
 #endif
 
-    for (i = 0; i < NX_NB_TXQ; i++) {
-        rwnx_hw->txq[i].idx = TXQ_INACTIVE;
-    }
+	for (i = 0; i < NX_NB_TXQ; i++) {
+		rwnx_hw->txq[i].idx = TXQ_INACTIVE;
+	}
 
-    rwnx_mu_group_init(rwnx_hw);
+	rwnx_mu_group_init(rwnx_hw);
 
-    /* Initialize RoC element pointer to NULL, indicate that RoC can be started */
-    rwnx_hw->roc_elem = NULL;
-    /* Cookie can not be 0 */
-    rwnx_hw->roc_cookie_cnt = 1;
+	/* Initialize RoC element pointer to NULL, indicate that RoC can be started */
+	rwnx_hw->roc_elem = NULL;
+	/* Cookie can not be 0 */
+	rwnx_hw->roc_cookie_cnt = 1;
 
-    INIT_LIST_HEAD(&rwnx_hw->vifs);
-    mutex_init(&rwnx_hw->mutex);
-    mutex_init(&rwnx_hw->dbgdump_elem.mutex);
-    spin_lock_init(&rwnx_hw->tx_lock);
-    spin_lock_init(&rwnx_hw->cb_lock);
+	INIT_LIST_HEAD(&rwnx_hw->vifs);
+	INIT_LIST_HEAD(&rwnx_hw->defrag_list);
+	spin_lock_init(&rwnx_hw->defrag_lock);
+	mutex_init(&rwnx_hw->mutex);
+	mutex_init(&rwnx_hw->dbgdump_elem.mutex);
+	spin_lock_init(&rwnx_hw->tx_lock);
+	spin_lock_init(&rwnx_hw->cb_lock);
 
 	INIT_WORK(&rwnx_hw->apmStalossWork, apm_staloss_work_process);
 	rwnx_hw->apmStaloss_wq = create_singlethread_workqueue("apmStaloss_wq");
 	if (!rwnx_hw->apmStaloss_wq) {
-		txrx_err("insufficient memory to create apmStaloss workqueue.\n");
+		txrx_err(
+			"insufficient memory to create apmStaloss workqueue.\n");
 		goto err_cache;
 	}
 
-    wiphy->mgmt_stypes = rwnx_default_mgmt_stypes;
+	wiphy->mgmt_stypes = rwnx_default_mgmt_stypes;
 
 #ifdef CONFIG_FWLOG_EN
-    rwnx_hw->fwlog_en = true;
+	rwnx_hw->fwlog_en = true;
 #else
-    rwnx_hw->fwlog_en = false;
+	rwnx_hw->fwlog_en = false;
 #endif
+	rwnx_hw->scanning = false;
+	rwnx_hw->p2p_working = false;
 	//init ic system
-	if((ret = rwnx_ic_system_init(rwnx_hw))){
+	if ((ret = rwnx_ic_system_init(rwnx_hw))) {
 		goto err_lmac_reqs;
 	}
 
 #ifdef USE_5G
-	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
-	    ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, 0, rwnx_hw->fwlog_en, &set_start_cfm);
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	    rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW) {
+		ret = rwnx_send_set_stack_start_req(
+			rwnx_hw, 1, 0, 0, rwnx_hw->fwlog_en, &set_start_cfm);
 	} else {
-	    ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), rwnx_hw->fwlog_en, &set_start_cfm);
+		ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5),
+						    rwnx_hw->fwlog_en,
+						    &set_start_cfm);
 	}
 #else
-    if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
-        ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), rwnx_hw->fwlog_en, &set_start_cfm);
-    } else {
-	ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, get_hardware_info(), feature.hwinfo, rwnx_hw->fwlog_en, &set_start_cfm);
-    }
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+	    rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	    rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) {
+		ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5),
+						    rwnx_hw->fwlog_en,
+						    &set_start_cfm);
+	} else {
+		ret = rwnx_send_set_stack_start_req(
+			rwnx_hw, 1, get_hardware_info(), feature.hwinfo,
+			rwnx_hw->fwlog_en, &set_start_cfm);
+	}
 #endif
 
-    if (ret){
-        goto err_lmac_reqs;
-    }
+	if (ret) {
+		goto err_lmac_reqs;
+	}
 
-	AICWFDBG(LOGINFO, "is 5g support = %d, vendor_info = 0x%02X\n", set_start_cfm.is_5g_support, set_start_cfm.vendor_info);
+	AICWFDBG(LOGINFO, "is 5g support = %d, vendor_info = 0x%02X\n",
+		 set_start_cfm.is_5g_support, set_start_cfm.vendor_info);
 	rwnx_hw->band_5g_support = set_start_cfm.is_5g_support;
 
-        ret = rwnx_send_get_fw_version_req(rwnx_hw, &fw_version);
-        memcpy(wiphy->fw_version, fw_version.fw_version, fw_version.fw_version_len>32? 32 : fw_version.fw_version_len>32);
-    	AICWFDBG(LOGINFO, "Firmware Version: %s\r\n", fw_version.fw_version);
+	ret = rwnx_send_get_fw_version_req(rwnx_hw, &fw_version);
+	memcpy(wiphy->fw_version, fw_version.fw_version,
+	       fw_version.fw_version_len > 32 ? 32 :
+						fw_version.fw_version_len > 32);
+	AICWFDBG(LOGINFO, "Firmware Version: %s\r\n", fw_version.fw_version);
 
-    wiphy->bands[NL80211_BAND_2GHZ] = &rwnx_band_2GHz;
-//#ifdef USE_5G
-	if(rwnx_hw->band_5g_support){
-    	wiphy->bands[NL80211_BAND_5GHZ] = &rwnx_band_5GHz;
+	wiphy->bands[NL80211_BAND_2GHZ] = &rwnx_band_2GHz;
+	//#ifdef USE_5G
+	if (rwnx_hw->band_5g_support) {
+		wiphy->bands[NL80211_BAND_5GHZ] = &rwnx_band_5GHz;
 	}
-//#endif
-    wiphy->interface_modes =
-    BIT(NL80211_IFTYPE_STATION)     |
-    BIT(NL80211_IFTYPE_AP)          |
-    BIT(NL80211_IFTYPE_AP_VLAN)     |
-    BIT(NL80211_IFTYPE_P2P_CLIENT)  |
-    BIT(NL80211_IFTYPE_P2P_GO)      |
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
-    #ifndef CONFIG_USE_P2P0
-    BIT(NL80211_IFTYPE_P2P_DEVICE)  |
-    #endif
-    #endif
-    BIT(NL80211_IFTYPE_MONITOR);
+	//#endif
+	wiphy->interface_modes =
+		BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_AP_VLAN) | BIT(NL80211_IFTYPE_P2P_CLIENT) |
+		BIT(NL80211_IFTYPE_P2P_GO) |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+#ifndef CONFIG_USE_P2P0
+		BIT(NL80211_IFTYPE_P2P_DEVICE) |
+#endif
+#endif
+		BIT(NL80211_IFTYPE_MONITOR);
 
 #ifdef CONFIG_GPIO_WAKEUP
-		/* Set WoWLAN flags */
-		printk("%s Wowlan support\r\n", __func__);
+	/* Set WoWLAN flags */
+	printk("%s Wowlan support\r\n", __func__);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
-		wiphy->wowlan = &aic_wowlan_support;
+	wiphy->wowlan = &aic_wowlan_support;
 #else
-		wiphy->wowlan.flags = aic_wowlan_support.flags;
+	wiphy->wowlan.flags = aic_wowlan_support.flags;
 #endif
 #endif
 
-    wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
-        #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
-        WIPHY_FLAG_HAS_CHANNEL_SWITCH |
-        #endif
-        WIPHY_FLAG_4ADDR_STATION |
-        WIPHY_FLAG_4ADDR_AP;
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
+			WIPHY_FLAG_HAS_CHANNEL_SWITCH |
+#endif
+			WIPHY_FLAG_4ADDR_STATION | WIPHY_FLAG_4ADDR_AP;
 
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
-    wiphy->max_num_csa_counters = BCN_MAX_CSA_CPT;
-    #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+	wiphy->max_num_csa_counters = BCN_MAX_CSA_CPT;
+#endif
 
-    wiphy->max_remain_on_channel_duration = rwnx_hw->mod_params->roc_dur_max;
+	wiphy->max_remain_on_channel_duration =
+		rwnx_hw->mod_params->roc_dur_max;
 
-    wiphy->features |= NL80211_FEATURE_NEED_OBSS_SCAN |
-        NL80211_FEATURE_SK_TX_STATUS |
-        NL80211_FEATURE_VIF_TXPOWER |
-        #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
-        NL80211_FEATURE_ACTIVE_MONITOR |
-        #endif
-        #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
-        NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
-        #endif
-        0;
+	wiphy->features |= NL80211_FEATURE_NEED_OBSS_SCAN |
+			   NL80211_FEATURE_SK_TX_STATUS |
+			   NL80211_FEATURE_VIF_TXPOWER |
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+			   NL80211_FEATURE_ACTIVE_MONITOR |
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+			   NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
+#endif
+			   0;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
-    wiphy->features |= NL80211_FEATURE_SAE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || \
+	defined(CONFIG_WPA3_FOR_OLD_KERNEL)
+	wiphy->features |= NL80211_FEATURE_SAE;
 #endif
 
-    if (rwnx_mod_params.tdls)
-        /* TDLS support */
-        wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
+	if (rwnx_mod_params.tdls)
+		/* TDLS support */
+		wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
 
-    wiphy->iface_combinations   = rwnx_combinations;
-    /* -1 not to include combination with radar detection, will be re-added in
+	wiphy->iface_combinations = rwnx_combinations;
+	/* -1 not to include combination with radar detection, will be re-added in
        rwnx_handle_dynparams if supported */
-    wiphy->n_iface_combinations = ARRAY_SIZE(rwnx_combinations) - 1;
-    wiphy->reg_notifier = rwnx_reg_notifier;
+	wiphy->n_iface_combinations = ARRAY_SIZE(rwnx_combinations) - 1;
+	wiphy->reg_notifier = rwnx_reg_notifier;
 
-    wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 
-    rwnx_enable_wapi(rwnx_hw);
+	rwnx_enable_wapi(rwnx_hw);
 
-    wiphy->cipher_suites = cipher_suites;
-    wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites) - NB_RESERVED_CIPHER;
+	wiphy->cipher_suites = cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites) - NB_RESERVED_CIPHER;
 
-    rwnx_hw->ext_capa[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING;
-    rwnx_hw->ext_capa[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF;
+	rwnx_hw->ext_capa[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING;
+	rwnx_hw->ext_capa[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
-    wiphy->extended_capabilities = rwnx_hw->ext_capa;
-    wiphy->extended_capabilities_mask = rwnx_hw->ext_capa;
-    wiphy->extended_capabilities_len = ARRAY_SIZE(rwnx_hw->ext_capa);
+	wiphy->extended_capabilities = rwnx_hw->ext_capa;
+	wiphy->extended_capabilities_mask = rwnx_hw->ext_capa;
+	wiphy->extended_capabilities_len = ARRAY_SIZE(rwnx_hw->ext_capa);
 #endif
 #ifdef CONFIG_SCHED_SCAN
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
-    wiphy->max_sched_scan_reqs = 1;
+	wiphy->max_sched_scan_reqs = 1;
 #endif
-    wiphy->max_sched_scan_ssids = SCAN_SSID_MAX;//16;
-    wiphy->max_match_sets = SCAN_SSID_MAX;//16;
-    wiphy->max_sched_scan_ie_len = 2048;
-#endif//CONFIG_SCHED_SCAN
+	wiphy->max_sched_scan_ssids = SCAN_SSID_MAX; //16;
+	wiphy->max_match_sets = SCAN_SSID_MAX; //16;
+	wiphy->max_sched_scan_ie_len = 2048;
+#endif //CONFIG_SCHED_SCAN
 
-    tasklet_init(&rwnx_hw->task, rwnx_task, (unsigned long)rwnx_hw);
+	tasklet_init(&rwnx_hw->task, rwnx_task, (unsigned long)rwnx_hw);
 
 	//init ic rf
-	if((ret = rwnx_ic_rf_init(rwnx_hw))){
+	if ((ret = rwnx_ic_rf_init(rwnx_hw))) {
 		goto err_lmac_reqs;
 	}
 
-    if ((ret = rwnx_send_get_macaddr_req(rwnx_hw, (struct mm_get_mac_addr_cfm *)mac_addr_efuse)))
-        goto err_lmac_reqs;
-    if (mac_addr_efuse[0] | mac_addr_efuse[1] | mac_addr_efuse[2] | mac_addr_efuse[3])
-    {
-        memcpy(init_conf.mac_addr, mac_addr_efuse, ETH_ALEN);
-    }else{
-    	AICWFDBG(LOGERROR, "no mac address in efuse!");
+	if ((ret = rwnx_send_get_macaddr_req(
+		     rwnx_hw, (struct mm_get_mac_addr_cfm *)mac_addr_efuse)))
+		goto err_lmac_reqs;
+	if (mac_addr_efuse[0] | mac_addr_efuse[1] | mac_addr_efuse[2] |
+	    mac_addr_efuse[3]) {
+		memcpy(init_conf.mac_addr, mac_addr_efuse, ETH_ALEN);
+	} else {
+		AICWFDBG(LOGERROR, "no mac address in efuse!");
 	}
 
-	AICWFDBG(LOGINFO, "get macaddr:%x,%x\r\n", mac_addr_efuse[0], mac_addr_efuse[5]);
+	AICWFDBG(LOGINFO, "get macaddr:%x,%x\r\n", mac_addr_efuse[0],
+		 mac_addr_efuse[5]);
 
+	memcpy(wiphy->perm_addr, init_conf.mac_addr, ETH_ALEN);
 
-    memcpy(wiphy->perm_addr, init_conf.mac_addr, ETH_ALEN);
-
-    /* Reset FW */
-    if ((ret = rwnx_send_reset(rwnx_hw)))
-        goto err_lmac_reqs;
+	/* Reset FW */
+	if ((ret = rwnx_send_reset(rwnx_hw)))
+		goto err_lmac_reqs;
 
 #ifdef CONFIG_TEMP_COMP
 	rwnx_send_set_temp_comp_req(rwnx_hw, &swconfig_cfm);
 #endif
 
-    if ((ret = rwnx_send_version_req(rwnx_hw, &rwnx_hw->version_cfm)))
-        goto err_lmac_reqs;
-    rwnx_set_vers(rwnx_hw);
+	if ((ret = rwnx_send_version_req(rwnx_hw, &rwnx_hw->version_cfm)))
+		goto err_lmac_reqs;
+	rwnx_set_vers(rwnx_hw);
 
-    if ((ret = rwnx_handle_dynparams(rwnx_hw, rwnx_hw->wiphy)))
-        goto err_lmac_reqs;
+	if ((ret = rwnx_handle_dynparams(rwnx_hw, rwnx_hw->wiphy)))
+		goto err_lmac_reqs;
 
-    rwnx_enable_mesh(rwnx_hw);
-    rwnx_radar_detection_init(&rwnx_hw->radar);
+	rwnx_enable_mesh(rwnx_hw);
+	rwnx_radar_detection_init(&rwnx_hw->radar);
 
-    /* Set parameters to firmware */
+	/* Set parameters to firmware */
 
 	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
-		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)) {
-    	rwnx_send_me_config_req(rwnx_hw);
+	    ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	     testmode == 0)) {
+		rwnx_send_me_config_req(rwnx_hw);
 	}
 
-    /* Only monitor mode supported when custom channels are enabled */
-    if (rwnx_mod_params.custchan) {
-        rwnx_limits[0].types = BIT(NL80211_IFTYPE_MONITOR);
-        rwnx_limits_dfs[0].types = BIT(NL80211_IFTYPE_MONITOR);
-    }
+	/* Only monitor mode supported when custom channels are enabled */
+	if (rwnx_mod_params.custchan) {
+		rwnx_limits[0].types = BIT(NL80211_IFTYPE_MONITOR);
+		rwnx_limits_dfs[0].types = BIT(NL80211_IFTYPE_MONITOR);
+	}
 
-    aicwf_vendor_init(wiphy);
+	aicwf_vendor_init(wiphy);
 
-    if ((ret = wiphy_register(wiphy))) {
-        wiphy_err(wiphy, "Could not register wiphy device\n");
-        goto err_register_wiphy;
-    }
+	if ((ret = wiphy_register(wiphy))) {
+		wiphy_err(wiphy, "Could not register wiphy device\n");
+		goto err_register_wiphy;
+	}
 
-    /* Update regulatory (if needed) and set channel parameters to firmware
+	/* Update regulatory (if needed) and set channel parameters to firmware
        (must be done after WiPHY registration) */
-    rwnx_custregd(rwnx_hw, wiphy);
+	rwnx_custregd(rwnx_hw, wiphy);
 	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
-		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)) {
-    	rwnx_send_me_chan_config_req(rwnx_hw);
-		#ifdef CONFIG_COEX
-    	rwnx_send_coex_req(rwnx_hw, 0, 1);
-    	#endif
+	    ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	     testmode == 0)) {
+		rwnx_send_me_chan_config_req(rwnx_hw);
+#ifdef CONFIG_COEX
+		rwnx_send_coex_req(rwnx_hw, 0, 1);
+#endif
 	}
-    *platform_data = rwnx_hw;
+	*platform_data = rwnx_hw;
 
 #ifdef CONFIG_DEBUG_FS
-    if ((ret = rwnx_dbgfs_register(rwnx_hw, "rwnx"))) {
-        wiphy_err(wiphy, "Failed to register debugfs entries");
-        goto err_debugfs;
-    }
+	if ((ret = rwnx_dbgfs_register(rwnx_hw, "rwnx"))) {
+		wiphy_err(wiphy, "Failed to register debugfs entries");
+		goto err_debugfs;
+	}
 #endif
-    rtnl_lock();
+	rtnl_lock();
 
-    /* Add an initial station interface */
-    vif = rwnx_interface_add(rwnx_hw, "wlan%d", NET_NAME_UNKNOWN,
-                                NL80211_IFTYPE_STATION, NULL);
+	/* Add an initial station interface */
+	vif = rwnx_interface_add(rwnx_hw, "wlan%d", NET_NAME_UNKNOWN,
+				 NL80211_IFTYPE_STATION, NULL);
 
-    #ifdef CONFIG_RWNX_MON_DATA
-    /* Add an initial station interface */
-    vif = rwnx_interface_add(rwnx_hw, "wlan%d", 1,
-                                NL80211_IFTYPE_MONITOR, NULL);
-    #endif
+#ifdef CONFIG_RWNX_MON_DATA
+	/* Add an initial station interface */
+	vif = rwnx_interface_add(rwnx_hw, "wlan%d", 1, NL80211_IFTYPE_MONITOR,
+				 NULL);
+#endif
 
-    rtnl_unlock();
+	rtnl_unlock();
 
-    if (!vif) {
-        wiphy_err(wiphy, "Failed to instantiate a network device\n");
-        ret = -ENOMEM;
-        goto err_add_interface;
-    }
+	if (!vif) {
+		wiphy_err(wiphy, "Failed to instantiate a network device\n");
+		ret = -ENOMEM;
+		goto err_add_interface;
+	}
 
 #if 0
     wiphy_info(wiphy, "New interface create %s", vif->ndev->name);
@@ -9580,60 +7252,64 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 
 	AICWFDBG(LOGINFO, "New interface create %s\r\n", vif->ndev->name);
 
-#ifdef  CONFIG_USE_P2P0
-
-        rtnl_lock();
-        /* Add an initial p2p0 interface */
-        vif = rwnx_interface_add(rwnx_hw, "p2p%d", NET_NAME_UNKNOWN,
-                                    NL80211_IFTYPE_STATION, NULL);
-        vif->is_p2p_vif = 1;
-        rtnl_unlock();
+#ifdef CONFIG_USE_P2P0
 
-        if (!vif) {
-            wiphy_err(wiphy, "Failed to instantiate a network device\n");
-            ret = -ENOMEM;
-            goto err_add_interface;
-        }
+	rtnl_lock();
+	/* Add an initial p2p0 interface */
+	vif = rwnx_interface_add(rwnx_hw, "p2p%d", NET_NAME_UNKNOWN,
+				 NL80211_IFTYPE_STATION, NULL);
+	vif->is_p2p_vif = 1;
+	rtnl_unlock();
+
+	if (!vif) {
+		wiphy_err(wiphy, "Failed to instantiate a network device\n");
+		ret = -ENOMEM;
+		goto err_add_interface;
+	}
 
-        //wiphy_info(wiphy, "New interface create %s", vif->ndev->name);
-        AICWFDBG(LOGINFO, "New interface create %s \r\n", vif->ndev->name);
+	//wiphy_info(wiphy, "New interface create %s", vif->ndev->name);
+	AICWFDBG(LOGINFO, "New interface create %s \r\n", vif->ndev->name);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
-        init_timer(&rwnx_hw->p2p_alive_timer);
-        rwnx_hw->p2p_alive_timer.data = (unsigned long)vif;
-        rwnx_hw->p2p_alive_timer.function = aicwf_p2p_alive_timeout;
+	init_timer(&rwnx_hw->p2p_alive_timer);
+	rwnx_hw->p2p_alive_timer.data = (unsigned long)vif;
+	rwnx_hw->p2p_alive_timer.function = aicwf_p2p_alive_timeout;
 #else
-        timer_setup(&rwnx_hw->p2p_alive_timer, aicwf_p2p_alive_timeout, 0);
+	timer_setup(&rwnx_hw->p2p_alive_timer, aicwf_p2p_alive_timeout, 0);
 #endif
-        rwnx_hw->is_p2p_alive = 0;
-        rwnx_hw->is_p2p_connected = 0;
-        atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+	rwnx_hw->is_p2p_alive = 0;
+	rwnx_hw->is_p2p_connected = 0;
+	atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
+#ifdef CONFIG_FOR_IPCAM
+	aic_ipc_setting(vif);
 #endif
 
-    return 0;
+	return 0;
 
 err_add_interface:
 #ifdef CONFIG_DEBUG_FS
-    rwnx_dbgfs_unregister(rwnx_hw);
+	rwnx_dbgfs_unregister(rwnx_hw);
 err_debugfs:
 #endif
-if(rwnx_hw->wiphy){
-    wiphy_unregister(rwnx_hw->wiphy);
-}
+	if (rwnx_hw->wiphy) {
+		wiphy_unregister(rwnx_hw->wiphy);
+	}
 err_register_wiphy:
 err_lmac_reqs:
-    AICWFDBG(LOGERROR, "err_lmac_reqs\n");
-    flush_workqueue(rwnx_hw->apmStaloss_wq);
-    destroy_workqueue(rwnx_hw->apmStaloss_wq);
-    //rwnx_fw_trace_dump(rwnx_hw);
-    rwnx_platform_off(rwnx_hw, NULL);
-    kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+	AICWFDBG(LOGERROR, "err_lmac_reqs\n");
+	flush_workqueue(rwnx_hw->apmStaloss_wq);
+	destroy_workqueue(rwnx_hw->apmStaloss_wq);
+	//rwnx_fw_trace_dump(rwnx_hw);
+	rwnx_platform_off(rwnx_hw, NULL);
+	kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
 //err_platon:
 //err_config:
 err_cache:
-    wiphy_free(wiphy);
+	aicwf_wakeup_lock_deinit(rwnx_hw);
+	wiphy_free(wiphy);
 err_out:
-    return ret;
+	return ret;
 }
 
 /**
@@ -9642,46 +7318,63 @@ if(rwnx_hw->wiphy){
 
 void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
 {
-    struct mm_set_stack_start_cfm set_start_cfm;
+	struct mm_set_stack_start_cfm set_start_cfm;
+	struct defrag_ctrl_info *defrag_ctrl = NULL;
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	rwnx_send_set_stack_start_req(rwnx_hw, 0, 0, 0, 0, &set_start_cfm);
 
-    rwnx_send_set_stack_start_req(rwnx_hw, 0, 0, 0, 0, &set_start_cfm);
+	rwnx_hw->fwlog_en = 0;
+	rwnx_hw->scanning = 0;
+	rwnx_hw->p2p_working = 0;
 
-    rwnx_hw->fwlog_en = 0;
+	spin_lock_bh(&rwnx_hw->defrag_lock);
+	if (!list_empty(&rwnx_hw->defrag_list)) {
+		list_for_each_entry(defrag_ctrl, &rwnx_hw->defrag_list, list) {
+			list_del_init(&defrag_ctrl->list);
+			if (timer_pending(&defrag_ctrl->defrag_timer))
+				del_timer_sync(&defrag_ctrl->defrag_timer);
+			dev_kfree_skb(defrag_ctrl->skb);
+			kfree(defrag_ctrl);
+		}
+	}
+	spin_unlock_bh(&rwnx_hw->defrag_lock);
 
 #ifdef CONFIG_DEBUG_FS
-    rwnx_dbgfs_unregister(rwnx_hw);
+	rwnx_dbgfs_unregister(rwnx_hw);
 #endif
 	flush_workqueue(rwnx_hw->apmStaloss_wq);
 	destroy_workqueue(rwnx_hw->apmStaloss_wq);
 
-    rwnx_wdev_unregister(rwnx_hw);
-	if(rwnx_hw->wiphy){
+	rwnx_wdev_unregister(rwnx_hw);
+	if (rwnx_hw->wiphy) {
 		AICWFDBG(LOGINFO, "%s wiphy_unregister \r\n", __func__);
-    	wiphy_unregister(rwnx_hw->wiphy);
+		wiphy_unregister(rwnx_hw->wiphy);
 	}
-    rwnx_radar_detection_deinit(&rwnx_hw->radar);
-    rwnx_platform_off(rwnx_hw, NULL);
-    kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+	rwnx_radar_detection_deinit(&rwnx_hw->radar);
+	rwnx_platform_off(rwnx_hw, NULL);
+	kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
 #ifdef CONFIG_FILTER_TCP_ACK
-    tcp_ack_deinit(rwnx_hw);
+	tcp_ack_deinit(rwnx_hw);
 #endif
-	if(rwnx_hw->wiphy){
-    	wiphy_free(rwnx_hw->wiphy);
+	aicwf_wakeup_lock_deinit(rwnx_hw);
+
+	if (rwnx_hw->wiphy) {
+		wiphy_free(rwnx_hw->wiphy);
 	}
 }
 
 static void aicsmac_driver_register(void)
 {
 #ifdef AICWF_SDIO_SUPPORT
-    aicwf_sdio_register();
+	aicwf_sdio_register();
 #endif
 #ifdef AICWF_USB_SUPPORT
-    aicwf_usb_register();
+	aicwf_usb_register();
 #endif
 #ifdef AICWF_PCIE_SUPPORT
-    aicwf_pcie_register();
+	aicwf_pcie_register();
 #endif
 }
 
@@ -9689,7 +7382,7 @@ static void aicsmac_driver_register(void)
 
 struct completion hostif_register_done;
 
-#define REGISTRATION_TIMEOUT                     9000
+#define REGISTRATION_TIMEOUT 9000
 
 void aicwf_hostif_ready(void)
 {
@@ -9699,9 +7392,8 @@ void aicwf_hostif_ready(void)
 
 static int __init rwnx_mod_init(void)
 {
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-    rwnx_print_version();
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+	rwnx_print_version();
 	AICWFDBG(LOGINFO, "RELEASE DATE:%s \r\n", RELEASE_DATE);
 	rwnx_init_cmd_array();
 
@@ -9713,22 +7405,23 @@ static int __init rwnx_mod_init(void)
 	aicsmac_driver_register();
 
 #ifdef AICWF_SDIO_SUPPORT
-	if ((wait_for_completion_timeout(&hostif_register_done, msecs_to_jiffies(REGISTRATION_TIMEOUT)) == 0)) {
+	if ((wait_for_completion_timeout(
+		     &hostif_register_done,
+		     msecs_to_jiffies(REGISTRATION_TIMEOUT)) == 0)) {
 		AICWFDBG(LOGERROR, "register_driver timeout or error\n");
-        aicwf_sdio_exit();
-	return -ENODEV;
-}
+		aicwf_sdio_exit();
+		return -ENODEV;
+	}
 
 #endif /* AICWF_SDIO_SUPPORT */
 #ifdef AICWF_USB_SUPPORT
-       //aicwf_usb_exit();
+	//aicwf_usb_exit();
 #endif /*AICWF_USB_SUPPORT */
 
-
 #ifdef AICWF_PCIE_SUPPORT
-    return rwnx_platform_register_drv();
+	return rwnx_platform_register_drv();
 #else
-    return 0;
+	return 0;
 #endif
 }
 
@@ -9737,18 +7430,18 @@ static int __init rwnx_mod_init(void)
  */
 static void __exit rwnx_mod_exit(void)
 {
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 #ifdef AICWF_PCIE_SUPPORT
-    rwnx_platform_unregister_drv();
+	rwnx_platform_unregister_drv();
 #endif
 
 #ifdef AICWF_SDIO_SUPPORT
-    aicwf_sdio_exit();
+	aicwf_sdio_exit();
 #endif
 
 #ifdef AICWF_USB_SUPPORT
-    aicwf_usb_exit();
+	aicwf_usb_exit();
 #endif
 	rwnx_free_cmd_array();
 	AICWFDBG(LOGINFO, "%s exit\r\n", __func__);
@@ -9765,4 +7458,3 @@ MODULE_DESCRIPTION(RW_DRV_DESCRIPTION);
 MODULE_VERSION(RWNX_VERS_MOD);
 MODULE_AUTHOR(RW_DRV_COPYRIGHT " " RW_DRV_AUTHOR);
 MODULE_LICENSE("GPL");
-
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
index e5ad27875..7d06691dd 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
@@ -13,20 +13,6 @@
 
 #include "rwnx_defs.h"
 
-typedef struct _android_wifi_priv_cmd {
-    char *buf;
-    int used_len;
-    int total_len;
-} android_wifi_priv_cmd;
-
-#ifdef CONFIG_COMPAT
-typedef struct _compat_android_wifi_priv_cmd {
-    compat_caddr_t buf;
-    int used_len;
-    int total_len;
-} compat_android_wifi_priv_cmd;
-#endif /* CONFIG_COMPAT */
-
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data);
 void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw);
 extern int testmode;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index 8e1e7285f..f78ca5f6d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -18,7 +18,7 @@
 #include "rwnx_cfgfile.h"
 #include "rwnx_dini.h"
 #include "reg_access.h"
-#include "./rwnx_compat.h"
+#include "rwnx_compat.h"
 
 #ifdef CONFIG_RWNX_FULLMAC
 #define COMMON_PARAM(name, default_softmac, default_fullmac)    \
@@ -44,8 +44,8 @@ struct rwnx_mod_params rwnx_mod_params = {
     COMMON_PARAM(sgi, true, true)
     COMMON_PARAM(sgi80, true, true)
     COMMON_PARAM(use_2040, 1, 1)
-    COMMON_PARAM(nss, 1, 1)
-    COMMON_PARAM(amsdu_rx_max, 2, 2)
+    COMMON_PARAM(nss, 2, 2)
+    COMMON_PARAM(amsdu_rx_max, 1, 1)
     COMMON_PARAM(bfmee, true, true)
     COMMON_PARAM(bfmer, false, false)
     COMMON_PARAM(mesh, true, true)
@@ -363,9 +363,6 @@ struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy,
 			return reg_regdb[idx];
 		}
 		idx++;
-		if(idx == reg_regdb_size){
-			break;
-		}
 	}
 
 	AICWFDBG(LOGERROR, "%s(): Error, wrong country = %s\n",
@@ -721,6 +718,9 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         return;
     }
 
+    if(rwnx_hw->usbdev->chipid <= PRODUCT_ID_AIC8800D81)
+        nss = 1;
+
 	rwnx_hw->vht_cap_2G.vht_supported = true;
 		if (rwnx_hw->mod_params->sgi80)
 			rwnx_hw->vht_cap_2G.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;
@@ -736,9 +736,11 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 			rwnx_hw->vht_cap_2G.cap |= 3 << 13;
         #endif
 		}
-		if (nss > 1)
+		if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+		rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
 			rwnx_hw->vht_cap_2G.cap |= IEEE80211_VHT_CAP_TXSTBC;
-
+		}
 		// Update the AMSDU max RX size (not shifted as located at offset 0 of the VHT cap)
 		rwnx_hw->vht_cap_2G.cap |= rwnx_hw->mod_params->amsdu_rx_max;
 
@@ -785,7 +787,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+			//mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;
 		}
 		for (; i < 8; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -797,8 +799,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-							IEEE80211_VHT_MCS_SUPPORT_0_8);
+			//mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+			//				IEEE80211_VHT_MCS_SUPPORT_0_9);
 		}
 		for (; i < 8; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -831,8 +833,11 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	        rwnx_hw->vht_cap_5G.cap |= 3 << 13;
 	        #endif
 	    }
-	    if (nss > 1)
-	        rwnx_hw->vht_cap_5G.cap |= IEEE80211_VHT_CAP_TXSTBC;
+		if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+		rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+			rwnx_hw->vht_cap_5G.cap |= IEEE80211_VHT_CAP_TXSTBC;
+		}
 
 	    // Update the AMSDU max RX size (not shifted as located at offset 0 of the VHT cap)
 	    rwnx_hw->vht_cap_5G.cap |= rwnx_hw->mod_params->amsdu_rx_max;
@@ -880,7 +885,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+	        //mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;
 	    }
 	    for (; i < 8; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -892,8 +897,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-	                        IEEE80211_VHT_MCS_SUPPORT_0_8);
+	        //mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+	        //                IEEE80211_VHT_MCS_SUPPORT_0_9);
 	    }
 	    for (; i < 8; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -906,6 +911,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 #endif
 	        rwnx_hw->vht_cap_5G.cap &= ~IEEE80211_VHT_CAP_SHORT_GI_80;
 	    }
+
+		rwnx_hw->vht_cap_5G.cap |= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
 	}
 #endif
 	return;
@@ -926,6 +933,9 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         return;
     }
 
+    if(rwnx_hw->usbdev->chipid <= PRODUCT_ID_AIC8800D81)
+        nss = 1;
+
 	band_2GHz->vht_cap.vht_supported = true;
 		if (rwnx_hw->mod_params->sgi80)
 			band_2GHz->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;
@@ -941,9 +951,11 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 			band_2GHz->vht_cap.cap |= 3 << 13;
         #endif
 		}
-		if (nss > 1)
+		if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+		rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
 			band_2GHz->vht_cap.cap |= IEEE80211_VHT_CAP_TXSTBC;
-
+		}
 		// Update the AMSDU max RX size (not shifted as located at offset 0 of the VHT cap)
 		band_2GHz->vht_cap.cap |= rwnx_hw->mod_params->amsdu_rx_max;
 
@@ -990,7 +1002,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			band_2GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			band_2GHz->vht_cap.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+			//mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;
 		}
 		for (; i < 8; i++) {
 			band_2GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -1002,8 +1014,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			band_2GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			band_2GHz->vht_cap.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-							IEEE80211_VHT_MCS_SUPPORT_0_8);
+			//mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+			//				IEEE80211_VHT_MCS_SUPPORT_0_9);
 		}
 		for (; i < 8; i++) {
 			band_2GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -1035,8 +1047,12 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	        band_5GHz->vht_cap.cap |= 3 << 13;
 	        #endif
 	    }
-	    if (nss > 1)
-	        band_5GHz->vht_cap.cap |= IEEE80211_VHT_CAP_TXSTBC;
+
+		if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+		rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+			band_5GHz->vht_cap.cap |= IEEE80211_VHT_CAP_TXSTBC;
+		}
 
 	    // Update the AMSDU max RX size (not shifted as located at offset 0 of the VHT cap)
 	    band_5GHz->vht_cap.cap |= rwnx_hw->mod_params->amsdu_rx_max;
@@ -1084,7 +1100,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        band_5GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        band_5GHz->vht_cap.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+	        //mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;
 	    }
 	    for (; i < 8; i++) {
 	        band_5GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -1096,8 +1112,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        band_5GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        band_5GHz->vht_cap.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-	                        IEEE80211_VHT_MCS_SUPPORT_0_8);
+	        //mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+	        //                IEEE80211_VHT_MCS_SUPPORT_0_9);
 	    }
 	    for (; i < 8; i++) {
 	        band_5GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -1134,6 +1150,9 @@ static void rwnx_set_ht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         return;
     }
 
+    if(rwnx_hw->usbdev->chipid <= PRODUCT_ID_AIC8800D81)
+        nss = 1;
+
     if (rwnx_hw->mod_params->stbc_on)
         band_2GHz->ht_cap.cap |= 1 << IEEE80211_HT_CAP_RX_STBC_SHIFT;
     if (rwnx_hw->mod_params->ldpc_on)
@@ -1145,8 +1164,12 @@ static void rwnx_set_ht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     } else {
         band_2GHz->ht_cap.mcs.rx_highest = cpu_to_le16(65 * nss);
     }
-    if (nss > 1)
-        band_2GHz->ht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;
+
+	if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+		band_2GHz->ht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;
+	}
 
     // Update the AMSDU max RX size
     if (rwnx_hw->mod_params->amsdu_rx_max)
@@ -1185,6 +1208,9 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     int nss = rwnx_hw->mod_params->nss;
     int mcs_map;
 
+    if(rwnx_hw->usbdev->chipid <= PRODUCT_ID_AIC8800D81)
+        nss = 1;
+
     he_cap = (struct ieee80211_sta_he_cap *) &rwnx_he_capa.he_cap;
     he_cap->has_he = true;
     he_cap->he_cap_elem.mac_cap_info[2] |= IEEE80211_HE_MAC_CAP2_ALL_ACK;
@@ -1196,8 +1222,14 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     if (rwnx_hw->mod_params->use_80) {
         he_cap->ppe_thres[0] |= 0x20;
         he_cap->ppe_thres[2] |= 0xc0;
-        he_cap->ppe_thres[3] |= 0x07;
+        he_cap->ppe_thres[3] |= 0x01;
     }
+	if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
+	}
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1225,6 +1257,13 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     #endif
     if (rwnx_hw->mod_params->stbc_on)
         he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ;
+
+	if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+		he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ;
+	}
+
 	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 13, 0)
     he_cap->he_cap_elem.phy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
                                            IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1 |
@@ -1268,7 +1307,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
         he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
         he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-        mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+        //mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
         }
     for (; i < 8; i++) {
         __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1282,8 +1321,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
         he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
         he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-        mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-                        IEEE80211_HE_MCS_SUPPORT_0_7);
+        //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+        //                IEEE80211_HE_MCS_SUPPORT_0_7);
     }
     for (; i < 8; i++) {
         __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1315,6 +1354,10 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         //#endif
         return;
     }
+
+    if(rwnx_hw->usbdev->chipid <= PRODUCT_ID_AIC8800D81)
+        nss = 1;
+
     he_cap = (struct ieee80211_sta_he_cap *) &band_2GHz->iftype_data->he_cap;
     he_cap->has_he = true;
     he_cap->he_cap_elem.mac_cap_info[2] |= IEEE80211_HE_MAC_CAP2_ALL_ACK;
@@ -1326,8 +1369,14 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     if (rwnx_hw->mod_params->use_80) {
         he_cap->ppe_thres[0] |= 0x20;
         he_cap->ppe_thres[2] |= 0xc0;
-        he_cap->ppe_thres[3] |= 0x07;
+        he_cap->ppe_thres[3] |= 0x01;
     }
+	if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
+	}
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1355,6 +1404,13 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     #endif
     if (rwnx_hw->mod_params->stbc_on)
         he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ;
+
+    if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+	rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+	rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+		he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ;
+	}
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 13, 0)
     he_cap->he_cap_elem.phy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
                                            IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1 |
@@ -1392,7 +1448,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
                                            IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
     #endif
-    mcs_map = rwnx_hw->mod_params->he_mcs_map;
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+        mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
+	else
+		mcs_map = rwnx_hw->mod_params->he_mcs_map;
     //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
     memset(&he_cap->he_mcs_nss_supp, 0, sizeof(he_cap->he_mcs_nss_supp));
     for (i = 0; i < nss; i++) {
@@ -1400,7 +1460,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
         he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
         he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-        mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+        //mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
         }
     for (; i < 8; i++) {
         __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1414,8 +1474,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
         he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
         he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-        mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-                        IEEE80211_HE_MCS_SUPPORT_0_7);
+        //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+        //                IEEE80211_HE_MCS_SUPPORT_0_7);
     }
     for (; i < 8; i++) {
         __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1437,8 +1497,14 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    if (rwnx_hw->mod_params->use_80) {
 		he_cap->ppe_thres[0] |= 0x20;
 		he_cap->ppe_thres[2] |= 0xc0;
-		he_cap->ppe_thres[3] |= 0x07;
+		he_cap->ppe_thres[3] |= 0x01;
 	    }
+		if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
+		}
 	    //if (rwnx_hw->mod_params->use_80)
 	    {
 	        he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1465,6 +1531,13 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    #endif
 	    if (rwnx_hw->mod_params->stbc_on)
 	        he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ;
+
+	    if((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) &&
+		rwnx_hw->mod_params->stbc_on == true){ //if (nss > 1)
+			he_cap->he_cap_elem.phy_cap_info[2] |= IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ;
+		}
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 13, 0)
 	    he_cap->he_cap_elem.phy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM |
 	                                           IEEE80211_HE_PHY_CAP3_DCM_MAX_RX_NSS_1 |
@@ -1502,7 +1575,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 	                                           IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 	    #endif
-	    mcs_map = rwnx_hw->mod_params->he_mcs_map;
+		if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+			mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
+		else
+			mcs_map = rwnx_hw->mod_params->he_mcs_map;
 	    //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
 	    memset(&he_cap->he_mcs_nss_supp, 0, sizeof(he_cap->he_mcs_nss_supp));
 	    for (i = 0; i < nss; i++) {
@@ -1510,7 +1587,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	        he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 	        he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
 	        he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-	        mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+	        //mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
 	    }
 	    for (; i < 8; i++) {
 	        __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1524,8 +1601,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	        he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 	        he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
 	        he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-	        mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-	                        IEEE80211_HE_MCS_SUPPORT_0_7);
+	        //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+	        //                IEEE80211_HE_MCS_SUPPORT_0_7);
 	    }
 	    for (; i < 8; i++) {
 	        __le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1698,21 +1775,33 @@ int rwnx_handle_dynparams(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 #endif
 
     //check he_mcs max
-    if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 && 
+    if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->he_mcs_map > IEEE80211_HE_MCS_SUPPORT_0_9){
         rwnx_hw->mod_params->he_mcs_map = IEEE80211_HE_MCS_SUPPORT_0_9;
+    } else {
+	rwnx_hw->mod_params->he_mcs_map = IEEE80211_HE_MCS_SUPPORT_0_11;
     }
 
     //check use_80 support
     if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->use_80 == true){
         rwnx_hw->mod_params->use_80 = false;
+    } else {
+	rwnx_hw->mod_params->use_80 = true;
     }
 
     //check sgi80 support
     if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->sgi80 == true){
         rwnx_hw->mod_params->sgi80 = false;
+    } else {
+	rwnx_hw->mod_params->sgi80 = true;
     }
 #ifdef CONFIG_5M10M
     rwnx_hw->mod_params->he_mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
@@ -1744,11 +1833,7 @@ void rwnx_custregd(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 // registration (in rwnx_set_wiphy_params()), so nothing has to be done here
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-    // nop
-#else
     wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
-#endif
     wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
 
     if (!rwnx_hw->mod_params->custregd)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 0bd3e4932..e640fd068 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -116,25 +116,28 @@ static inline int rwnx_rx_chan_switch_ind(struct rwnx_hw *rwnx_hw,
     } else {
         /* Retrieve the allocated RoC element */
         struct rwnx_roc_elem *roc_elem = rwnx_hw->roc_elem;
+        if (roc_elem) {
+            /* If mgmt_roc is true, remain on channel has been started by ourself */
+            if (!roc_elem->mgmt_roc) {
+                /* Inform the host that we have switch on the indicated off-channel */
+                #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
+                cfg80211_ready_on_channel(roc_elem->wdev->netdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
+                #elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+                cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
+                #else
+                cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, roc_elem->duration, GFP_ATOMIC);
+                #endif
+            }
 
-        /* If mgmt_roc is true, remain on channel has been started by ourself */
-        if (!roc_elem->mgmt_roc) {
-            /* Inform the host that we have switch on the indicated off-channel */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-	    cfg80211_ready_on_channel(roc_elem->wdev->netdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
-	    cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
-#else
-            cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, roc_elem->duration, GFP_ATOMIC);
-#endif
+            /* Keep in mind that we have switched on the channel */
+            roc_elem->on_chan = true;
+        } else {
+            printk("roc_elem == null\n");
         }
 
-        /* Keep in mind that we have switched on the channel */
-        roc_elem->on_chan = true;
-
         // Enable traffic on OFF channel queue
         rwnx_txq_offchan_start(rwnx_hw);
     }
@@ -603,7 +606,6 @@ static inline int rwnx_rx_scan_done_ind(struct rwnx_hw *rwnx_hw,
  * Messages from SCANU task
  **************************************************************************/
 #ifdef CONFIG_RWNX_FULLMAC
-extern uint8_t scanning;
 static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
                                           struct rwnx_cmd *cmd,
                                           struct ipc_e2a_msg *msg)
@@ -666,7 +668,7 @@ static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
 #endif//CONFIG_SCHED_SCAN
 
     rwnx_hw->scan_request = NULL;
-    scanning = 0;
+    rwnx_hw->scanning = 0;
 
     return 0;
 }
@@ -679,6 +681,11 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
     struct ieee80211_channel *chan;
     struct scanu_result_ind *ind = (struct scanu_result_ind *)msg->param;
     struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)ind->payload;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+	u16 capability, beacon_interval;
+	u16 len = ind->length;
 
 #if 0    
 	const u8 *ie = mgmt->u.beacon.variable;
@@ -697,20 +704,34 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
     chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
 
     if (chan != NULL) {
-        #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
-        //ktime_t ts;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
         struct timespec ts;
-		get_monotonic_boottime(&ts);
-        //ts = ktime_get_real();
+        get_monotonic_boottime(&ts);
+        tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
         mgmt->u.probe_resp.timestamp = ((u64)ts.tv_sec*1000000) + ts.tv_nsec/1000;
-        #else
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
+        struct timespec ts;
+        ts = ktime_to_timespec(ktime_get_boottime());
+        tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
+        mgmt->u.probe_resp.timestamp = tsf;
+#else
         struct timespec64 ts;
-        ktime_get_real_ts64(&ts);
-        mgmt->u.probe_resp.timestamp = ((u64)ts.tv_sec*1000000) + ts.tv_nsec/1000;
-        #endif
-        bss = cfg80211_inform_bss_frame(rwnx_hw->wiphy, chan,
-                                        (struct ieee80211_mgmt *)ind->payload,
-                                        ind->length, ind->rssi * 100, GFP_ATOMIC);
+        ts = ktime_to_timespec64(ktime_get_boottime());
+        tsf = (u64)ts.tv_sec * 1000000 + div_u64(ts.tv_nsec, 1000);
+        mgmt->u.probe_resp.timestamp = tsf;
+#endif
+        ie = mgmt->u.probe_resp.variable;
+        ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+        beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+        capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+        /* framework use system bootup time */
+        bss = cfg80211_inform_bss(rwnx_hw->wiphy, chan,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+            CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+            mgmt->bssid, tsf, capability, beacon_interval,
+            ie, ielen, ind->rssi * 100, GFP_ATOMIC);
+
 #if 0
         //print scan result info start
         if(ie != NULL && bss != NULL){
@@ -735,7 +756,12 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
 
 #ifdef CONFIG_USE_WIRELESS_EXT
 		if(rwnx_hw->wext_scan){
-			
+			list_for_each_entry(scan_re_wext, &rwnx_hw->wext_scanre_list, scanu_re_list) {
+				if (!memcmp(scan_re_wext->bss->bssid, bss->bssid, ETH_ALEN)) {
+					AICWFDBG(LOGDEBUG, "%s: BSSID already exists, no need to add again\r\n", __func__);
+					goto putbss;
+				}
+			}
 			scan_re_wext = (struct scanu_result_wext *)vmalloc(sizeof(struct scanu_result_wext));
 			scan_re_wext->ind = (struct scanu_result_ind *)vmalloc(sizeof(struct scanu_result_ind));
 			scan_re_wext->payload = (u32_l *)vmalloc(sizeof(u32_l) * ind->length);
@@ -755,7 +781,7 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
 #endif
 
     }
-
+putbss:
     if (bss != NULL)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
 	cfg80211_put_bss(bss);
@@ -838,6 +864,7 @@ static inline void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,
         }
 }
 #endif
+
 static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
                                          struct rwnx_cmd *cmd,
                                          struct ipc_e2a_msg *msg)
@@ -849,9 +876,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     const u8 *extcap_ie;
     const struct ieee_types_extcap *extcap;
     struct ieee80211_channel *chan;
-	struct cfg80211_bss *bss = NULL;
+	//struct cfg80211_bss *bss = NULL;
     struct wireless_dev *wdev = NULL;
-    int retry_counter = 10;
+    //int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 	
@@ -975,9 +1002,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
             rwnx_vif->wep_auth_err = true;
             AICWFDBG(LOGINFO, "con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
         }
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
     }else{
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}
 
 
@@ -987,72 +1014,11 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
         ind->status_code,
         (int)atomic_read(&rwnx_vif->drv_conn_state));
 
-	do {
-		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-							wdev->u.client.ssid, wdev->u.client.ssid_len,
-#else
-							wdev->ssid, wdev->ssid_len,
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-							wdev->conn_bss_type,
-							IEEE80211_PRIVACY_ANY);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-							IEEE80211_BSS_TYPE_ESS,
-							IEEE80211_PRIVACY_ANY);
-#else
-                            WLAN_CAPABILITY_ESS,
-                            WLAN_CAPABILITY_PRIVACY);
-#endif
-
-
-		if (!bss) {
-			printk("%s bss is NULL \r\n", __func__);
-
-			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n", 
-				__func__, 
-				(int)rwnx_vif->sta.ssid_len,
-				rwnx_vif->sta.ssid,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-				IEEE80211_BSS_TYPE_ESS,
-#else
-				WLAN_CAPABILITY_ESS,
-#endif
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-				(int)wdev->u.client.ssid_len,
-				wdev->u.client.ssid, 
-#else
-				(int)wdev->ssid_len,
-				wdev->ssid,
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-				wdev->conn_bss_type
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-				IEEE80211_BSS_TYPE_ESS
-#else
-				WLAN_CAPABILITY_ESS
-#endif
-				);
-
-			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__, 
-				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
-				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
+    if(ind->status_code == 0 && (int)atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING){
+        AICWFDBG(LOGINFO, "%s the disconnection has been requested, return it\r\n", __func__);
+        goto exit;
+    }
 
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
-#else
-			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
-#endif
-			msleep(100);
-			retry_counter--;
-			if(retry_counter == 0){
-				printk("%s bss recover fail \r\n", __func__);
-				break;
-			}
-		}
-	} while (!bss);
 
     if (!ind->roamed) {//not roaming
         cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
@@ -1060,9 +1026,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
                                 ind->assoc_rsp_ie_len, ind->status_code,
                                 GFP_ATOMIC);
 		if (ind->status_code == 0) {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 		} else {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
 		}
 		AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", __func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
@@ -1071,7 +1037,7 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
         if(ind->status_code != 0){
             AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
 			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
         }else{
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
@@ -1095,7 +1061,6 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
             info.resp_ie_len = ind->assoc_rsp_ie_len;
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
             cfg80211_roamed(dev, &info, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
             chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
@@ -1110,12 +1075,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
                 , ind->assoc_rsp_ie_len
                 , GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 		}
+        rwnx_vif->sta.is_roam = false;
     }
-    netif_tx_start_all_queues(dev);
-    netif_carrier_on(dev);
 
+	if (ind->status_code == 0) {
+	    netif_tx_start_all_queues(dev);
+	    netif_carrier_on(dev);
+	}
+    
+exit:
+    rwnx_vif->sta.is_roam = false;
     return 0;
 }
 
@@ -1163,7 +1134,8 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     struct aicwf_rx_priv *rx_priv;
 #endif
 
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
+    //RWNX_DBG(RWNX_FN_ENTRY_STR);
+    AICWFDBG(LOGINFO, "%s reason code:%d \r\n", __func__, ind->reason_code);
 	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED){
 		AICWFDBG(LOGINFO, "%s, is already disconnected, drop disconnect ind", __func__);
 		return 0;
@@ -1183,6 +1155,10 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 		AICWFDBG(LOGINFO, "%s roaming no rwnx_cfg80211_unlink_bss \r\n", __func__);
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	rwnx_dbgfs_unregister_rc_stat(rwnx_hw, rwnx_vif->sta.ap);
+#endif
+
 #ifdef CONFIG_BR_SUPPORT
 	struct rwnx_vif *vif = netdev_priv(dev);
         /* clear bridge database */
@@ -1241,7 +1217,10 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     rwnx_chanctx_unlink(rwnx_vif);
 
 	//msleep(200);
-	atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+    if (rwnx_vif->sta.is_roam == false) {
+	    rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+    }
+
     return 0;
 }
 
@@ -1278,13 +1257,6 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 	}
 	AICWFDBG(LOGINFO, "%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
 
-	if (wdev->conn_owner_nlportid != 0) {
-		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
-	} else {
-		AICWFDBG(LOGINFO, "%s try to recover conn_owner_nlportid\r\n", __func__);
-		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
-	}
-
     if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
         (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
         (ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 389a60629..df6920ccf 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -67,7 +67,7 @@ const int chnl2bw[] = {
     [PHY_CHNL_BW_80P80]   = NL80211_CHAN_WIDTH_80P80,
 };
 
-#define RWNX_CMD_ARRAY_SIZE 20
+#define RWNX_CMD_ARRAY_SIZE 40
 #define RWNX_CMD_HIGH_WATER_SIZE RWNX_CMD_ARRAY_SIZE/2
 //#define RWNX_MSG_ARRAY_SIZE 20
 
@@ -386,7 +386,6 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
     struct rwnx_cmd *cmd;
     bool nonblock;
     int ret = 0;
-    u8_l empty = 0;
 
     //RWNX_DBG(RWNX_FN_ENTRY_STR);
     AICWFDBG(LOGDEBUG, "%s (%d)%s reqcfm:%d in_softirq:%d in_atomic:%d\r\n",
@@ -444,7 +443,7 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
         cmd->flags = RWNX_CMD_FLAG_NONBLOCK;
     if (reqcfm)
         cmd->flags |= RWNX_CMD_FLAG_REQ_CFM;
-
+#if 0
     if(cfm != NULL) {
         do {
             if(rwnx_hw->cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED)
@@ -468,7 +467,7 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
              }
 	} while(!empty);//wait for cmd queue empty
     }
-
+#endif
     if(reqcfm) {
         cmd->flags &= ~RWNX_CMD_FLAG_WAIT_ACK; // we don't need ack any more
         ret = rwnx_hw->cmd_mgr->queue(rwnx_hw->cmd_mgr, cmd);
@@ -1065,6 +1064,31 @@ int rwnx_send_arpoffload_en_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_v
 }
 #endif
 
+int rwnx_send_disable_agg_req(struct rwnx_hw *rwnx_hw, u8_l agg_disable, u8_l agg_disable_rx, u8_l sta_idx)
+{
+    struct mm_set_agg_disable_req *req;
+    int error;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_AGG_DISABLE_REQ message */
+    req = rwnx_msg_zalloc(MM_SET_AGG_DISABLE_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_agg_disable_req));
+
+    if (!req) {
+        return -ENOMEM;
+    }
+
+    req->disable = agg_disable;
+    req->staidx = sta_idx;
+    req->disable_rx = agg_disable_rx;
+
+    /* Send the MM_SET_AGG_DISABLE_REQ message to UMAC FW */
+    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_AGG_DISABLE_CFM, NULL);
+
+    return (error);
+};
+
 int rwnx_send_coex_req(struct rwnx_hw *rwnx_hw, u8_l disable_coexnull, u8_l enable_nullcts)
 {
     struct mm_set_coex_req *coex_req;
@@ -1114,7 +1138,7 @@ int rwnx_send_rf_config_req(struct rwnx_hw *rwnx_hw, u8_l ofst, u8_l sel, u8_l *
     rf_config_req->table_num = 16;
     rf_config_req->deft_page = 0;
 
-	memcpy(rf_config_req->data, tbl, len);
+    memcpy(rf_config_req->data, tbl, len);
 
     /* Send the MM_SET_RF_CONFIG_REQ message to UMAC FW */
     error = rwnx_send_msg(rwnx_hw, rf_config_req, 1, MM_SET_RF_CONFIG_CFM, NULL);
@@ -1127,7 +1151,7 @@ extern void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap);
 int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm)
 {
     struct mm_set_rf_calib_req *rf_calib_req;
-	xtal_cap_conf_t xtal_cap = {0,};
+    xtal_cap_conf_t xtal_cap = {0,};
     int error;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
@@ -1142,30 +1166,34 @@ int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *
 
     if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
         rf_calib_req->cal_cfg_24g = 0xbf;
-	rf_calib_req->cal_cfg_5g = 0x3f;
+        rf_calib_req->cal_cfg_5g = 0x3f;
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
-	rf_calib_req->cal_cfg_24g = 0x0f8f;
-	rf_calib_req->cal_cfg_5g = 0;
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0;
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
-	rf_calib_req->cal_cfg_24g = 0x0f8f;
-	rf_calib_req->cal_cfg_5g = 0x0f0f;
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0x0f0f;
+    }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0x0f0f;
     }
 
     rf_calib_req->param_alpha = 0x0c34c008;
     rf_calib_req->bt_calib_en = 0;
     rf_calib_req->bt_calib_param = 0x264203;
 
-	get_userconfig_xtal_cap(&xtal_cap);
+    get_userconfig_xtal_cap(&xtal_cap);
 
-	if (xtal_cap.enable) {
-		AICWFDBG(LOGINFO, "user xtal cap: %d, cap_fine: %d\n", xtal_cap.xtal_cap, xtal_cap.xtal_cap_fine);
-		rf_calib_req->xtal_cap = xtal_cap.xtal_cap;
-		rf_calib_req->xtal_cap_fine = xtal_cap.xtal_cap_fine;
-	} else {
-		rf_calib_req->xtal_cap = 0;
-		rf_calib_req->xtal_cap_fine = 0;
-	}
+    if (xtal_cap.enable) {
+        AICWFDBG(LOGINFO, "user xtal cap: %d, cap_fine: %d\n", xtal_cap.xtal_cap, xtal_cap.xtal_cap_fine);
+        rf_calib_req->xtal_cap = xtal_cap.xtal_cap;
+        rf_calib_req->xtal_cap_fine = xtal_cap.xtal_cap_fine;
+    } else {
+        rf_calib_req->xtal_cap = 0;
+        rf_calib_req->xtal_cap_fine = 0;
+    }
 
     /* Send the MM_SET_RF_CALIB_REQ message to UMAC FW */
     error = rwnx_send_msg(rwnx_hw, rf_calib_req, 1, MM_SET_RF_CALIB_CFM, cfm);
@@ -1299,8 +1327,10 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 	struct mm_set_mac_timescale_req *req2;
 	struct mm_set_cca_threshold_req *req3;
 	struct mm_set_bwmode_req *req4;
+	struct mm_set_customized_freq_req *req5;
 
 	int error = 0;
+	int i;
 
 	switch (hwconfig_id)
 	{
@@ -1339,8 +1369,9 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		req1->rc_retry_cnt[1] = param[10];
 		req1->rc_retry_cnt[2] = param[11];
 		req1->ccademod_th = param[12];
-		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d\n",
-			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th);
+		req1->remove_1m2m = param[13];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d remove_1m2m = %d\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th, req1->remove_1m2m);
 		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
@@ -1391,27 +1422,42 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
         case CHIP_TEMP_GET_REQ:
-        if ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-            (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW))
-        {
-            struct mm_get_chip_temp_req *req;
-            struct mm_set_vendor_hwconfig_cfm cfm = {0,};
-            /* Build the CHIP_TEMP_GET_REQ message */
-            req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
-            if (!req)
-                return -ENOMEM;
-            req->hwconfig_id = hwconfig_id;
-            /* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
-            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
-            if (!error) {
-                if (param_out) {
-                    param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
-                }
-                printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
-            } else {
-                printk("get_chip_temp err=%d\n", error);
-            }
-        }
+		if ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+		(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW))
+		{
+		struct mm_get_chip_temp_req *req;
+		struct mm_set_vendor_hwconfig_cfm cfm = {0,};
+		/* Build the CHIP_TEMP_GET_REQ message */
+		req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
+		if (!req)
+			return -ENOMEM;
+		req->hwconfig_id = hwconfig_id;
+		/* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
+		if (!error) {
+			if (param_out) {
+				param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
+			}
+			printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
+		} else {
+			printk("get_chip_temp err=%d\n", error);
+			}
+		}
+	case CUSTOMIZED_FREQ_REQ:
+		/* Build the CUSTOMIZED_FREQ_REQ message */
+		req5 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_customized_freq_req));
+		if (!req5)
+		    return -ENOMEM;
+		req5->hwconfig_id = hwconfig_id;
+		for (i = 0; i < 4; i++) {
+		    req5->raw_freq[i] = param [i];
+		    req5->map_freq[i] = param [i + 4];
+		}
+		printk("customized_freq_req: raw_freq[ %d %d %d %d ], map_freq[ %d %d %d %d]\n",
+			param[0], param[1], param[2], param[3], param[4], param[5], param[6], param[7]);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req5, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+
         break;
 	    default:
 		return -ENOMEM;
@@ -1471,6 +1517,44 @@ int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id,
             }
             break;
 
+        case EXT_FLAGS_SET_REQ:
+            /* Build the EXT_FLAGS_SET_REQ message */
+            req->ext_flags_set_req.user_flags = (u32_l)param_in[0];
+            printk("ext_flags_set_req: flags=%x\n",
+                req->ext_flags_set_req.user_flags);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_set_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_set_cfm.user_flags);
+            }
+            break;
+
+        case EXT_FLAGS_GET_REQ:
+            /* Build the EXT_FLAGS_GET_REQ message */
+            printk("ext_flags_get_req\n");
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_get_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_get_cfm.user_flags);
+            }
+            break;
+
+        case EXT_FLAGS_MASK_SET_REQ:
+            /* Build the EXT_FLAGS_MASK_SET_REQ message */
+            req->ext_flags_mask_set_req.user_flags_mask = (u32_l)param_in[0];
+            req->ext_flags_mask_set_req.user_flags_val = (u32_l)param_in[1];
+            printk("ext_flags_mask_set_req: flags mask=0x%x, val=0x%x\n",
+                req->ext_flags_mask_set_req.user_flags_mask, req->ext_flags_mask_set_req.user_flags_val);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_mask_set_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_mask_set_cfm.user_flags);
+            }
+            break;
+
         default:
             error = -ENOMEM;
             break;
@@ -1479,6 +1563,32 @@ int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id,
     return error;
 }
 
+int rwnx_send_mask_set_ext_flags_req(struct rwnx_hw *rwnx_hw, uint32_t flags_mask, uint32_t flags_val, struct mm_set_vendor_swconfig_cfm *cfm)
+{
+    struct mm_set_vendor_swconfig_req *req;
+    int ret;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+    /* Build the REQ message */
+    req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+    if (!req) {
+        AICWFDBG(LOGERROR, "%s msg_alloc fail\n", __func__);
+        return -ENOMEM;
+    }
+    req->swconfig_id = EXT_FLAGS_MASK_SET_REQ;
+    req->ext_flags_mask_set_req.user_flags_mask = (u32_l)flags_mask;
+    req->ext_flags_mask_set_req.user_flags_val = (u32_l)flags_val;
+
+    ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+    if (!ret) {
+        AICWFDBG(LOGINFO, "curr ext_flags=%x\n", cfm->ext_flags_mask_set_cfm.user_flags);
+    } else {
+        AICWFDBG(LOGERROR, "%s send_msg_fail\n", __func__);
+        return ret;
+    }
+    return ret;
+}
+
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm)
 {
     void *req;
@@ -1569,7 +1679,7 @@ int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw)
 
     txpwr_lvl_v2 = &txpwr_lvl_v2_tmp;
     txpwr_loss = &txpwr_loss_tmp;
-    txpwr_loss->loss_enable = 0;
+    txpwr_loss->loss_enable_2g4 = 0;
 
     get_userconfig_txpwr_lvl_v2_in_fdrv(txpwr_lvl_v2);
     get_userconfig_txpwr_loss(txpwr_loss);
@@ -1613,16 +1723,18 @@ int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw)
         AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_2g4:%d\r\n",   __func__, txpwr_lvl_v2->pwrlvl_11ax_2g4[10]);
         AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_2g4:%d\r\n",   __func__, txpwr_lvl_v2->pwrlvl_11ax_2g4[11]);
 
-    if (txpwr_loss->loss_enable == 1) {
-        AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n", __func__, txpwr_loss->loss_value);
+		if (txpwr_loss->loss_enable_2g4 == 1) {
+			AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+				 txpwr_loss->loss_value_2g4);
+
+			for (i = 0; i <= 11; i++)
+				txpwr_lvl_v2->pwrlvl_11b_11ag_2g4[i] -= txpwr_loss->loss_value_2g4;
+			for (i = 0; i <= 9; i++)
+				txpwr_lvl_v2->pwrlvl_11n_11ac_2g4[i] -= txpwr_loss->loss_value_2g4;
+			for (i = 0; i <= 11; i++)
+				txpwr_lvl_v2->pwrlvl_11ax_2g4[i] -= txpwr_loss->loss_value_2g4;
+		}
 
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v2->pwrlvl_11b_11ag_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 9; i++)
-            txpwr_lvl_v2->pwrlvl_11n_11ac_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v2->pwrlvl_11ax_2g4[i] += txpwr_loss->loss_value;
-    }
         if ((testmode == 0) && (chip_sub_id == 0)) {
             txpwr_lvl_req->txpwr_lvl.enable         = txpwr_lvl_v2->enable;
             txpwr_lvl_req->txpwr_lvl.dsss           = txpwr_lvl_v2->pwrlvl_11b_11ag_2g4[3]; // 11M
@@ -1665,30 +1777,38 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
         return -ENOMEM;
     }
 
-    txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
-    txpwr_loss = &txpwr_loss_tmp;
-    txpwr_loss->loss_enable = 0;
+	txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
+	txpwr_loss = &txpwr_loss_tmp;
+	txpwr_loss->loss_enable_2g4 = 0;
+	txpwr_loss->loss_enable_5g = 0;
 
-    get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_v3);
+	get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_v3);
 	get_userconfig_txpwr_loss(txpwr_loss);
 
-    if (txpwr_loss->loss_enable == 1) {
-        AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n", __func__, txpwr_loss->loss_value);
+	if (txpwr_loss->loss_enable_2g4 == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+				 txpwr_loss->loss_value_2g4);
 
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 9; i++)
-            txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11ax_2g4[i] += txpwr_loss->loss_value;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11ax_2g4[i] -= txpwr_loss->loss_value_2g4;
+	}
+
+	if (txpwr_loss->loss_enable_5g == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
 
 		for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11a_5g[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 9; i++)
-            txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11ax_5g[i] += txpwr_loss->loss_value;
-    }
+			txpwr_lvl_v3->pwrlvl_11a_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11ax_5g[i] -= txpwr_loss->loss_value_5g;
+	}
+
 
     if (txpwr_lvl_v3->enable == 0) {
         rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
@@ -1774,6 +1894,185 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     }
 }
 
+int rwnx_send_txpwr_lvl_v4_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_lvl_req *txpwr_lvl_req;
+    txpwr_lvl_conf_v4_t txpwr_lvl_v4_tmp;
+    txpwr_lvl_conf_v4_t *txpwr_lvl_v4;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+    txpwr_loss_conf_t *txpwr_loss;
+    int error;
+	int i;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_LVL_REQ message */
+    txpwr_lvl_req = rwnx_msg_zalloc(MM_SET_TXPWR_IDX_LVL_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_lvl_req));
+
+    if (!txpwr_lvl_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_lvl_v4 = &txpwr_lvl_v4_tmp;
+    txpwr_loss = &txpwr_loss_tmp;
+    txpwr_loss->loss_enable_2g4 = 0;
+    txpwr_loss->loss_enable_5g = 0;
+
+    get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_v4);
+    get_userconfig_txpwr_loss(txpwr_loss);
+
+	if (txpwr_loss->loss_enable_2g4 == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+				 txpwr_loss->loss_value_2g4);
+
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11ax_2g4[i] -= txpwr_loss->loss_value_2g4;
+	}
+
+	if (txpwr_loss->loss_enable_5g == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+
+		for (i = 0; i <= 7; i++)
+			txpwr_lvl_v4->pwrlvl_11a_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v4->pwrlvl_11n_11ac_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11ax_5g[i] -= txpwr_loss->loss_value_5g;
+	}
+
+
+    if (txpwr_lvl_v4->enable == 0) {
+        rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
+        return 0;
+    } else {
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n",               __func__, txpwr_lvl_v4->enable);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_1m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_2m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_5m5_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_11m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_6m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_9m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_12m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_18m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_24m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_36m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_48m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_54m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[11]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[11]);
+
+        AICWFDBG(LOGINFO, "%s:lvl_11a_6m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_9m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_12m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_18m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_24m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_36m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_48m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_54m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[11]);
+
+        txpwr_lvl_req->txpwr_lvl_v4  = *txpwr_lvl_v4;
+
+        /* Send the MM_SET_TXPWR_LVL_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_lvl_req, 1, MM_SET_TXPWR_IDX_LVL_CFM, NULL);
+
+        return (error);
+    }
+}
+
+int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_lvl_adj_req *txpwr_lvl_adj_req;
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj_tmp;
+    txpwr_lvl_adj_conf_t *txpwr_lvl_adj;
+    int error;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_LVL_REQ message */
+    txpwr_lvl_adj_req = rwnx_msg_zalloc(MM_SET_TXPWR_LVL_ADJ_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_lvl_adj_req));
+
+    if (!txpwr_lvl_adj_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_lvl_adj = &txpwr_lvl_adj_tmp;
+
+    get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj);
+
+    if (txpwr_lvl_adj->enable == 0) {
+        rwnx_msg_free(rwnx_hw, txpwr_lvl_adj_req);
+        return 0;
+    } else {
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n",                   __func__, txpwr_lvl_adj->enable);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_1_4:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_5_9:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_10_13:%d\r\n",   __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[2]);
+
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_42:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_58:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_106:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_122:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_138:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_155:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[5]);
+
+        txpwr_lvl_adj_req->txpwr_lvl_adj  = *txpwr_lvl_adj;
+
+        /* Send the MM_SET_TXPWR_LVL_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_lvl_adj_req, 1, MM_SET_TXPWR_LVL_ADJ_CFM, NULL);
+
+        return (error);
+    }
+}
+
 extern void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst);
 
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
@@ -1857,6 +2156,9 @@ int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
     }
     if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
         get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
+    } else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
     }
     if (txpwr_ofst2x->enable){
         AICWFDBG(LOGINFO, "%s:enable:%d\r\n", __func__, txpwr_ofst2x->enable);
@@ -1888,6 +2190,58 @@ int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
     return (error);
 }
 
+int rwnx_send_txpwr_ofst2x_v2_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_ofst_req *txpwr_ofst_req;
+    txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2;
+    int error = 0;
+    int type, ch_grp;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_OFST_REQ message */
+    txpwr_ofst_req = rwnx_msg_zalloc(MM_SET_TXPWR_OFST_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_ofst_req));
+
+    if (!txpwr_ofst_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_ofst2x_v2 = &txpwr_ofst_req->txpwr_ofst2x_v2;
+    txpwr_ofst2x_v2->enable = 0;
+
+	get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_v2);
+
+    if (txpwr_ofst2x_v2->enable){
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n", __func__, txpwr_ofst2x_v2->enable);
+        AICWFDBG(LOGINFO, "pwrofst2x 2.4g(ant0/ant1): [0]:11b, [1]:ofdm_highrate\n"
+            "  chan=" "\t1-4" "\t5-9" "\t10-13");
+        for (type = 0; type < 2; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant1[ch_grp][type]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\npwrofst2x 5g(ant0/ant1): [0]:ofdm_highrate\n"
+            "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+        for (type = 0; type < 1; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant1[ch_grp][type]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\n");
+
+        /* Send the MM_SET_TXPWR_OFST_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_ofst_req, 1, MM_SET_TXPWR_OFST_CFM, NULL);
+    }else{
+        AICWFDBG(LOGINFO, "%s:Do not use txpwr_ofst2x_v2\r\n", __func__);
+        rwnx_msg_free(rwnx_hw, txpwr_ofst_req);
+    }
+
+    return (error);
+}
+
 int rwnx_send_set_filter(struct rwnx_hw *rwnx_hw, uint32_t filter)
 {
     struct mm_set_filter_req *set_filter_req_param;
@@ -2112,6 +2466,11 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
     struct me_chan_config_req *req;
     struct wiphy *wiphy = rwnx_hw->wiphy;
     int i;
+#ifdef CONFIG_POWER_LIMIT
+	int8_t max_pwr;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+	txpwr_loss_conf_t *txpwr_loss;
+#endif
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -2121,6 +2480,19 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
     if (!req)
         return -ENOMEM;
 
+
+#ifdef CONFIG_POWER_LIMIT
+	txpwr_loss = &txpwr_loss_tmp;
+	get_userconfig_txpwr_loss(txpwr_loss);
+
+	if (txpwr_loss->loss_enable_2g4 == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+					txpwr_loss->loss_value_2g4);
+	if (txpwr_loss->loss_enable_5g == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+#endif
+
     req->chan2G4_cnt=  0;
     if (wiphy->bands[NL80211_BAND_2GHZ] != NULL) {
         struct ieee80211_supported_band *b = wiphy->bands[NL80211_BAND_2GHZ];
@@ -2132,6 +2504,16 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
             req->chan2G4[req->chan2G4_cnt].band = NL80211_BAND_2GHZ;
             req->chan2G4[req->chan2G4_cnt].freq = b->channels[i].center_freq;
             req->chan2G4[req->chan2G4_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+            #ifdef CONFIG_POWER_LIMIT
+            {
+                max_pwr = get_powerlimit_by_freq(PHY_BAND_2G4, req->chan2G4[req->chan2G4_cnt].freq);
+                if (txpwr_loss->loss_enable_2g4 == 1)
+                    max_pwr -= txpwr_loss->loss_value_2g4;
+                if (req->chan2G4[req->chan2G4_cnt].tx_power > max_pwr) {
+                    req->chan2G4[req->chan2G4_cnt].tx_power = max_pwr;
+                }
+            }
+            #endif
             req->chan2G4_cnt++;
             if (req->chan2G4_cnt == MAC_DOMAINCHANNEL_24G_MAX)
                 break;
@@ -2149,6 +2531,16 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
             req->chan5G[req->chan5G_cnt].band = NL80211_BAND_5GHZ;
             req->chan5G[req->chan5G_cnt].freq = b->channels[i].center_freq;
             req->chan5G[req->chan5G_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+            #ifdef CONFIG_POWER_LIMIT
+            {
+                max_pwr = get_powerlimit_by_freq(PHY_BAND_5G, req->chan5G[req->chan5G_cnt].freq);
+                if (txpwr_loss->loss_enable_5g == 1)
+                    max_pwr -= txpwr_loss->loss_value_5g;
+                if (req->chan5G[req->chan5G_cnt].tx_power > max_pwr) {
+                    req->chan5G[req->chan5G_cnt].tx_power = max_pwr;
+                }
+            }
+            #endif
             req->chan5G_cnt++;
             if (req->chan5G_cnt == MAC_DOMAINCHANNEL_5G_MAX)
                 break;
@@ -2179,6 +2571,12 @@ int rwnx_send_me_set_control_port_req(struct rwnx_hw *rwnx_hw, bool opened, u8 s
     return rwnx_send_msg(rwnx_hw, req, 1, ME_SET_CONTROL_PORT_CFM, NULL);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
+struct ieee80211_he_cap_elem_4_19 {
+	u8 mac_cap_info[6];
+	u8 phy_cap_info[11];
+} __packed;
+#endif
 int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *params,
                          const u8 *mac, u8 inst_nbr, struct me_sta_add_cfm *cfm)
 {
@@ -2245,21 +2643,24 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 #elif defined(CONFIG_VHT_FOR_OLD_KERNEL)
     if (sta->vht) {
-        const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
+        //const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
 
         req->flags |= STA_VHT_CAPA;
-        req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
-        req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
-        req->vht_cap.rx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.rx_mcs_map);
-        req->vht_cap.tx_highest = cpu_to_le16(vht_capa->supp_mcs.tx_highest);
-        req->vht_cap.tx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.tx_mcs_map);
+        req->vht_cap.vht_capa_info = cpu_to_le32(rwnx_vht_capa->cap);
+        req->vht_cap.rx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_highest);
+        req->vht_cap.rx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_mcs_map);
+        req->vht_cap.tx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_highest);
+        req->vht_cap.tx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_mcs_map);
     }
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	if (link_sta_params->he_capa) {
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		const struct ieee80211_he_cap_elem_4_19 *he_capa = (const struct ieee80211_he_cap_elem_4_19 *) link_sta_params->he_capa;
+	#else
 		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
+	#endif
         struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
                                 (struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -2566,14 +2967,15 @@ int rwnx_send_sm_connect_req(struct rwnx_hw *rwnx_hw,
         rwnx_vif->last_auth_type = sme->auth_type;
     }
 #ifdef CONFIG_USE_WIRELESS_EXT
-	memset(rwnx_hw->wext_essid, 0, 32);
+	memset(rwnx_hw->wext_essid, 0, 33);
 	memcpy(rwnx_hw->wext_essid, sme->ssid, (int)sme->ssid_len);
 #endif
 
 	rwnx_vif->sta.ssid_len = (int)sme->ssid_len;
 	memset(rwnx_vif->sta.ssid, 0, rwnx_vif->sta.ssid_len + 1);
 	memcpy(rwnx_vif->sta.ssid, sme->ssid, rwnx_vif->sta.ssid_len);
-	memcpy(rwnx_vif->sta.bssid, sme->bssid, ETH_ALEN);
+	if (sme->bssid)
+		memcpy(rwnx_vif->sta.bssid, sme->bssid, ETH_ALEN);
 
 	AICWFDBG(LOGINFO, "%s drv_vif_index:%d connect to %s(%d) channel:%d auth_type:%d\r\n",
 		__func__,
@@ -2762,8 +3164,6 @@ int rwnx_send_apm_stop_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *vif)
     return rwnx_send_msg(rwnx_hw, req, 1, APM_STOP_CFM, NULL);
 }
 
-uint8_t scanning = 0;
-uint8_t p2p_working = 0;
 
 #define P2P_WILDCARD_SSID                       "DIRECT-"
 #define P2P_WILDCARD_SSID_LEN                   (sizeof(P2P_WILDCARD_SSID) - 1)
@@ -2844,7 +3244,7 @@ int rwnx_send_scanu_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     if (!req)
         return -ENOMEM;
 
-    scanning = 1;
+    rwnx_hw->scanning = 1;
     /* Set parameters */
     req->vif_idx = rwnx_vif->vif_index;
     req->chan_cnt = (u8)min_t(int, SCAN_CHANNEL_MAX, param->n_channels);
@@ -2900,9 +3300,9 @@ int rwnx_send_scanu_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 #endif
             AICWFDBG(LOGINFO ,"p2p scan start\n");
 #ifdef CONFIG_STA_SCAN_WHEN_P2P_WORKING
-			p2p_working = 0;
+			rwnx_hw->p2p_working = false;
 #else
-			p2p_working = 1;
+			rwnx_hw->p2p_working = true;
 #endif
         }
     }
@@ -3852,7 +4252,7 @@ int rwnx_send_cfg_rssi_req(struct rwnx_hw *rwnx_hw, u8 vif_index, int rssi_thold
     return rwnx_send_msg(rwnx_hw, req, 1, MM_CFG_RSSI_CFM, NULL);
 }
 
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
 int rwnx_send_reboot(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -3863,4 +4263,4 @@ int rwnx_send_reboot(struct rwnx_hw *rwnx_hw)
     ret = rwnx_send_dbg_start_app_req(rwnx_hw, delay, HOST_START_APP_REBOOT);
     return ret;
 }
-#endif // CONFIG_USB_BT
+//#endif // CONFIG_USB_BT
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
index f3ccd71d3..c673abfd6 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -159,6 +159,7 @@ int rwnx_send_dbg_gpio_write_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, u8_l gp
 int rwnx_send_dbg_gpio_read_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, struct dbg_gpio_read_cfm *cfm);
 int rwnx_send_dbg_gpio_init_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, u8_l gpio_dir, u8_l gpio_val);
 int rwnx_send_cfg_rssi_req(struct rwnx_hw *rwnx_hw, u8 vif_index, int rssi_thold, u32 rssi_hyst);
+int rwnx_send_disable_agg_req(struct rwnx_hw *rwnx_hw, u8_l agg_disable, u8_l agg_disable_rx, u8_l sta_idx);
 int rwnx_send_coex_req(struct rwnx_hw *rwnx_hw, u8_l disable_coexnull, u8_l enable_nullcts);
 int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_get_sta_info_cfm *cfm);
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
@@ -167,18 +168,22 @@ int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en
 int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
 int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out);
 int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out);
+int rwnx_send_mask_set_ext_flags_req(struct rwnx_hw *rwnx_hw, uint32_t flags_mask, uint32_t flags_val, struct mm_set_vendor_swconfig_cfm *cfm);
 
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm);
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_ofst2x_v2_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_set_filter(struct rwnx_hw *rwnx_hw, uint32_t filter);
 int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_lvl_v4_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw);
 
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
 int rwnx_send_reboot(struct rwnx_hw *rwnx_hw);
-#endif // CONFIG_USB_BT
+//#endif // CONFIG_USB_BT
 
 
 #endif /* _RWNX_MSG_TX_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index bb7bae5f9..5156bbbd4 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -33,6 +33,7 @@
 #include "md5.h"
 #include "aicwf_compat_8800dc.h"
 #include "aicwf_compat_8800d80.h"
+#include "aicwf_compat_8800d80x2.h"
 #ifdef CONFIG_USE_FW_REQUEST
 #include <linux/firmware.h>
 #endif
@@ -60,9 +61,12 @@ typedef struct
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+    txpwr_lvl_conf_v4_t txpwr_lvl_v4;
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj;
     txpwr_loss_conf_t txpwr_loss;
     txpwr_ofst_conf_t txpwr_ofst;
     txpwr_ofst2x_conf_t txpwr_ofst2x;
+    txpwr_ofst2x_conf_v2_t txpwr_ofst2x_v2;
     xtal_cap_conf_t xtal_cap;
 } userconfig_info_t;
 
@@ -112,9 +116,32 @@ userconfig_info_t userconfig_info = {
             //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
             { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15,   14,   14},
     },
+    .txpwr_lvl_v4 = {
+        .enable             = 1,
+        .pwrlvl_11b_11ag_2g4 =
+            //1M,   2M,   5M5,  11M,  6M,   9M,   12M,  18M,  24M,  36M,  48M,  54M
+            { 20,   20,   20,   20,   20,   20,   20,   20,   18,   18,   16,   16},
+        .pwrlvl_11n_11ac_2g4 =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   16},
+        .pwrlvl_11ax_2g4 =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   16,   15,   15},
+        .pwrlvl_11a_5g =
+            //6M,   9M,   12M,  18M,  24M,  36M,  48M,  54M
+            { 20,   20,   20,   20,   18,   18,   16,   16},
+        .pwrlvl_11n_11ac_5g =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15},
+        .pwrlvl_11ax_5g =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15,   14,   14},
+    },
     .txpwr_loss = {
-        .loss_enable      = 1,
-        .loss_value       = 0,
+        .loss_enable_2g4  = 0,
+        .loss_value_2g4   = 0,
+        .loss_enable_5g   = 0,
+        .loss_value_5g    = 0,
     },
     .txpwr_ofst = {
         .enable       = 1,
@@ -141,6 +168,42 @@ userconfig_info_t userconfig_info = {
             {   0,    0,    0,    0,    0,    0   }, // ofdm_midrate
         },
     },
+    .txpwr_ofst2x_v2 = {
+        .enable        = 0,
+        .pwrofst_flags = 0,
+        .pwrofst2x_tbl_2g4_ant0 =
+        { // 11b, ofdm_highrate, ofdm_lowrate
+            {   0,    0,    0   }, // ch1-4
+            {   0,    0,    0   }, // ch5-9
+            {   0,    0,    0   }, // ch10-13
+        },
+        .pwrofst2x_tbl_2g4_ant1 =
+        { // 11b, ofdm_highrate, ofdm_lowrate
+            {   0,    0,    0   }, // ch1-4
+            {   0,    0,    0   }, // ch5-9
+            {   0,    0,    0   }, // ch10-13
+        },
+        .pwrofst2x_tbl_5g_ant0 =
+        { // ofdm_highrate, ofdm_lowrate, ofdm_midrate
+            {   0,    0,    0   }, // ch42
+            {   0,    0,    0   }, // ch58
+            {   0,    0,    0   }, // ch106
+            {   0,    0,    0   }, // ch122
+            {   0,    0,    0   }, // ch138
+            {   0,    0,    0   }, // ch155
+        },
+        .pwrofst2x_tbl_5g_ant1 =
+        { // ofdm_highrate, ofdm_lowrate, ofdm_midrate
+            {   0,    0,    0   }, // ch42
+            {   0,    0,    0   }, // ch58
+            {   0,    0,    0   }, // ch106
+            {   0,    0,    0   }, // ch122
+            {   0,    0,    0   }, // ch138
+            {   0,    0,    0   }, // ch155
+        },
+        .pwrofst2x_tbl_6g_ant0 = {   0,   }, // ofdm_highrate: 6e_ch7 ~ 6e_ch229
+        .pwrofst2x_tbl_6g_ant1 = {   0,   }, // ofdm_highrate: 6e_ch7 ~ 6e_ch229
+    },
     .xtal_cap = {
         .enable        = 0,
         .xtal_cap      = 24,
@@ -148,6 +211,29 @@ userconfig_info_t userconfig_info = {
     },
 };
 
+#ifdef CONFIG_POWER_LIMIT
+#define POWER_LIMIT_INVALID_VAL     POWER_LEVEL_INVALID_VAL
+
+#define POWER_LIMIT_CC_MATCHED_BIT  (0x1U << 0)
+
+typedef struct
+{
+    u8_l ch_cnt_2g4;
+    u8_l ch_cnt_5g;
+    u8_l ch_num_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    u8_l ch_num_5g[MAC_DOMAINCHANNEL_5G_MAX];
+    s8_l max_pwr_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    s8_l max_pwr_5g[MAC_DOMAINCHANNEL_5G_MAX];
+} txpwr_lmt_info_t;
+
+typedef struct
+{
+    u32_l flags;
+    txpwr_lmt_info_t txpwr_lmt;
+} powerlimit_info_t;
+
+powerlimit_info_t powerlimit_info = {0,};
+#endif
 
 #ifndef CONFIG_ROM_PATCH_EN
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
@@ -1334,6 +1420,15 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                 }
                 #endif
                 else
+                #elif defined(CONFIG_LOFT_CALIB)
+                if (1) {
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(rwnx_hw, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                } else
                 #endif
                 {
                     ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
@@ -1360,8 +1455,23 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                         return ret;
                     }
                 }
-                #endif
-                #endif
+                #endif/*CONFIG_FORCE_DPD_CALIB*/
+                #elif defined(CONFIG_LOFT_CALIB)
+                {
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(rwnx_hw, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif/*CONFIG_DPD*/
                 AICWFDBG(LOGINFO, "%s load rftest bin\n", __func__);
                 ret = aicwf_plat_rftest_load_8800dc(rwnx_hw);
                 if (ret) {
@@ -1628,6 +1738,33 @@ static int rwnx_check_fw_compatibility(struct rwnx_hw *rwnx_hw)
 #endif
 #endif /* !CONFIG_RWNX_FHOST */
 
+int rwnx_atoi2(char *value, int c_len)
+{
+    int len = 0;
+    int i = 0;
+    int result = 0;
+    int flag = 1;
+
+    if (value[0] == '-') {
+        flag = -1;
+        value++;
+    }
+    len = c_len;
+
+    for (i = 0;i < len ;i++) {
+        result = result * 10;
+        if (value[i] >= 48 && value[i] <= 57) {
+            result += value[i] - 48;
+        } else {
+            result = 0;
+            break;
+        }
+    }
+
+    return result * flag;
+}
+
+
 int rwnx_atoi(char *value)
 {
     int len = 0;
@@ -1796,6 +1933,95 @@ void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3)
     AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v3->pwrlvl_11ax_5g[11]);
 }
 
+void get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_conf_v4_t *txpwr_lvl_v4)
+{
+    *txpwr_lvl_v4 = userconfig_info.txpwr_lvl_v4;
+
+    AICWFDBG(LOGINFO, "%s:enable:%d\r\n",               __func__, txpwr_lvl_v4->enable);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_1m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_2m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_5m5_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_11m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_6m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_9m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_12m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_18m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_24m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_36m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_48m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_54m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[11]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[11]);
+
+    AICWFDBG(LOGINFO, "%s:lvl_11a_6m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_9m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_12m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_18m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_24m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_36m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_48m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_54m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[11]);
+}
+
+void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj)
+{
+    *txpwr_lvl_adj = userconfig_info.txpwr_lvl_adj;
+
+    AICWFDBG(LOGINFO, "%s:enable:%d\r\n",                   __func__, txpwr_lvl_adj->enable);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_1_4:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_5_9:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_10_13:%d\r\n",   __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[2]);
+
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_42:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_58:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_106:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_122:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_138:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_155:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[5]);
+}
+
 
 void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst)
 {
@@ -1842,13 +2068,39 @@ void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x)
     AICWFDBG(LOGINFO, "\n");
 }
 
+void get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2)
+{
+    int type, ch_grp;
+    *txpwr_ofst2x_v2 = userconfig_info.txpwr_ofst2x_v2;
+    AICWFDBG(LOGINFO, "%s:enable      :%d\r\n", __func__, txpwr_ofst2x_v2->enable);
+    AICWFDBG(LOGINFO, "pwrofst2x 2.4g(ant0/ant1): [0]:11b, [1]:ofdm_highrate\n"
+        "  chan=" "\t1-4" "\t5-9" "\t10-13");
+    for (type = 0; type < 2; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant1[ch_grp][type]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_highrate\n"
+        "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+    for (type = 0; type < 1; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant1[ch_grp][type]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\n");
+}
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss)
 {
-    txpwr_loss->loss_enable      = userconfig_info.txpwr_loss.loss_enable;
-    txpwr_loss->loss_value       = userconfig_info.txpwr_loss.loss_value;
-
-    AICWFDBG(LOGINFO, "%s:loss_enable:%d\r\n",     __func__, txpwr_loss->loss_enable);
-    AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n",      __func__, txpwr_loss->loss_value);
+	txpwr_loss->loss_enable_2g4  = userconfig_info.txpwr_loss.loss_enable_2g4;
+	txpwr_loss->loss_value_2g4   = userconfig_info.txpwr_loss.loss_value_2g4;
+	txpwr_loss->loss_enable_5g  = userconfig_info.txpwr_loss.loss_enable_5g;
+	txpwr_loss->loss_value_5g   = userconfig_info.txpwr_loss.loss_value_5g;
+
+	AICWFDBG(LOGDEBUG, "%s:loss_enable_2g4: %d, val_2g4: %d, loss_enable_5g: %d, val_5g: %d\r\n", __func__,
+				txpwr_loss->loss_enable_2g4, txpwr_loss->loss_value_2g4,
+				txpwr_loss->loss_enable_5g, txpwr_loss->loss_value_5g);
 }
 
 void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
@@ -2056,13 +2308,37 @@ void rwnx_plat_nvram_set_value(char *command, char *value)
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[10] = rwnx_atoi(value);
     } else if (!strcmp(command,     "lvl_11ax_mcs11_5g")) {
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[11] = rwnx_atoi(value);
-    } else if (!strcmp(command, "loss_enable")) {
-        userconfig_info.txpwr_loss.loss_enable = rwnx_atoi(value);
-    } else if (!strcmp(command, "loss_value")) {
-        userconfig_info.txpwr_loss.loss_value = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_enable")) {
+        userconfig_info.txpwr_lvl_adj.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_1_4")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_5_9")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_10_13")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_42")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_58")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_106")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_122")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_138")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_155")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_2g4")) {
+        userconfig_info.txpwr_loss.loss_enable_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_2g4")) {
+        userconfig_info.txpwr_loss.loss_value_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_5g")) {
+        userconfig_info.txpwr_loss.loss_enable_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_5g")) {
+        userconfig_info.txpwr_loss.loss_value_5g = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_enable")) {
         userconfig_info.txpwr_ofst.enable = rwnx_atoi(value);
-	userconfig_info.txpwr_ofst2x.enable = rwnx_atoi(value);
+        userconfig_info.txpwr_ofst2x.enable = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_1_4")) {
         userconfig_info.txpwr_ofst.chan_1_4 = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_5_9")) {
@@ -2094,7 +2370,7 @@ void rwnx_plat_nvram_set_value(char *command, char *value)
     } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_5_9")) {
         userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][1] = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_10_13")) {
-        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][0] = rwnx_atoi(value);
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][2] = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_42")) {
         userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][0] = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_58")) {
@@ -2142,6 +2418,293 @@ void rwnx_plat_nvram_set_value(char *command, char *value)
     }
 
 }
+void rwnx_plat_nvram_set_value_8800d80x2(char *command, char *value)
+{
+    //TODO send command
+    AICWFDBG(LOGINFO, "%s:command=%s value=%s\n", __func__, command, value);
+    if (!strcmp(command, "enable")) {
+        userconfig_info.txpwr_lvl_v4.enable = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_1m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_2m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_5m5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_11m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_6m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_9m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_12m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_18m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_24m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_36m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_48m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_54m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[11] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs0_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs1_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs2_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs3_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs4_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs6_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs7_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs8_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs9_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs0_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs1_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs2_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs3_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs4_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs6_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs7_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs8_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs9_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs10_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs11_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[11] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_6m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_9m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_12m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_18m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_24m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_36m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_48m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_54m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs0_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs1_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs2_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs3_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs4_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs5_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs6_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs7_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs8_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs9_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs0_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs1_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs2_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs3_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs4_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs5_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs6_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs7_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs8_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs9_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs10_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs11_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[11] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_enable")) {
+        userconfig_info.txpwr_lvl_adj.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_1_4")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_5_9")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_10_13")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_42")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_58")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_106")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_122")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_138")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_155")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_2g4")) {
+        userconfig_info.txpwr_loss.loss_enable_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_2g4")) {
+        userconfig_info.txpwr_loss.loss_value_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_5g")) {
+        userconfig_info.txpwr_loss.loss_enable_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_5g")) {
+        userconfig_info.txpwr_loss.loss_value_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_enable")) {
+        userconfig_info.txpwr_ofst2x_v2.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[3][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[4][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[5][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[3][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[4][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[5][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_enable")) {
+        userconfig_info.xtal_cap.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_cap")) {
+        userconfig_info.xtal_cap.xtal_cap = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_cap_fine")) {
+        userconfig_info.xtal_cap.xtal_cap_fine = rwnx_atoi(value);
+    } else {
+        AICWFDBG(LOGERROR, "invalid cmd: %s\n", command);
+    }
+}
+
+void rwnx_plat_userconfig_parsing_8800d80x2(char *buffer, int size)
+{
+    int i = 0;
+    int parse_state = 0;
+    char command[64];
+    char value[100];
+    int char_counter = 0;
+
+    memset(command, 0, 64);
+    memset(value, 0, 100);
+
+    for (i = 0; i < size; i++) {
+        //Send command or print nvram log when char is \r or \n
+        if (buffer[i] == 0x0a || buffer[i] == 0x0d) {
+            if (command[0] != 0 && value[0] != 0) {
+                if (parse_state == PRINT) {
+                    AICWFDBG(LOGINFO, "%s:%s\r\n", __func__, value);
+                } else if (parse_state == GET_VALUE) {
+                    rwnx_plat_nvram_set_value_8800d80x2(command, value);
+                }
+            }
+            //Reset command value and char_counter
+            memset(command, 0, 64);
+            memset(value, 0, 100);
+            char_counter = 0;
+            parse_state = INIT;
+            continue;
+        }
+
+        //Switch parser state
+        if (parse_state == INIT) {
+            if (buffer[i] == '#') {
+                parse_state = PRINT;
+                continue;
+            } else if (buffer[i] == 0x0a || buffer[i] == 0x0d) {
+                parse_state = INIT;
+                continue;
+            } else {
+                parse_state = CMD;
+            }
+        }
+
+        //Fill data to command and value
+        if (parse_state == PRINT) {
+            command[0] = 0x01;
+            value[char_counter] = buffer[i];
+            char_counter++;
+        } else if (parse_state == CMD) {
+            if (command[0] != 0 && buffer[i] == '=') {
+                parse_state = GET_VALUE;
+                char_counter = 0;
+                continue;
+            }
+            command[char_counter] = buffer[i];
+            char_counter++;
+        } else if (parse_state == GET_VALUE) {
+            if(buffer[i] != 0x2D && (buffer[i] < 0x30 || buffer[i] > 0x39)) {
+                continue;
+            }
+            value[char_counter] = buffer[i];
+            char_counter++;
+        }
+    }
+}
 
 void rwnx_plat_userconfig_parsing(char *buffer, int size)
 {
@@ -2208,6 +2771,405 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size)
     }
 }
 
+#ifdef CONFIG_POWER_LIMIT
+#define GetLineFromBuffer(buffer)   strsep(&buffer, "\n")
+
+int isAllSpaceOrTab(uint8_t *data, uint8_t size)
+{
+    uint8_t cnt = 0, NumOfSpaceAndTab = 0;
+    while (size > cnt) {
+        if (data[cnt] == ' ' || data[cnt] == '\t' || data[cnt] == '\0')
+            ++NumOfSpaceAndTab;
+        ++cnt;
+    }
+    return size == NumOfSpaceAndTab;
+}
+
+int IsCommentString(char *szStr)
+{
+    if (*szStr == '#' && *(szStr + 1) == ' ')
+        return 1;
+    else
+        return 0;
+}
+
+int ParseQualifiedString(char *In, u32 *Start, char *Out, char LeftQualifier, char RightQualifier)
+{
+    u32 i = 0, j = 0;
+    char c = In[(*Start)++];
+    if (c != LeftQualifier)
+        return 0;
+    i = (*Start);
+    c = In[(*Start)++];
+    while (c != RightQualifier && c != '\0')
+        c = In[(*Start)++];
+    if (c == '\0')
+        return 0;
+    j = (*Start) - 2;
+    strncpy((char *)Out, (const char *)(In + i), j - i + 1);
+    return 1;
+}
+
+int GetU1ByteIntegerFromStringInDecimal(char *Str, u8 *pInt)
+{
+    u16 i = 0;
+    *pInt = 0;
+    while (Str[i] != '\0') {
+        if (Str[i] >= '0' && Str[i] <= '9') {
+            *pInt *= 10;
+            *pInt += (Str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    return 1;
+}
+int GetS1ByteIntegerFromStringInDecimal(char *str, s8 *val)
+{
+    u8 negative = 0;
+    u16 i = 0;
+    *val = 0;
+    while (str[i] != '\0') {
+        if (i == 0 && (str[i] == '+' || str[i] == '-')) {
+            if (str[i] == '-')
+                negative = 1;
+        } else if (str[i] >= '0' && str[i] <= '9') {
+            *val *= 10;
+            *val += (str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    if (negative)
+        *val = -*val;
+    return 1;
+}
+
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc)
+{
+#define LD_STAGE_EXC_MAPPING    0
+#define LD_STAGE_TAB_DEFINE     1
+#define LD_STAGE_TAB_START      2
+#define LD_STAGE_COLUMN_DEFINE  3
+#define LD_STAGE_CH_ROW         4
+
+    uint8_t loadingStage = LD_STAGE_EXC_MAPPING;
+    uint32_t i = 0, forCnt = 0;
+    uint32_t i_cc;
+    char *szLine, *ptmp;
+    char band[10], colNumBuf[10];
+    uint8_t colNum = 0, colNum_cc = 255, band_cc = 0;
+    bool sp_cc = false;
+    // clear powerlimit info at first
+    memset((void *)&powerlimit_info, 0, sizeof(powerlimit_info_t));
+    ptmp = buffer;
+    for (szLine = GetLineFromBuffer(ptmp); szLine != NULL; szLine = GetLineFromBuffer(ptmp)) {
+        if (isAllSpaceOrTab(szLine, sizeof(*szLine)))
+            continue;
+        if (IsCommentString(szLine))
+            continue;
+
+        if (loadingStage == LD_STAGE_EXC_MAPPING) {
+            if (szLine[0] == '#' || szLine[1] == '#') {
+                loadingStage = LD_STAGE_TAB_DEFINE;
+            } else {
+                continue;
+            }
+        }
+
+        if (loadingStage == LD_STAGE_TAB_DEFINE) {
+            /* read "##	2.4G" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            szLine[--i] = ' '; /* return the space in front of the regulation info */
+
+            /* Parse the label of the table */
+            memset((void *)band, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, band, ' ', ',')) {
+                AICWFDBG(LOGERROR, "Fail to parse band!\n");
+                goto exit;
+            }
+            if (strncmp(band, "2.4G", 4) == 0) {
+                band_cc = PHY_BAND_2G4;
+            } else if (strncmp(band, "5G", 2) == 0) {
+                band_cc = PHY_BAND_5G;
+            }
+            memset((void *) colNumBuf, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, colNumBuf, '#', '#')) {
+                AICWFDBG(LOGERROR, "Fail to parse column number!\n");
+                goto exit;
+            }
+            if (!GetU1ByteIntegerFromStringInDecimal(colNumBuf, &colNum)) {
+                AICWFDBG(LOGERROR, "Column number \"%s\" is not unsigned decimal\n", colNumBuf);
+                goto exit;
+            }
+            if (colNum == 0) {
+                AICWFDBG(LOGERROR, "Column number is 0\n");
+                goto exit;
+            }
+
+            AICWFDBG(LOGINFO, "band=%s(%d)\n", band, band_cc);
+            loadingStage = LD_STAGE_TAB_START;
+        } else if (loadingStage == LD_STAGE_TAB_START) {
+            /* read "##	START" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            if (strncmp((u8 *)(szLine + i), "START", 5)) {
+                AICWFDBG(LOGERROR, "Missing \"##   START\" label\n");
+                goto exit;
+            }
+
+            loadingStage = LD_STAGE_COLUMN_DEFINE;
+        } else if (loadingStage == LD_STAGE_COLUMN_DEFINE) {
+            /* read "##	CN	US" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            for (forCnt = 0; forCnt < colNum; forCnt++) {
+                /* skip the space */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    i++;
+                i_cc = i;
+
+                while (szLine[i] != ' ' && szLine[i] != '\t' && szLine[i] != '\0')
+                    i++;
+
+                if ((i - i_cc) != 2) {
+                    AICWFDBG(LOGERROR, "CC len err\n");
+                    goto exit;
+                } else if ((szLine[i_cc] == cc[0]) && (szLine[i_cc + 1] == cc[1])) {
+                    AICWFDBG(LOGINFO, "CC matched: %s, col=%d\n", cc, forCnt);
+                    colNum_cc = forCnt;
+                    powerlimit_info.flags |= POWER_LIMIT_CC_MATCHED_BIT;
+                    sp_cc = true;
+                    break;
+                }
+            }
+
+            if (!sp_cc) {
+                colNum_cc = colNum - 1;
+                AICWFDBG(LOGDEBUG, "use 00: %s, colNum_cc=%d\n", cc, colNum_cc);
+                powerlimit_info.flags |= POWER_LIMIT_CC_MATCHED_BIT;
+            }
+
+            loadingStage = LD_STAGE_CH_ROW;
+        } else if (loadingStage == LD_STAGE_CH_ROW) {
+            char channel[10] = {0}, powerLimit[10] = {0};
+            u8 channel_num, powerLimit_val, cnt = 0;
+
+            /* the table ends */
+            if (szLine[0] == '#' && szLine[1] == '#') {
+                i = 2;
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                if (strncmp((u8 *)(szLine + i), "END", 3) == 0) {
+                    loadingStage = LD_STAGE_TAB_DEFINE;
+                    colNum = 0;
+                    continue;
+                } else {
+                    AICWFDBG(LOGERROR, "Missing \"##   END\" label\n");
+                    goto exit;
+                }
+            }
+
+            if ((szLine[0] != 'c' && szLine[0] != 'C') ||
+                (szLine[1] != 'h' && szLine[1] != 'H')
+            ) {
+                AICWFDBG(LOGERROR, "Wrong channel prefix: '%c','%c'(%d,%d)\n", szLine[0], szLine[1], szLine[0], szLine[1]);
+                continue;
+            }
+            i = 2;/* move to the  location behind 'h' */
+
+            /* load the channel number */
+            cnt = 0;
+            while (szLine[i] >= '0' && szLine[i] <= '9') {
+                channel[cnt] = szLine[i];
+                ++cnt;
+                ++i;
+            }
+
+            for (forCnt = 0; forCnt < colNum; ++forCnt) {
+                /* skip the space between channel number and the power limit value */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                /* load the power limit value */
+                memset((void *)powerLimit, 0, 10);
+
+                if (szLine[i] == 'N' && szLine[i + 1] == 'A') {
+                    /*
+                    * means channel not available
+                    */
+                    sprintf(powerLimit, "%d", POWER_LIMIT_INVALID_VAL);
+                    i += 2;
+                } else if ((szLine[i] >= '0' && szLine[i] <= '9')
+                    || szLine[i] == '+' || szLine[i] == '-'
+                ) {
+                    /* case of dBm value */
+                    cnt = 0;
+                    while ((szLine[i] >= '0' && szLine[i] <= '9')
+                        || szLine[i] == '+' || szLine[i] == '-'
+                    ) {
+                        powerLimit[cnt] = szLine[i];
+                        ++cnt;
+                        ++i;
+                    }
+                } else {
+                    AICWFDBG(LOGERROR, "Wrong limit expression \"%c%c\"(%d, %d)\n"
+                        , szLine[i], szLine[i + 1], szLine[i], szLine[i + 1]);
+                    goto exit;
+                }
+
+                if (forCnt == colNum_cc) {
+                    /* store the power limit value */
+                    if (GetU1ByteIntegerFromStringInDecimal((char *)channel, &channel_num) == 0
+                        || GetS1ByteIntegerFromStringInDecimal((char *)powerLimit, &powerLimit_val) == 0
+                    ) {
+                        AICWFDBG(LOGERROR, "Illegal index of power limit table [ch %s][val %s]\n", channel, powerLimit);
+                        goto exit;
+                    }
+
+                    if (band_cc == PHY_BAND_2G4) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_24G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_2g4[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_2g4[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_2g4++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_24G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    } else if (band_cc == PHY_BAND_5G) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_5G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_5g[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_5g[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_5g++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_5G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+exit:
+    return;
+}
+
+/// 5G lower bound freq
+#define PHY_FREQ_5G 5000
+
+uint16_t phy_channel_to_freq(uint8_t band, int channel)
+{
+    if ((band == PHY_BAND_2G4) && (channel >= 1) && (channel <= 14)) {
+        if (channel == 14)
+            return 2484;
+        else
+            return 2407 + channel * 5;
+    } else if ((band == PHY_BAND_5G) && (channel >= 1) && (channel <= 165)) {
+        return PHY_FREQ_5G + channel * 5;
+    }
+    return 0;
+}
+
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (band == PHY_BAND_2G4) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_2G4, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        } else if (band == PHY_BAND_5G) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_5G, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        }
+    }
+    return ret;
+}
+
+int8_t get_powerlimit_by_chnum(uint8_t chnum)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (chnum <= 14) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                uint8_t ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        } else if (chnum <= 165) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        }
+    }
+    return ret;
+}
+#endif
+
 /**
  * rwnx_plat_userconfig_load  ---Load aic_userconfig.txt
  *@filename name of config
@@ -2216,10 +3178,19 @@ static int rwnx_plat_userconfig_load(struct rwnx_hw *rwnx_hw) {
 
 	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC){
 		rwnx_plat_userconfig_load_8800dc(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800dcdw(rwnx_hw, PRODUCT_ID_AIC8800DC);
+        #endif
 	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
         rwnx_plat_userconfig_load_8800dw(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800dcdw(rwnx_hw, PRODUCT_ID_AIC8800DW);
+        #endif
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
         rwnx_plat_userconfig_load_8800d80(rwnx_hw);
+    }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        rwnx_plat_userconfig_load_8800d80x2(rwnx_hw);
     }
 
 	return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index 43f6b313f..72959b75b 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -38,6 +38,8 @@
 #define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_lite_8800dc.bin"
 #endif
 
+#define POWER_LEVEL_INVALID_VAL     (127)
+
 enum {
     FW_NORMAL_MODE          = 0,
     FW_RFTEST_MODE          = 1,
@@ -127,9 +129,18 @@ int is_file_exist(char* name);
 void get_userconfig_txpwr_lvl_in_fdrv(txpwr_lvl_conf_t *txpwr_lvl);
 void get_userconfig_txpwr_lvl_v2_in_fdrv(txpwr_lvl_conf_v2_t *txpwr_lvl_v2);
 void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3);
+void get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_conf_v4_t *txpwr_lvl_v4);
+void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj);
 void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst);
 void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x);
+void get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2);
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+#ifdef CONFIG_POWER_LIMIT
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc);
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq);
+int8_t get_powerlimit_by_chnum(uint8_t chnum);
+#endif
 int rwnx_platform_register_drv(void);
 void rwnx_platform_unregister_drv(void);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index 15a8d933e..ff3e87023 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -47,44 +47,23 @@ u16 tx_legrates_lut_rate[] = {
     540
 };
 
-
-u16 legrates_lut_rate[] = {
-    10 ,
-    20 ,
-    55 ,
-    110 ,
-    0 ,
-    0 ,
-    0 ,
-    0 ,
-    480 ,
-    240 ,
-    120 ,
-    60 ,
-    540 ,
-    360 ,
-    180 ,
-    90
-};
-
-
-const u8 legrates_lut[] = {
-    0,                          /* 0 */
-    1,                          /* 1 */
-    2,                          /* 2 */
-    3,                          /* 3 */
-    -1,                         /* 4 */
-    -1,                         /* 5 */
-    -1,                         /* 6 */
-    -1,                         /* 7 */
-    10,                         /* 8 */
-    8,                          /* 9 */
-    6,                          /* 10 */
-    4,                          /* 11 */
-    11,                         /* 12 */
-    9,                          /* 13 */
-    7,                          /* 14 */
-    5                           /* 15 */
+struct rwnx_legrate legrates_lut[] = {
+	[0] = { .idx = 0, .rate = 10},
+	[1] = { .idx = 1, .rate = 20},
+	[2] = { .idx = 2, .rate = 55},
+	[3] = { .idx = 3, .rate = 110},
+	[4] = { .idx = -1, .rate = 0},
+	[5] = { .idx = -1, .rate = 0},
+	[6] = { .idx = -1, .rate = 0},
+	[7] = { .idx = -1, .rate = 0},
+	[8] = { .idx = 10, .rate = 480},
+	[9] = { .idx = 8, .rate = 240},
+	[10] = { .idx = 6, .rate = 120},
+	[11] = { .idx = 4, .rate = 60},
+	[12] = { .idx = 11, .rate = 540},
+	[13] = { .idx = 9, .rate = 360},
+	[14] = { .idx = 7, .rate = 180},
+	[15] = { .idx = 5, .rate = 90},
 };
 
 struct vendor_radiotap_hdr {
@@ -285,7 +264,7 @@ static void rwnx_rx_statistic(struct rwnx_hw *rwnx_hw, struct hw_rxhdr *hw_rxhdr
                 break;
         }
     } else {
-        int idx = legrates_lut[rxvect->leg_rate];
+        int idx = legrates_lut[rxvect->leg_rate].idx;
         if (idx < 4) {
             rate_idx = idx * 2 + rxvect->pre_type;
         } else {
@@ -327,8 +306,7 @@ static void rwnx_rx_statistic(struct rwnx_hw *rwnx_hw, struct hw_rxhdr *hw_rxhdr
     cpu_raise_softirq(smp_processor_id(), NET_RX_SOFTIRQ)
 #endif /* LINUX_VERSION_CODE  */
 
-void rwnx_rx_data_skb_resend(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
-							 struct sk_buff *skb,  struct hw_rxhdr *rxhdr)
+void rwnx_rx_data_skb_resend(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif, struct sk_buff *skb)
 {
 	struct sk_buff *rx_skb = skb;
 	//bool amsdu = rxhdr->flags_is_amsdu;
@@ -369,8 +347,7 @@ void rwnx_rx_data_skb_resend(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 	}
 }
 #ifdef AICWF_RX_REORDER
-static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
-							 struct sk_buff *skb,  struct hw_rxhdr *rxhdr)
+static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif, struct sk_buff *skb)
 {
 	struct sk_buff *rx_skb;
 
@@ -457,25 +434,31 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     struct sk_buff *rx_skb;
     bool amsdu = rxhdr->flags_is_amsdu;
     bool resend = false, forward = true;
+    u8 flags_vif_idx = rxhdr->flags_vif_idx;
+    u8 flags_dst_idx = rxhdr->flags_dst_idx;
 
     skb->dev = rwnx_vif->ndev;
 
     __skb_queue_head_init(&list);
 
     if (amsdu) {
+        #if 1
+        rwnx_rxdata_process_amsdu(rwnx_hw, skb, flags_vif_idx, &list);
+        #else
         int count;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
         ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
-                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, 0);
+                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, false);
 #else
-        // for mainline linux commit 986e43b19ae9176093da35e0a844e65c8bf9ede7
         ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
-                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, false);
+                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL);
 #endif
+
         count = skb_queue_len(&list);
         if (count > ARRAY_SIZE(rwnx_hw->stats.amsdus_rx))
             count = ARRAY_SIZE(rwnx_hw->stats.amsdus_rx);
         rwnx_hw->stats.amsdus_rx[count - 1]++;
+        #endif
     } else {
         rwnx_hw->stats.amsdus_rx[0]++;
         __skb_queue_head(&list, skb);
@@ -497,9 +480,9 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
         } else {
             /* unicast pkt for STA inside the BSS, no need to forward to upper
                layer simply resend on wireless interface */
-            if (rxhdr->flags_dst_idx != RWNX_INVALID_STA)
+            if (flags_dst_idx != RWNX_INVALID_STA)
             {
-                struct rwnx_sta *sta = &rwnx_hw->sta_table[rxhdr->flags_dst_idx];
+                struct rwnx_sta *sta = &rwnx_hw->sta_table[flags_dst_idx];
                 if (sta->valid && (sta->vlan_idx == rwnx_vif->vif_index))
                 {
                     forward = false;
@@ -516,7 +499,7 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
         if (!is_multicast_ether_addr(eth->h_dest)) {
             /* unicast pkt for STA inside the BSS, no need to forward to upper
                layer simply resend on wireless interface */
-            if (rxhdr->flags_dst_idx != RWNX_INVALID_STA)
+            if (flags_dst_idx != RWNX_INVALID_STA)
             {
                 forward = false;
                 resend = true;
@@ -693,7 +676,10 @@ static void rwnx_rx_mgmt(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 	struct ieee80211_he_cap_elem *he;
 #endif
 
-    //printk("rwnx_rx_mgmt\n");
+	//printk("rwnx_rx_mgmt\n");
+	if(skb->data[0]!=0x80)
+		AICWFDBG(LOGDEBUG,"rxmgmt:%x,%x\n", skb->data[0], skb->data[1]);
+
 #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
 	struct aic_sta *sta = &rwnx_hw->aic_table[rwnx_vif->ap.aic_index];
 	const u8* ie;
@@ -728,8 +714,19 @@ static void rwnx_rx_mgmt(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
         }
         #endif
     }
+    if (ieee80211_is_deauth(mgmt->frame_control) && rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) {
+        printk("DEAUTH: sta_idx %d MAC %pM reason:%x\n", rwnx_vif->ap.aic_index, mgmt->sa, mgmt->u.deauth.reason_code);
+    }
+    if (ieee80211_is_disassoc(mgmt->frame_control) && rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) {
+        printk("DISASSOC: sta_idx %d MAC %pM reason:%x\n", rwnx_vif->ap.aic_index, mgmt->sa, mgmt->u.disassoc.reason_code);
+    }
 #endif
 
+    if (ieee80211_is_mgmt(mgmt->frame_control) &&
+        (skb->len <= 24 || skb->len > 768)) {
+        printk("mgmt err\n");
+        return;
+    }
     if (ieee80211_is_beacon(mgmt->frame_control)) {
         if ((RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MESH_POINT) &&
             hw_rxhdr->flags_new_peer) {
@@ -1018,7 +1015,7 @@ static void rwnx_rx_add_rtap_hdr(struct rwnx_hw* rwnx_hw,
         struct ieee80211_supported_band* band =
                 rwnx_hw->wiphy->bands[phy_info->phy_band];
         rtap->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
-        BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate]) == -1);
+        BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate].idx) == -1);
         if (phy_info->phy_band == NL80211_BAND_5GHZ)
             rate_idx -= 4;  /* rwnx_ratetable_5ghz[0].hw_value == 4 */
         *pos = DIV_ROUND_UP(band->bitrates[rate_idx].bitrate, 5);
@@ -1345,6 +1342,7 @@ struct reord_ctrl_info *reord_init_sta(struct aicwf_rx_priv* rx_priv, const u8 *
         return NULL;
     }
 
+    AICWFDBG(LOGINFO, "reord_init_sta:%pM\n", mac_addr);
     reord_info = kmalloc(sizeof(struct reord_ctrl_info), GFP_ATOMIC);
     if (!reord_info)
         return NULL;
@@ -1482,31 +1480,13 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
     struct list_head *rxframes_freequeue = NULL;
     struct sk_buff *skb = NULL;
     struct rwnx_vif *rwnx_vif = (struct rwnx_vif *)rx_priv->rwnx_vif;
+    struct sk_buff_head list;
+    struct sk_buff *rx_skb;
 
     rxframes_freequeue = &rx_priv->rxframes_freequeue;
     skb = prframe->pkt;
-    if (skb == NULL) {
-        txrx_err("skb is NULL\n");
-        return -1;
-    }
-
-	if(!prframe->forward) {
-		//printk("single: %d not forward: drop\n", prframe->seq_num);
-		dev_kfree_skb(skb);
-		prframe->pkt = NULL;
-		reord_rxframe_free(&rx_priv->freeq_lock, rxframes_freequeue, &prframe->rxframe_list);
-		return 0;
-	}
-
-    skb->data = prframe->rx_data;
-    skb_set_tail_pointer(skb, prframe->len);
-    skb->len = prframe->len;
 
-    rwnx_vif->net_stats.rx_packets++;
-    rwnx_vif->net_stats.rx_bytes += skb->len;
-    //printk("netif sn=%d, len=%d\n", precv_frame->attrib.seq_num, skb->len);
-
-#ifdef CONFIG_BR_SUPPORT
+    #ifdef CONFIG_BR_SUPPORT
     void *br_port = NULL;
 
     if (1) {//(check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) == _TRUE) {
@@ -1531,54 +1511,110 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
     }
 #endif /* CONFIG_BR_SUPPORT */
 
-    skb->dev = rwnx_vif->ndev;
+    if (skb == NULL) {
+        txrx_err("skb is NULL\n");
+        return -1;
+    }
 
-#if 0
-	if(test_log_flag){
-		if(skb->data[42] == 0x80){
-			printk("AIDEN : SN:%d R_SN:%d pid:%d\r\n",
-				prframe->seq_num, (skb->data[44] << 8| skb->data[45]), current->pid);
-			}
-	}
-#endif
-	rwnx_skb_align_8bytes(skb);
+    if(prframe->is_ap_reord) {
+        if(prframe->ap_resend_cnt) {
+            struct sk_buff *resend_skb = prframe->first_resend_skb;
+            struct sk_buff *resend_next_skb;
+            u8 resend_cnt = 0;
+            while(resend_skb) {
+                resend_cnt++;
+                resend_next_skb = resend_skb->next;
+                dev_kfree_skb(resend_skb);
+                resend_skb = resend_next_skb;
+            }
+            if(resend_cnt != prframe->ap_resend_cnt)
+                printk("resend cnt error: %d,%d\n", resend_cnt, prframe->ap_resend_cnt);
+
+            if(!prframe->ap_fwd_cnt) {
+                prframe->pkt = NULL;
+                reord_rxframe_free(&rx_priv->freeq_lock, rxframes_freequeue, &prframe->rxframe_list);
+                return 0;
+            } //else
+              //  printk("both has resend & fwd\n");
+        }
+    } else {
+        if(!prframe->forward) {
+            dev_kfree_skb(skb);
+            prframe->pkt = NULL;
+            reord_rxframe_free(&rx_priv->freeq_lock, rxframes_freequeue, &prframe->rxframe_list);
+            return 0;
+        }
+    }
 
-    skb->protocol = eth_type_trans(skb, rwnx_vif->ndev);
+    __skb_queue_head_init(&list);
+    if(!prframe->is_ap_reord)
+    {
+        if(prframe->is_amsdu) {
+            rwnx_rxdata_process_amsdu(rwnx_vif->rwnx_hw, skb, rwnx_vif->vif_index, &list); //rxhdr not used below since skb free!
+        } else {
+           __skb_queue_head(&list, skb);
+        }
+    } else {
+        struct sk_buff *fwd_skb = prframe->first_fwd_skb;
+        struct sk_buff *fwd_next_skb;
+        u8 fwd_cnt = 0;
+        while(fwd_skb) {
+            //printk("single ind:%p\n", fwd_skb);
+            fwd_cnt++;
+            fwd_next_skb = fwd_skb->next;
+            __skb_queue_tail(&list, fwd_skb);
+            fwd_skb = fwd_next_skb;
+        }
+        if(fwd_cnt != prframe->ap_fwd_cnt)
+            printk("fwd cnt error: %d,%d\n", fwd_cnt, prframe->ap_fwd_cnt);
+    }
+
+    while (!skb_queue_empty(&list)) {
+        rx_skb = __skb_dequeue(&list);
+
+        rwnx_vif->net_stats.rx_packets++;
+        rwnx_vif->net_stats.rx_bytes += rx_skb->len;
+        //printk("netif sn=%d, len=%d\n", precv_frame->attrib.seq_num, skb->len);
+        rx_skb->dev = rwnx_vif->ndev;
+        rwnx_skb_align_8bytes(rx_skb);
+        rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 
 #ifdef AICWF_ARP_OFFLOAD
-    if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
-        arpoffload_proc(skb, rwnx_vif);
-    }
+        if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
+            arpoffload_proc(rx_skb, rwnx_vif);
+        }
 #endif
-    memset(skb->cb, 0, sizeof(skb->cb));
+        memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 
 #ifdef CONFIG_FILTER_TCP_ACK
-     filter_rx_tcp_ack(rwnx_vif->rwnx_hw, skb->data, cpu_to_le16(skb->len));
+         filter_rx_tcp_ack(rwnx_vif->rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
 #endif
 
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
-    local_bh_disable();
-	netif_receive_skb(skb);
-    local_bh_enable();
+        local_bh_disable();
+        netif_receive_skb(rx_skb);
+        local_bh_enable();
 #else
-    if (in_interrupt()) {
-        netif_rx(skb);
-    } else {
-    /*
-    * If the receive is not processed inside an ISR, the softirqd must be woken explicitly to service the NET_RX_SOFTIRQ.
-    * * In 2.6 kernels, this is handledby netif_rx_ni(), but in earlier kernels, we need to do it manually.
-    */
+        if (in_interrupt()) {
+            netif_rx(rx_skb);
+        } else {
+        /*
+        * If the receive is not processed inside an ISR, the softirqd must be woken explicitly to service the NET_RX_SOFTIRQ.
+        * * In 2.6 kernels, this is handledby netif_rx_ni(), but in earlier kernels, we need to do it manually.
+        */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
-    netif_rx_ni(skb);
+        netif_rx_ni(rx_skb);
 #else
-    ulong flags;
-    netif_rx(skb);
-    local_irq_save(flags);
-    RAISE_RX_SOFTIRQ();
-    local_irq_restore(flags);
+        ulong flags;
+        netif_rx(rx_skb);
+        local_irq_save(flags);
+        RAISE_RX_SOFTIRQ();
+        local_irq_restore(flags);
 #endif
-    }
+        }
 #endif//CONFIG_RX_NETIF_RECV_SKB
+    }
+
     prframe->pkt = NULL;
     reord_rxframe_free(&rx_priv->freeq_lock, rxframes_freequeue, &prframe->rxframe_list);
 
@@ -1705,45 +1741,38 @@ void reord_timeout_worker(struct work_struct *work)
     return ;
 }
 
-int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 seq_num, u8 tid, u8 forward)
+int reord_process_unit(struct recv_msdu *pframe, struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 seq_num, u8 tid, u8 forward, u8 is_amsdu)
 {
     int ret=0;
     u8 *mac;
-    struct recv_msdu *pframe;
     struct reord_ctrl *preorder_ctrl;
     struct reord_ctrl_info *reord_info;
     struct rwnx_vif *rwnx_vif = (struct rwnx_vif *)rx_priv->rwnx_vif;
     struct ethhdr *eh = (struct ethhdr *)(skb->data);
-    //u8 *da = eh->h_dest;
-    //u8 is_mcast = ((*da) & 0x01)? 1 : 0;
-
-    if (rwnx_vif == NULL || skb->len <= 14) {
-        dev_kfree_skb(skb);
-        return -1;
-    }
+    u8 *da = eh->h_dest;
+    u8 is_mcast = ((*da) & 0x01)? 1 : 0;
 
+    #if 0
+    struct recv_msdu *pframe;
     pframe = reord_rxframe_alloc(&rx_priv->freeq_lock, &rx_priv->rxframes_freequeue);
     if (!pframe) {
         dev_kfree_skb(skb);
         return -1;
     }
+    #endif
 
     INIT_LIST_HEAD(&pframe->reord_pending_list);
     pframe->seq_num = seq_num;
     pframe->tid = tid;
     pframe->rx_data = skb->data;
-    pframe->len = skb->len;
+    //pframe->len = skb->len;
     pframe->pkt = skb;
-	pframe->forward = forward;
+    pframe->forward = forward;
     preorder_ctrl = pframe->preorder_ctrl;
+    pframe->is_amsdu = is_amsdu;
 
-#if 0
-    if ((ntohs(eh->h_proto) == ETH_P_PAE) || is_mcast){
-		printk("%s AIDEN pframe->seq_num:%d is bcast or mcast\r\n", __func__, pframe->seq_num);
-        ret = reord_single_frame_ind(rx_priv, pframe);
-		return ret;
-    }
-#endif
+    if ((ntohs(eh->h_proto) == ETH_P_PAE) || is_mcast)
+        return reord_single_frame_ind(rx_priv, pframe);
 
     if((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))
         mac = eh->h_dest;
@@ -1765,11 +1794,11 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 
     if (&reord_info->list == &rx_priv->stas_reord_list) {//first time???
         reord_info = reord_init_sta(rx_priv, mac);
-		//reord_info has 8 preorder_ctrl,
-		//There is a one-to-one matched preorder_ctrl and tid
+        //reord_info has 8 preorder_ctrl,
+        //There is a one-to-one matched preorder_ctrl and tid
         if (!reord_info) {
             spin_unlock_bh(&rx_priv->stas_reord_lock);
-            dev_kfree_skb(skb);
+            reord_single_frame_ind(rx_priv, pframe);
             return -1;
         }
         list_add_tail(&reord_info->list, &rx_priv->stas_reord_list);
@@ -1786,22 +1815,22 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 
     if (preorder_ctrl->enable == false) {
         preorder_ctrl->ind_sn = pframe->seq_num;
-		spin_lock_bh(&preorder_ctrl->reord_list_lock);//AIDEN
+        spin_lock_bh(&preorder_ctrl->reord_list_lock);//AIDEN
         reord_single_frame_ind(rx_priv, pframe);
-		spin_unlock_bh(&preorder_ctrl->reord_list_lock);//AIDEN
+        spin_unlock_bh(&preorder_ctrl->reord_list_lock);//AIDEN
         preorder_ctrl->ind_sn = (preorder_ctrl->ind_sn + 1)%4096;
         return 0;
     }
 
     spin_lock_bh(&preorder_ctrl->reord_list_lock);
     if (reord_need_check(preorder_ctrl, pframe->seq_num)) {
-#if 0
+#if 1
 		if(pframe->rx_data[42] == 0x80){//this is rtp package
 			if(pframe->seq_num == preorder_ctrl->ind_sn){
-				printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
+				//printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
 	        	reord_single_frame_ind(rx_priv, pframe);//not need to reorder
 			}else{
-				printk("%s free pframe->seq_num:%d \r\n", __func__, pframe->seq_num);
+				//printk("%s free pframe->seq_num:%d \r\n", __func__, pframe->seq_num);
 			    if (pframe->pkt){
 			        dev_kfree_skb(pframe->pkt);
 			        pframe->pkt = NULL;
@@ -1848,7 +1877,7 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
         dev_kfree_skb(pframe->pkt);
         pframe->pkt = NULL;
     }
-   	reord_rxframe_free(&rx_priv->freeq_lock, &rx_priv->rxframes_freequeue, &pframe->rxframe_list);
+    reord_rxframe_free(&rx_priv->freeq_lock, &rx_priv->rxframes_freequeue, &pframe->rxframe_list);
     return ret;
 }
 
@@ -1921,14 +1950,94 @@ void remove_sec_hdr_mgmt_frame(struct hw_rxhdr *hw_rxhdr,struct sk_buff *skb)
                 skb_pull(skb,8);
                 memcpy(skb->data,mgmt_header,hdr_len);
                 hw_rxhdr->hwvect.len -= 8;
+            } else {
+                printk("unsupport decr_status:%d\n",hw_rxhdr->hwvect.decr_status);
             }
+        }
+    }
+}
+
+void rwnx_rxdata_process_amsdu(struct rwnx_hw *rwnx_hw, struct sk_buff *skb, u8 vif_idx,
+                                        struct sk_buff_head *list)
+{
+	u16 len_alligned = 0;
+	u16 sublen = 0;
+	struct sk_buff *sub_skb = NULL;
+    struct rwnx_vif *rwnx_vif;
+
+    //if (is_amsdu) 
+    {
+        //skb_pull(skb, pull_len-8);
+        /* |amsdu sub1 | amsdu sub2 | ... */
+        len_alligned = 0;
+        sublen = 0;
+        sub_skb = NULL;
+        while (skb->len > 16) {
+            sublen = (skb->data[12]<<8)|(skb->data[13]);
+            if (skb->len > (sublen+14))
+                len_alligned = roundup(sublen + 14, 4);
+            else if (skb->len == (sublen+14))
+                len_alligned = sublen+14;
             else {
-                printk("unsupport decr_status:%d\n",hw_rxhdr->hwvect.decr_status);
+                printk("accroding to amsdu: this will not happen\n");
+                break;
+            }
+            //printk("sublen = %d, %x, %x, %x, %x\r\n", sublen,skb->data[0], skb->data[1], skb->data[12], skb->data[13]);
+#if 1
+            sub_skb = __dev_alloc_skb(sublen - 6 + 12, GFP_ATOMIC);
+            if(!sub_skb){
+                printk("sub_skb alloc fail:%d\n", sublen);
+                break;
+            }
+            skb_put(sub_skb, sublen - 6 + 12);
+            memcpy(sub_skb->data, skb->data, MAC_ADDR_LEN);
+            memcpy(&sub_skb->data[6], &skb->data[6], MAC_ADDR_LEN);
+            memcpy(&sub_skb->data[12], &skb->data[14 + 6], sublen - 6);
+
+            rwnx_vif = rwnx_rx_get_vif(rwnx_hw, vif_idx);
+            if (!rwnx_vif) {
+                printk("frame received but no active vif (%d), skb->len:%u\n", vif_idx, skb->len);
+                //dev_kfree_skb(sub_skb);
+                break;
             }
+            __skb_queue_tail(list, sub_skb);
+
+            //printk("a:%p\n", sub_skb);
+            //if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, sub_skb, hw_rxhdr))
+            //    dev_kfree_skb(sub_skb);
+#endif
+            skb_pull(skb, len_alligned);
         }
+        //printk("af:%p\n", skb);
+        //printk("cnt=%d\n", cnt);
+        dev_kfree_skb(skb);
+        //return 0;
     }
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void defrag_timeout_cb(ulong data)
+#else
+void defrag_timeout_cb(struct timer_list *t)
+#endif
+{
+	struct defrag_ctrl_info *defrag_ctrl = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+	defrag_ctrl = (struct defrag_ctrl_info *)data;
+#else
+	defrag_ctrl = from_timer(defrag_ctrl, t, defrag_timer);
+#endif
+
+	printk("%s:%p\r\n", __func__, defrag_ctrl);
+	spin_lock_bh(&defrag_ctrl->rwnx_hw->defrag_lock);
+	list_del_init(&defrag_ctrl->list);
+	dev_kfree_skb(defrag_ctrl->skb);
+	kfree(defrag_ctrl);
+	spin_unlock_bh(&defrag_ctrl->rwnx_hw->defrag_lock);
+}
+
+extern void rwnx_data_dump(char* tag, void* data, unsigned long len);
+
 u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
 {
     struct hw_rxhdr *hw_rxhdr;
@@ -1937,19 +2046,26 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
     struct sk_buff *skb  = hostid;
     int msdu_offset = sizeof(struct hw_rxhdr) + 2;
     u16_l status = 0;
+    struct aicwf_rx_priv *rx_priv_tmp;
     u8 hdr_len = 24;
     u8 ra[MAC_ADDR_LEN] = {0};
     u8 ta[MAC_ADDR_LEN] = {0};
     u8 ether_type[2] = {0};
     u8 pull_len = 0;
+    u16 seq_num = 0;
+    u8_l frag_num = 0;
     u8 tid = 0;
     u8 is_qos = 0;
-#ifdef AICWF_RX_REORDER
-    struct aicwf_rx_priv *rx_priv_tmp;
-	u16 seq_num = 0;
-    bool resend = false;
-    bool forward = false;
-#endif
+    u8 is_frag = 0;
+    struct defrag_ctrl_info *defrag_info = NULL;
+    struct defrag_ctrl_info *defrag_info_tmp = NULL;
+    struct sk_buff *skb_tmp = NULL;
+    int ret;
+    u8 sta_idx = 0;
+    u16_l frame_ctrl;
+    u8 is_amsdu = 0;
+    bool resend = false, forward = true;
+    const struct ethhdr *eth;
 
     REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_RWNXDATAIND);
     hw_rxhdr = (struct hw_rxhdr *)skb->data;
@@ -1985,7 +2101,7 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
         //Check if monitor interface exists and is open
         rwnx_vif = rwnx_rx_get_vif(rwnx_hw, rwnx_hw->monitor_vif);
         if (!rwnx_vif) {
-            dev_err(rwnx_hw->dev, "Received monitor frame but there is no monitor interface open\n");
+            dev_err(rwnx_hw->dev, "Received monitor frame but there is no monitor interface open, skb->len:%u\n", skb->len);
             goto check_len_update;
         }
 
@@ -2033,6 +2149,8 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
         #endif
         }
 
+        skb_reset_tail_pointer(skb);
+        skb->len = 0;
         skb_reset_tail_pointer(skb_monitor);
         skb_monitor->len = 0;
         skb_put(skb_monitor, frm_len);
@@ -2084,16 +2202,23 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
                                &hw_rxhdr->hwvect.rx_vect1,
                                &hw_rxhdr->hwvect.rx_vect2);
         skb_pull(skb, msdu_offset + 2); //+2 since sdio allign 58->60
+#define MAC_FCTRL_MOREFRAG 0x0400
+		frame_ctrl = (skb->data[1] << 8) | skb->data[0];
+		seq_num = ((skb->data[22] & 0xf0) >> 4) | (skb->data[23] << 4);
+		frag_num = (skb->data[22] & 0x0f);
+        is_amsdu = 0;
+
+		if ((skb->data[0] & 0x0f) == 0x08) {
+			if ((skb->data[0] & 0x80) == 0x80) {//qos data
+				hdr_len = 26;
+				tid = skb->data[24] & 0x0F;
+				is_qos = 1;
+				if (skb->data[24] & 0x80)
+					is_amsdu = 1;
+			}
 
-	if(skb->data[1] & 0x80)//htc
-		hdr_len += 4;
-
-        if((skb->data[0] & 0x0f)==0x08) {
-            if((skb->data[0] & 0x80) == 0x80) {//qos data
-                hdr_len += 2;//802.11 mac header len
-                tid = skb->data[24] & 0x0F;
-                is_qos = 1;
-            }
+			if(skb->data[1] & 0x80)// htc
+				hdr_len += 4;
 
             if((skb->data[1] & 0x3) == 0x1)  {// to ds
                 memcpy(ra, &skb->data[16], MAC_ADDR_LEN);//destination addr
@@ -2104,41 +2229,185 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
             }
 
             pull_len += (hdr_len + 8);
-#ifdef AICWF_RX_REORDER
-            seq_num = ((skb->data[22]&0xf0)>>4) | (skb->data[23]<<4);
+
+			switch (hw_rxhdr->hwvect.decr_status) {
+			case RWNX_RX_HD_DECR_CCMP128:
+				pull_len += 8;//ccmp_header
+				//skb_pull(&skb->data[skb->len-8], 8); //ccmp_mic_len
+				memcpy(ether_type, &skb->data[hdr_len + 6 + 8], 2);
+				break;
+			case RWNX_RX_HD_DECR_TKIP:
+				pull_len += 8;//tkip_header
+				memcpy(ether_type, &skb->data[hdr_len + 6 + 8], 2);
+				break;
+			case RWNX_RX_HD_DECR_WEP:
+				pull_len += 4;//wep_header
+				memcpy(ether_type, &skb->data[hdr_len + 6 + 4], 2);
+				break;
+			case RWNX_RX_HD_DECR_WAPI:
+                pull_len += 18;//wapi_header
+                memcpy(ether_type, &skb->data[hdr_len + 6 + 18], 2);
+                break;
+
+			default:
+				memcpy(ether_type, &skb->data[hdr_len + 6], 2);
+				break;
+			}
+            if(is_amsdu)
+                hw_rxhdr->flags_is_amsdu = 1;
+            else
+                hw_rxhdr->flags_is_amsdu = 0;
+
+            if((ether_type[0] == 0x8e && ether_type[1] == 0x88) || (ether_type[0] == 0x88 && ether_type[1] == 0x8e))
+                printk("rx eapol\n");
+			if (is_amsdu) {
+                skb_pull(skb, pull_len-8);
+			}
+
+			if (hw_rxhdr->flags_dst_idx != RWNX_INVALID_STA)
+				sta_idx = hw_rxhdr->flags_dst_idx;
+
+			if (!hw_rxhdr->flags_need_reord && ((frame_ctrl & MAC_FCTRL_MOREFRAG) || frag_num)) {
+				printk("rxfrag:%d,%d,%d,sn=%d,%d\r\n", (frame_ctrl & MAC_FCTRL_MOREFRAG), frag_num, skb->len, seq_num,pull_len);
+				if (frame_ctrl & MAC_FCTRL_MOREFRAG) {
+					spin_lock_bh(&rwnx_hw->defrag_lock);
+					if (!list_empty(&rwnx_hw->defrag_list)) {
+						list_for_each_entry(defrag_info_tmp, &rwnx_hw->defrag_list, list) {
+							if ((defrag_info_tmp->sn == seq_num) && (defrag_info_tmp->tid == tid) && \
+									defrag_info_tmp->sta_idx == sta_idx) {
+								defrag_info = defrag_info_tmp;
+								break;
+							}
+						}
+					}
+
+					//printk("rx frag: sn=%d, fn=%d, skb->len=%d\r\n", seq_num, frag_num, skb->len);
+					if (defrag_info) {
+						is_frag = 1;
+						if (defrag_info->next_fn != frag_num) {
+							printk("discard:%d:%d\n", defrag_info->next_fn, frag_num);
+							dev_kfree_skb(skb);
+							spin_unlock_bh(&rwnx_hw->defrag_lock);
+							return 0;
+						}
+
+						skb_put(defrag_info->skb, skb->len-(pull_len-8));
+						memcpy(&defrag_info->skb->data[defrag_info->frm_len], \
+								&skb->data[pull_len-8], skb->len - (pull_len-8));
+						//printk("middle:%d,%d\n", skb->len-(pull_len-8), skb->len);
+						defrag_info->frm_len += (skb->len - (pull_len - 8));
+						defrag_info->next_fn++;
+						dev_kfree_skb(skb);
+						spin_unlock_bh(&rwnx_hw->defrag_lock);
+						return 0;
+					} else {
+						defrag_info = kzalloc(sizeof(struct defrag_ctrl_info), GFP_KERNEL);
+						if (defrag_info == NULL) {
+							printk("no defrag_ctrl_info\r\n");
+							dev_kfree_skb(skb);
+							spin_unlock_bh(&rwnx_hw->defrag_lock);
+							return 0;
+						}
+						defrag_info->skb = __dev_alloc_skb(2000, GFP_KERNEL);
+						if (defrag_info->skb == NULL) {
+							printk("no fragment skb\r\n");
+							dev_kfree_skb(skb);
+							kfree(defrag_info);
+							spin_unlock_bh(&rwnx_hw->defrag_lock);
+							return 0;
+						}
+						is_frag = 1;
+						skb_pull(skb, pull_len);
+						skb_push(skb, 14);
+						memcpy(skb->data, ra, MAC_ADDR_LEN);
+						memcpy(&skb->data[6], ta, MAC_ADDR_LEN);
+						memcpy(&skb->data[12], ether_type, 2);
+						defrag_info->sn = seq_num;
+						defrag_info->next_fn = 1;
+						defrag_info->tid = tid;
+						defrag_info->sta_idx = sta_idx;
+
+						skb_put(defrag_info->skb, skb->len);
+						memcpy(defrag_info->skb->data, skb->data, skb->len);
+						defrag_info->frm_len = skb->len;
+						defrag_info->rwnx_hw = rwnx_hw;
+						//printk("first:%p,%p,%p,%p,%p, %d,%d\r\n", defrag_info, defrag_info->skb, defrag_info->skb->head, defrag_info->skb->tail, defrag_info->skb->end, defrag_info->frm_len, skb->len);
+						list_add_tail(&defrag_info->list, &rwnx_hw->defrag_list);
+						spin_unlock_bh(&rwnx_hw->defrag_lock);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+						init_timer(&defrag_info->defrag_timer);
+						defrag_info->defrag_timer.data = (unsigned long)defrag_info;
+						defrag_info->defrag_timer.function = defrag_timeout_cb;
+#else
+						timer_setup(&defrag_info->defrag_timer, defrag_timeout_cb, 0);
 #endif
-            switch(hw_rxhdr->hwvect.decr_status)
-            {
-                case RWNX_RX_HD_DECR_CCMP128:
-                    pull_len += 8;//ccmp_header
-                    //skb_pull(&skb->data[skb->len-8], 8); //ccmp_mic_len
-                    memcpy(ether_type, &skb->data[hdr_len + 6 + 8], 2);
-                    break;
-                case RWNX_RX_HD_DECR_TKIP:
-                    pull_len += 8;//tkip_header
-                    memcpy(ether_type, &skb->data[hdr_len + 6 + 8], 2);
-                    break;
-                case RWNX_RX_HD_DECR_WEP:
-                    pull_len += 4;//wep_header
-                    memcpy(ether_type, &skb->data[hdr_len + 6 + 4], 2);
-                    break;
-		case RWNX_RX_HD_DECR_WAPI:
-                    pull_len += 18;//wapi_header
-                    memcpy(ether_type, &skb->data[hdr_len + 6 + 18], 2);
-                    break;
-
-                default:
-                    memcpy(ether_type, &skb->data[hdr_len + 6], 2);
-                    break;
-            }
+						ret = mod_timer(&defrag_info->defrag_timer, jiffies + msecs_to_jiffies(DEFRAG_MAX_WAIT));
+						dev_kfree_skb(skb);
+						return 0;
+					}
+				} else {
+					//check whether the last fragment
+					if (!list_empty(&rwnx_hw->defrag_list)) {
+						spin_lock_bh(&rwnx_hw->defrag_lock);
+						list_for_each_entry(defrag_info_tmp, &rwnx_hw->defrag_list, list) {
+							if (((defrag_info_tmp->sn == seq_num) && (defrag_info_tmp->tid == tid) && \
+										defrag_info_tmp->sta_idx == sta_idx)) {
+								defrag_info = defrag_info_tmp;
+								break;
+							}
+						}
+
+						if (!defrag_info) 
+							spin_unlock_bh(&rwnx_hw->defrag_lock);
+						else {
+							if (defrag_info->next_fn != frag_num) {
+								printk("discard:%d:%d\n", defrag_info->next_fn, frag_num);
+								dev_kfree_skb(skb);
+								spin_unlock_bh(&rwnx_hw->defrag_lock);
+								return 0;
+							}
+
+							skb_put(defrag_info->skb, skb->len - (pull_len-8));
+							memcpy(&defrag_info->skb->data[defrag_info->frm_len], \
+										&skb->data[pull_len-8], skb->len - (pull_len-8));
+							defrag_info->frm_len += (skb->len - (pull_len-8));
+							is_frag = 1;
+							//printk("last: sn=%d, fn=%d, %d, %d\r\n", seq_num, frag_num, defrag_info->frm_len, skb->len);
+
+							rwnx_vif = rwnx_rx_get_vif(rwnx_hw, hw_rxhdr->flags_vif_idx);
+							if (!rwnx_vif) {
+								printk("Frame received but no active vif (%d)", hw_rxhdr->flags_vif_idx);
+								dev_kfree_skb(skb);
+								spin_unlock_bh(&rwnx_hw->defrag_lock);
+								return 0;
+							}
+							dev_kfree_skb(skb);
+
+							skb_tmp = defrag_info->skb;
+							list_del_init(&defrag_info->list);
+							if (timer_pending(&defrag_info->defrag_timer)) {
+								ret = del_timer(&defrag_info->defrag_timer);
+							}
+							kfree(defrag_info);
+							spin_unlock_bh(&rwnx_hw->defrag_lock);
+
+							if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb_tmp, hw_rxhdr))
+								dev_kfree_skb(skb_tmp);
+
+							return 0;
+						}
+					}
+				}
+			}
 
-            skb_pull(skb, pull_len);
-            skb_push(skb, 14);
-			//fill 802.3 header
-            memcpy(skb->data, ra, MAC_ADDR_LEN);//destination addr
-            memcpy(&skb->data[6], ta, MAC_ADDR_LEN);//source addr
-            memcpy(&skb->data[12], ether_type, 2);//802.3 type
-        }
+			if (!is_frag && !is_amsdu) {
+				skb_pull(skb, pull_len);
+				skb_push(skb, 14);
+				memcpy(skb->data, ra, MAC_ADDR_LEN);
+				memcpy(&skb->data[6], ta, MAC_ADDR_LEN);
+				memcpy(&skb->data[12], ether_type, 2);
+			}
+		}
 
         if (hw_rxhdr->flags_is_80211_mpdu) {
             remove_sec_hdr_mgmt_frame(hw_rxhdr,skb);
@@ -2147,8 +2416,8 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
             rwnx_vif = rwnx_rx_get_vif(rwnx_hw, hw_rxhdr->flags_vif_idx);
 
             if (!rwnx_vif) {
-                dev_err(rwnx_hw->dev, "Frame received but no active vif (%d)",
-                        hw_rxhdr->flags_vif_idx);
+                dev_err(rwnx_hw->dev, "Frame received but no active vif (%d), skb->len:%u\n",
+                        hw_rxhdr->flags_vif_idx, skb->len);
                 dev_kfree_skb(skb);
                 goto end;
             }
@@ -2176,71 +2445,168 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
             skb->priority = 256 + tid;//hw_rxhdr->flags_user_prio;
 
 #ifdef AICWF_RX_REORDER
-	     rx_priv_tmp = rx_priv;
+            rx_priv_tmp = rx_priv;
             rx_priv_tmp->rwnx_vif = (void *)rwnx_vif;
 
-	    if( (rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ){
-            if(is_qos && hw_rxhdr->flags_need_reord){
-                reord_process_unit((struct aicwf_rx_priv *)rx_priv, skb, seq_num, tid, 1);
-            }else if(is_qos  && !hw_rxhdr->flags_need_reord) {
-                 reord_flush_tid((struct aicwf_rx_priv *)rx_priv, skb, tid);
-                if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr))
-                    dev_kfree_skb(skb);
-            }
-            else {
-                if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr))
-                    dev_kfree_skb(skb);
-            }
-	    } else if( (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) ) {
-                #if 1
-                const struct ethhdr *eth;
-                resend = false;
-				forward = true;
-                skb_reset_mac_header(skb);
-                eth = eth_hdr(skb);
-                //printk("da:%pM, %x,%x, len=%d\n", eth->h_dest, skb->data[12], skb->data[13], skb->len);
-
-                if (unlikely(is_multicast_ether_addr(eth->h_dest))) {
-                    /* broadcast pkt need to be forwared to upper layer and resent
-                       on wireless interface */
-                    resend = true;
+    	    if( (rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ){
+                if(is_qos && hw_rxhdr->flags_need_reord){
+    				struct recv_msdu *pframe;
+    				pframe = reord_rxframe_alloc(&rx_priv_tmp->freeq_lock, &rx_priv_tmp->rxframes_freequeue);
+    				if (!pframe) {
+                        printk("no pframe\n");
+    					dev_kfree_skb(skb);
+    					return -1;
+    				}
+    				pframe->is_ap_reord = 0;
+    				pframe->ap_fwd_cnt = 0;
+    				pframe->ap_resend_cnt = 0;
+    				reord_process_unit(pframe, (struct aicwf_rx_priv *)rx_priv, skb, seq_num, tid, 1, hw_rxhdr->flags_is_amsdu);
+                } else if (is_qos  && !hw_rxhdr->flags_need_reord) {
+                    reord_flush_tid((struct aicwf_rx_priv *)rx_priv, skb, tid);
+                    if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr) && !hw_rxhdr->flags_is_amsdu)
+                        dev_kfree_skb(skb);
                 } else {
-                    /* unicast pkt for STA inside the BSS, no need to forward to upper
-                       layer simply resend on wireless interface */
-                    if (hw_rxhdr->flags_dst_idx != RWNX_INVALID_STA) {
-                        struct rwnx_sta *sta = &rwnx_hw->sta_table[hw_rxhdr->flags_dst_idx];
-                        if (sta->valid && (sta->vlan_idx == rwnx_vif->vif_index)) {
-                            resend = true;
-                            forward = false;
-                        }
-                    }
+                    if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr) && !hw_rxhdr->flags_is_amsdu)
+                        dev_kfree_skb(skb);
                 }
+	        } else if( (rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) ) {
+				struct sk_buff_head list;
+				struct sk_buff *rx_skb;
+				u8 flags_dst_idx = hw_rxhdr->flags_dst_idx;
+				u8 flags_need_reord = hw_rxhdr->flags_need_reord;
+				u8 flags_vif_idx = hw_rxhdr->flags_vif_idx;
+                u8 flags_is_amsdu = hw_rxhdr->flags_is_amsdu;
+				u8 reord_cnt = 0;
+				struct recv_msdu *pframe = NULL;
+
+				__skb_queue_head_init(&list);
+
+                //printk("dst_idx=%d, len=%d\n", flags_dst_idx, skb->len);
+				if (flags_is_amsdu) {
+					rwnx_rxdata_process_amsdu(rwnx_hw, skb, flags_vif_idx, &list); //rxhdr not used below since skb free!
+				} else {
+					rwnx_hw->stats.amsdus_rx[0]++;
+					__skb_queue_head(&list, skb);
+				}
+
+				while (!skb_queue_empty(&list)) {
+					rx_skb = __skb_dequeue(&list);
+
+					skb_reset_mac_header(rx_skb);
+					eth = eth_hdr(rx_skb);
+					//printk("da:%pM, %x,%x, len=%d\n", eth->h_dest, skb->data[12], skb->data[13], skb->len);
+
+                    resend = false;
+                    forward = true;
+					if (unlikely(is_multicast_ether_addr(eth->h_dest))) {
+					/* broadcast pkt need to be forwared to upper layer and resent
+					   on wireless interface */
+						resend = true;
+					} else {
+						/* unicast pkt for STA inside the BSS, no need to forward to upper
+						   layer simply resend on wireless interface */
+						if ((flags_dst_idx != RWNX_INVALID_STA) && !flags_is_amsdu) {
+							struct rwnx_sta *sta = &rwnx_hw->sta_table[flags_dst_idx];
+							if (sta->valid && (sta->vlan_idx == rwnx_vif->vif_index)) {
+								resend = true;
+								forward = false;
+							}
+						} else {
+                            struct rwnx_sta *cur, *tmp;
+                            bool found = false;
+                            spin_lock_bh(&rwnx_hw->cb_lock);
+                            list_for_each_entry_safe(cur, tmp, &rwnx_vif->ap.sta_list, list) {
+                                if (!memcmp(cur->mac_addr, eth->h_dest, ETH_ALEN)) {
+                                    found = true;
+                                    break;
+                                }
+                            }
+                            spin_unlock_bh(&rwnx_hw->cb_lock);
+                            if(found) {
+                                //printk("amsdu found da\n");
+                                resend = true;
+                                forward = false;
+                            }
+                        }
+					}
 
                 if(resend){
-                    rwnx_rx_data_skb_resend(rwnx_hw, rwnx_vif, skb, hw_rxhdr);
+					rwnx_rx_data_skb_resend(rwnx_hw, rwnx_vif, rx_skb);
                 }
 
                 if(forward) {
-                    if (is_qos && hw_rxhdr->flags_need_reord)
-                        reord_process_unit((struct aicwf_rx_priv *)rx_priv, skb, seq_num, tid, 1);
-                    else if (is_qos  && !hw_rxhdr->flags_need_reord) {
-                        reord_flush_tid((struct aicwf_rx_priv *)rx_priv, skb, tid);
-                        rwnx_rx_data_skb_forward(rwnx_hw, rwnx_vif, skb, hw_rxhdr);
+					if (is_qos && flags_need_reord) {
+						if(pframe == NULL) {
+							pframe = reord_rxframe_alloc(&rx_priv_tmp->freeq_lock, &rx_priv_tmp->rxframes_freequeue);
+							if (!pframe) {
+								dev_kfree_skb(rx_skb);
+								return -1;
+							}
+                            rx_skb->next = NULL;
+							pframe->ap_fwd_cnt = 1;
+							pframe->ap_resend_cnt = 0;
+							pframe->first_fwd_skb = rx_skb;
+						    pframe->last_fwd_skb = rx_skb;
+ 							pframe->first_resend_skb = NULL;
+ 							pframe->last_resend_skb = NULL;
+						} else {
+							rx_skb->next = NULL;
+							pframe->ap_fwd_cnt++;
+							if(pframe->first_fwd_skb == NULL) {
+								pframe->first_fwd_skb = rx_skb;
+								pframe->last_fwd_skb = rx_skb;
+							} else {
+								pframe->last_fwd_skb->next = rx_skb;
+								pframe->last_fwd_skb = rx_skb;
+							}
+						}
+					} else if (is_qos  && !flags_need_reord) {
+                        reord_flush_tid((struct aicwf_rx_priv *)rx_priv, rx_skb, tid);
+                        rwnx_rx_data_skb_forward(rwnx_hw, rwnx_vif, rx_skb);
                     } else
-                        rwnx_rx_data_skb_forward(rwnx_hw, rwnx_vif, skb, hw_rxhdr);
+                        rwnx_rx_data_skb_forward(rwnx_hw, rwnx_vif, rx_skb);
                 } else if(resend) {
-					if (is_qos && hw_rxhdr->flags_need_reord)
-						reord_process_unit((struct aicwf_rx_priv *)rx_priv, skb, seq_num, tid, 0);
-					else if (is_qos  && !hw_rxhdr->flags_need_reord) {
-						reord_flush_tid((struct aicwf_rx_priv *)rx_priv, skb, tid);
-						dev_kfree_skb(skb);
-					}
+					if (is_qos && flags_need_reord) {
+							if(pframe == NULL) {
+								pframe = reord_rxframe_alloc(&rx_priv_tmp->freeq_lock, &rx_priv_tmp->rxframes_freequeue);
+								if (!pframe) {
+									dev_kfree_skb(rx_skb);
+									return -1;
+								}
+                                rx_skb->next = NULL;
+								pframe->ap_fwd_cnt = 0;
+								pframe->ap_resend_cnt = 1;
+								pframe->first_fwd_skb = NULL;
+								pframe->last_fwd_skb = NULL;
+								pframe->first_resend_skb = rx_skb;
+								pframe->last_resend_skb = rx_skb;
+							} else {
+								rx_skb->next = NULL;
+								pframe->ap_resend_cnt++;
+								if(pframe->first_resend_skb == NULL) {
+									pframe->first_resend_skb = rx_skb;
+									pframe->last_resend_skb = rx_skb;
+								} else {
+									pframe->last_resend_skb->next = rx_skb;
+									pframe->last_resend_skb = rx_skb;
+								}
+							}
+						}
+					else if (is_qos  && !flags_need_reord) {
+							if(!reord_flush_tid((struct aicwf_rx_priv *)rx_priv, rx_skb, tid))
+								dev_kfree_skb(rx_skb);
+						} else {
+							dev_kfree_skb(rx_skb);
+						}
 				} else
-                    dev_kfree_skb(skb);
-                #else
-                if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr))
-					dev_kfree_skb(skb);
-                #endif
+                    dev_kfree_skb(rx_skb);
+				}
+
+				if(pframe != NULL) {
+					pframe->is_ap_reord = 1;
+                    //printk("reord:%d,%d\n", pframe->ap_fwd_cnt, pframe->ap_resend_cnt);
+					reord_process_unit(pframe, (struct aicwf_rx_priv *)rx_priv, rx_skb, seq_num, tid, 0, 0);
+				}
 			}
 #else
             if (!rwnx_rx_data_skb(rwnx_hw, rwnx_vif, skb, hw_rxhdr))
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
index e5480cdc9..e7e71f62c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
@@ -326,8 +326,12 @@ struct hw_rxhdr {
     u32    pattern;
 };
 
-extern const u8 legrates_lut[];
-extern u16 legrates_lut_rate[];
+struct rwnx_legrate {
+	int idx;
+	int rate;
+};
+
+extern struct rwnx_legrate legrates_lut[];
 extern u16 tx_legrates_lut_rate[];
 
 struct DHCPInfo {
@@ -376,6 +380,8 @@ void reord_timeout_handler (struct timer_list *t);
 #endif
 
 #endif
+void rwnx_rxdata_process_amsdu(struct rwnx_hw *rwnx_hw, struct sk_buff *skb, u8 vif_idx,
+                                        struct sk_buff_head *list);
 
 #ifdef CONFIG_HE_FOR_OLD_KERNEL
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 197)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
index 689fb9a85..d7b9a403f 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -677,7 +677,14 @@ void rwnx_tx_push(struct rwnx_hw *rwnx_hw, struct rwnx_txhdr *txhdr, int flags)
         sw_txhdr->need_cfm = 1;
         sw_txhdr->desc.host.status_desc_addr = ((1<<31) | rwnx_hw->usb_env.txdesc_free_idx[0]);
         aicwf_usb_host_txdesc_push(&(rwnx_hw->usb_env), 0, (long)(skb));
-        AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p sta_idx:%d\n", 
+        if((sw_txhdr->desc.host.flags & TXU_CNTRL_MGMT))
+		AICWFDBG(LOGINFO, "need cfm mgmt:%x,user_idx=%d, skb=%p sta_idx:%d\n",
+			*(skb->data+sw_txhdr->headroom),
+			rwnx_hw->usb_env.txdesc_free_idx[0],
+			skb,
+			sw_txhdr->desc.host.staid);
+	else
+		AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p sta_idx:%d\n",
 			sw_txhdr->desc.host.ethertype, 
 			rwnx_hw->usb_env.txdesc_free_idx[0], 
 			skb,
@@ -1324,6 +1331,9 @@ int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
 	sw_txhdr->amsdu.len = 0;
 	sw_txhdr->amsdu.nb = 0;
 #endif
+	sw_txhdr->raw_frame = 0;
+	sw_txhdr->fixed_rate = 0;
+
 	// Fill-in the descriptor
 	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
 	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
@@ -1380,7 +1390,7 @@ int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
 	desc->host.packet_addr = sw_txhdr->dma_addr + frame_oft;
 #endif
 #endif
-	//desc->host.hostid = sw_txhdr->dma_addr;
+	desc->host.status_desc_addr = sw_txhdr->dma_addr;
 
 	spin_lock_bh(&rwnx_hw->tx_lock);
 	if (rwnx_txq_queue_skb(skb, txq, rwnx_hw, false))
@@ -1452,7 +1462,11 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
         skb = newskb;
     }
 
+	if(skb->priority < 3)
+		skb->priority = 0;
+
 #ifdef CONFIG_FILTER_TCP_ACK
+	if(cpu_to_le16(skb->len) <= MAX_TCP_ACK){
         msgbuf=intf_tcp_alloc_msg(msgbuf);
         msgbuf->rwnx_vif=rwnx_vif;
         msgbuf->skb=skb;
@@ -1462,6 +1476,7 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
             move_tcpack_msg(rwnx_hw,msgbuf);
             kfree(msgbuf);
         }
+	}
 #endif
     memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
 
@@ -1863,11 +1878,11 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
     int nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX;
 
     rtap_hdr = (struct ieee80211_radiotap_header*)(rtap_buf);
-    rtap_len = ieee80211_get_radiotap_len(rtap_buf);
+    rtap_len = ieee80211_get_radiotap_len(rtap_buf);//max_length
     frame_len = skb->len;
 
-    printk("rwnx_start_monitor_if_xmit, skb_len=%d, rtap_len=%d\n", skb->len, rtap_len);
-
+    AICWFDBG(LOGINFO, "rwnx_start_monitor_if_xmit, skb_len=%d, rtap_len=%d\n", skb->len, rtap_len);
+//rwnx_data_dump((char*)__func__, skb->data, skb->len);
     if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
         g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
@@ -1875,14 +1890,20 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
     }
 
 
-    if (unlikely(rtap_hdr->it_version))
+    if (unlikely(rtap_hdr->it_version)){
+        AICWFDBG(LOGERROR, "%s itv \r\n", __func__);
         goto free_tag;
+        }
 
-    if (unlikely(skb->len < rtap_len))
+    if (unlikely(skb->len < rtap_len)){
+        AICWFDBG(LOGERROR, "%s skb->len < rtap_len \r\n", __func__);
         goto free_tag;
+        }
 
-    if (unlikely(rtap_len < sizeof(struct ieee80211_radiotap_header)))
+    if (unlikely(rtap_len < sizeof(struct ieee80211_radiotap_header))){
+        AICWFDBG(LOGERROR, "%s rtap_len < sizeof(struct ieee80211_radiotap_header) \r\n", __func__);
         goto free_tag;
+        }
 
     frame_len -= rtap_len;
     pframe = rtap_buf + rtap_len;
@@ -1894,39 +1915,44 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
         if (ret) {
             continue;
         }
+        AICWFDBG(LOGDEBUG, "%s iterator.this_arg_index:%d iterator.this_arg:%x\r\n", __func__, 
+            iterator.this_arg_index, *iterator.this_arg);
         switch (iterator.this_arg_index) {
             case IEEE80211_RADIOTAP_RATE:
                 // This is basic 802.11b/g rate; use MCS/VHT for higher rates
                 rate = *iterator.this_arg;
-                printk("rate=0x%x\n", rate);
+                AICWFDBG(LOGDEBUG, "rate=0x%x\n", rate);
                 for (idx = 0; idx < HW_RATE_MAX; idx++) {
                     if ((rate * 5) == tx_legrates_lut_rate[idx]) {
+                        AICWFDBG(LOGDEBUG, "%s datarate:%d \r\n", __func__, tx_legrates_lut_rate[idx]);
                         break;
                     }
                 }
+                
                 if (idx < HW_RATE_MAX) {
                     rate_idx = idx;
+                    AICWFDBG(LOGDEBUG, "rate_idx = %d \r\n", rate_idx);
                 } else {
-                    printk("invalid radiotap rate: %d\n", rate);
+                    AICWFDBG(LOGERROR, "invalid radiotap rate: %d\n", rate);
                 }
                 break;
 
             case IEEE80211_RADIOTAP_TX_FLAGS: {
                 u16_l txflags = get_unaligned_le16(iterator.this_arg);
-                printk("txflags=0x%x\n", txflags);
+                AICWFDBG(LOGDEBUG, "txflags=0x%x\n", txflags);
                 if ((txflags & IEEE80211_RADIOTAP_F_TX_NOACK) == 0) {
-                    printk("  TX_NOACK\n");
+                    AICWFDBG(LOGDEBUG, "  TX_NOACK\n");
                 }
                 if (txflags & 0x0010) { // Use preconfigured seq num
                     // NOTE: this is currently ignored due to qos_en=_FALSE and HW seq num override
-                    printk("  GetSequence\n");
+                    AICWFDBG(LOGDEBUG, "  GetSequence\n");
                 }
             }
             break;
 
             case IEEE80211_RADIOTAP_MCS: {
                 u8_l mcs_have = iterator.this_arg[0];
-                printk("mcs_have=0x%x\n", mcs_have);
+                AICWFDBG(LOGDEBUG, "mcs_have=0x%x\n", mcs_have);
                 rate_fmt = FORMATMOD_HT_MF;
                 if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_BW) {
                     u8_l bw = (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_BW_MASK);
@@ -1940,7 +1966,7 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
                         bw = IEEE80211_RADIOTAP_MCS_BW_20;
                         ch_offset = 2; // CHNL_OFFSET_UPPER;
                     }
-                    printk("  bw=%d, ch_offset=%d\n", bw, ch_offset);
+                    AICWFDBG(LOGDEBUG, "  bw=%d, ch_offset=%d\n", bw, ch_offset);
                 }
                 if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_MCS) {
                     u8_l fixed_rate = iterator.this_arg[2] & 0x7f;
@@ -1948,17 +1974,17 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
                         fixed_rate = 0;
                     }
                     rate_idx = fixed_rate;
-                    printk("  fixed_rate=0x%x\n", fixed_rate);
+                    AICWFDBG(LOGDEBUG, "  fixed_rate=0x%x\n", fixed_rate);
                 }
                 if ((mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_GI) && (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_SGI)) {
-                    printk("  sgi\n");
+                    AICWFDBG(LOGDEBUG, "  sgi\n");
                 }
                 if ((mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_FEC) && (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_FEC_LDPC)) {
-                    printk("  ldpc\n");
+                    AICWFDBG(LOGDEBUG, "  ldpc\n");
                 }
                 if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
                     u8 stbc = (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_STBC_MASK) >> IEEE80211_RADIOTAP_MCS_STBC_SHIFT;
-                    printk("  stbc=0x%x\n", stbc);
+                    AICWFDBG(LOGDEBUG, "  stbc=0x%x\n", stbc);
                 }
             }
             break;
@@ -1968,17 +1994,17 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
                 u8 known = iterator.this_arg[0];
                 u8 flags = iterator.this_arg[2];
                 rate_fmt = FORMATMOD_VHT;
-                printk("known=0x%x, flags=0x%x\n", known, flags);
+                AICWFDBG(LOGDEBUG, "known=0x%x, flags=0x%x\n", known, flags);
                 // NOTE: this code currently only supports 1SS for radiotap defined rates
                 if ((known & IEEE80211_RADIOTAP_VHT_KNOWN_STBC) && (flags & IEEE80211_RADIOTAP_VHT_FLAG_STBC)) {
-                    printk("  stbc\n");
+                    AICWFDBG(LOGDEBUG, "  stbc\n");
                 }
                 if ((known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) && (flags & IEEE80211_RADIOTAP_VHT_FLAG_SGI)) {
-                    printk("  sgi\n");
+                    AICWFDBG(LOGDEBUG, "  sgi\n");
                 }
                 if (known & IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {
                     u8_l bw = iterator.this_arg[3] & 0x1F;
-                    printk("  bw=0x%x\n",bw);
+                    AICWFDBG(LOGDEBUG, "  bw=0x%x\n",bw);
                     // NOTE: there are various L and U, but we just use straight 20/40/80
                     // since it's not clear how to set CHNL_OFFSET_LOWER/_UPPER with different
                     // sideband sizes/configurations.  TODO.
@@ -1986,26 +2012,26 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
                     txsig_bw = PHY_CHNL_BW_40;
                     if (bw == 0) {
                         txsig_bw = PHY_CHNL_BW_20;
-                        printk("  20M\n");
+                        AICWFDBG(LOGDEBUG, "  20M\n");
                     } else if (bw >=1 && bw <= 3) {
-                        printk("  40M\n");
+                        AICWFDBG(LOGDEBUG, "  40M\n");
                     } else if (bw >=4 && bw <= 10) {
-                        printk("  80M\n");
+                        AICWFDBG(LOGDEBUG, "  80M\n");
                     } else if (bw >= 11 && bw <= 25) {
-                        printk("  160M\n");
+                        AICWFDBG(LOGDEBUG, "  160M\n");
                     }
                 }
                 // User 0
                 nss = iterator.this_arg[4] & 0x0F; // Number of spatial streams
-                printk("  nss=0x%x\n", nss);
+                AICWFDBG(LOGINFO, "  nss=0x%x\n", nss);
                 if (nss > 0) {
                     if (nss > 4) nss = 4;
                     mcs = (iterator.this_arg[4]>>4) & 0x0F; // MCS rate index
                     if (mcs > 8) mcs = 9;
                     rate_idx = mcs;
-                    printk("    mcs=0x%x\n", mcs);
+                    AICWFDBG(LOGDEBUG, "    mcs=0x%x\n", mcs);
                     if (iterator.this_arg[8] & IEEE80211_RADIOTAP_CODING_LDPC_USER0) {
-                        printk("    ldpc\n");
+                        AICWFDBG(LOGDEBUG, "    ldpc\n");
                     }
                 }
             }
@@ -2035,13 +2061,13 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
                 }
                 if (data2 & IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN) {
                     u8 gi = (data5 & IEEE80211_RADIOTAP_HE_DATA5_GI) >> 4;
-                    printk("  gi: %d\n", gi);
+                    AICWFDBG(LOGDEBUG, "  gi: %d\n", gi);
                 }
             }
             break;
 
             default:
-                printk("unparsed arg: 0x%x\n",iterator.this_arg_index);
+                AICWFDBG(LOGERROR, "unparsed arg: 0x%x\n",iterator.this_arg_index);
                 break;
         }
     }
@@ -2076,14 +2102,14 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
             txq = rwnx_txq_vif_get(vif, NX_UNK_TXQ_TYPE);
     }
     if (txq->idx == TXQ_INACTIVE) {
-        printk("TXQ_INACTIVE\n");
+        AICWFDBG(LOGERROR, "TXQ_INACTIVE\n");
         goto free_tag;
     }
     // prepare to xmit
     headroom = sizeof(struct rwnx_txhdr);
     skb_mgmt = dev_alloc_skb(headroom + frame_len);
     if (!skb_mgmt) {
-        printk("skb_mgmt alloc fail\n");
+        AICWFDBG(LOGERROR, "skb_mgmt alloc fail\n");
         goto free_tag;
     }
     skb_reserve(skb_mgmt, headroom);
@@ -2105,7 +2131,7 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
     sw_txhdr = kmem_cache_alloc(rwnx_hw->sw_txhdr_cache, GFP_ATOMIC);
     if (unlikely(sw_txhdr == NULL)) {
         dev_kfree_skb(skb_mgmt);
-        printk("sw_txhdr alloc fail\n");
+        AICWFDBG(LOGERROR, "sw_txhdr alloc fail\n");
         goto free_tag;
     }
     txhdr->sw_hdr = sw_txhdr;
@@ -2147,6 +2173,7 @@ netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *d
     desc->host.status_desc_addr = sw_txhdr->dma_addr;
 
     spin_lock_bh(&rwnx_hw->tx_lock);
+    AICWFDBG(LOGTRACE, "%s send data\r\n", __func__);
     if (rwnx_txq_queue_skb(skb_mgmt, txq, rwnx_hw, false))
         rwnx_hwq_process(rwnx_hw, txq->hwq);
     spin_unlock_bh(&rwnx_hw->tx_lock);
@@ -2285,8 +2312,9 @@ int rwnx_txdatacfm(void *pthis, void *host_id)
     }
 #endif /* CONFIG_RWNX_AMSDUS_TX */
 
+    headroom = sw_txhdr->headroom;
     kmem_cache_free(rwnx_hw->sw_txhdr_cache, sw_txhdr);
-    skb_pull(skb, sw_txhdr->headroom);
+    skb_pull(skb, headroom);
     consume_skb(skb);
 
     return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index 101cc24de..01cbe90ec 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,5 +1,5 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_1212_15dcf017"
+#define RELEASE_DATE "2024_1119_06da8476"
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
new file mode 100644
index 000000000..90e7ad872
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
@@ -0,0 +1,92 @@
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+#include <linux/pm_wakeirq.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include "rwnx_defs.h"
+#include "rwnx_wakelock.h"
+
+struct wakeup_source *rwnx_wakeup_init(const char *name)
+{
+	struct wakeup_source *ws;
+	ws = wakeup_source_create(name);
+	wakeup_source_add(ws);
+	return ws;
+}
+
+void rwnx_wakeup_deinit(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_remove(ws);
+	wakeup_source_destroy(ws);
+}
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name)
+{
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+	return wakeup_source_register(dev, name);
+#else
+
+#if defined(CONFIG_PLATFORM_ROCKCHIP2) || defined(CONFIG_PLATFORM_ROCKCHIP)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+    return wakeup_source_register(dev, name);
+#else
+    return wakeup_source_register(name);
+#endif
+
+#else
+	return wakeup_source_register(name);
+#endif//#if defined(CONFIG_PLATFORM_ROCKCHIP2) || defined(CONFIG_PLATFORM_ROCKCHIP)
+
+#endif//LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+}
+
+void rwnx_wakeup_unregister(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_unregister(ws);
+}
+
+void rwnx_wakeup_lock(struct wakeup_source *ws)
+{
+    AICWFDBG(LOGDEBUG, "%s enter \r\n", __func__);
+	__pm_stay_awake(ws);
+}
+
+void rwnx_wakeup_unlock(struct wakeup_source *ws)
+{
+    AICWFDBG(LOGDEBUG, "%s enter \r\n", __func__);
+	__pm_relax(ws);
+}
+
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec)
+{
+	__pm_wakeup_event(ws, msec);
+}
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_hw->ws_tx = rwnx_wakeup_init("rwnx_tx_wakelock");
+	rwnx_hw->ws_rx = rwnx_wakeup_init("rwnx_rx_wakelock");
+    rwnx_hw->ws_irqrx = rwnx_wakeup_init("rwnx_irqrx_wakelock");
+	rwnx_hw->ws_pwrctrl = rwnx_wakeup_init("rwnx_pwrcrl_wakelock");
+}
+
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_wakeup_deinit(rwnx_hw->ws_tx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_rx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_irqrx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_pwrctrl);
+	rwnx_hw->ws_tx = NULL;
+	rwnx_hw->ws_rx = NULL;
+	rwnx_hw->ws_irqrx = NULL;
+	rwnx_hw->ws_pwrctrl = NULL;
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
new file mode 100644
index 000000000..9c9655a46
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
@@ -0,0 +1,21 @@
+#ifndef __RWNX_WAKELOCK_H
+#define __RWNX_WAKELOCK_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+
+struct wakeup_source *rwnx_wakeup_init(const char *name);
+void rwnx_wakeup_deinit(struct wakeup_source *ws);
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name);
+void rwnx_wakeup_unregister(struct wakeup_source *ws);
+
+void rwnx_wakeup_lock(struct wakeup_source *ws);
+void rwnx_wakeup_unlock(struct wakeup_source *ws);
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec);
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw);
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/Makefile b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
index f3cfac534..482318c18 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/Makefile
+++ b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
@@ -5,15 +5,21 @@ CONFIG_USB_MSG_EP = y
 CONFIG_USB_NO_TRANS_DMA_MAP = n
 CONFIG_M2D_OTA_AUTO_SUPPORT = n
 CONFIG_LINK_DET_5G = y
+CONFIG_FOR_IPCAM = n
+CONFIG_USB_SUSPEND_REBOOT_TIME = n
+CONFIG_SUPPORT_USB_SUSP = n
+
+
 # Need to set fw path in BOARD_KERNEL_CMDLINE
-CONFIG_USE_FW_REQUEST = n
-CONFIG_PREALLOC_RX_SKB = n
-CONFIG_PREALLOC_TXQ = y
+CONFIG_USE_FW_REQUEST ?= n
+CONFIG_PREALLOC_RX_SKB ?= n
+CONFIG_PREALLOC_TXQ ?= y
 
 # Platform support list
 CONFIG_PLATFORM_ROCKCHIP ?= n
 CONFIG_PLATFORM_ALLWINNER ?= n
 CONFIG_PLATFORM_AMLOGIC ?= n
+CONFIG_PLATFORM_HI ?= n
 CONFIG_PLATFORM_UBUNTU ?= y
 
 CONFIG_AIC_LOADFW_SUPPORT = m
@@ -30,9 +36,12 @@ ccflags-$(CONFIG_USB_MSG_EP) += -DCONFIG_USB_MSG_EP
 ccflags-$(CONFIG_USB_NO_TRANS_DMA_MAP) += -DCONFIG_USB_NO_TRANS_DMA_MAP
 ccflags-$(CONFIG_M2D_OTA_AUTO_SUPPORT) += -DCONFIG_M2D_OTA_AUTO_SUPPORT
 ccflags-$(CONFIG_LINK_DET_5G) += -DCONFIG_LINK_DET_5G
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
 ccflags-$(CONFIG_PREALLOC_RX_SKB) += -DCONFIG_PREALLOC_RX_SKB
 ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
+ccflags-$(CONFIG_USB_SUSPEND_REBOOT_TIME) += -DCONFIG_USB_SUSPEND_REBOOT_TIME
+ccflags-$(CONFIG_SUPPORT_USB_SUSP) += -DCONFIG_SUPPORT_USB_SUSP
 
 
 obj-$(CONFIG_AIC_LOADFW_SUPPORT) := $(MODULE_NAME).o
@@ -42,6 +51,7 @@ $(MODULE_NAME)-y := 	aic_bluetooth_main.o \
 					aic_txrxif.o \
 					aicbluetooth_cmds.o \
 					aic_compat_8800d80.o \
+					aic_compat_8800d80x2.o \
 					md5.o
 
 $(MODULE_NAME)-$(CONFIG_PREALLOC_RX_SKB)	 += aicwf_rx_prealloc.o
@@ -83,7 +93,8 @@ KDIR  := /lib/modules/$(shell uname -r)/build
 PWD   := $(shell pwd)
 KVER := $(shell uname -r)
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH := x86_64
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE :=
 endif
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
index 9d1442d2d..be05052bb 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
@@ -1,81 +1,81 @@
-#include <linux/module.h>
-#include <linux/inetdevice.h>
-#include <linux/version.h>
-
-#include "aicwf_usb.h"
-#include "rwnx_version_gen.h"
-#include "aicwf_rx_prealloc.h"
-#include "aicwf_debug.h"
-#include "aicwf_txq_prealloc.h"
-
-
-#define DRV_CONFIG_FW_NAME             "fw.bin"
-#define DRV_DESCRIPTION  "AIC BLUETOOTH"
-#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
-#define DRV_AUTHOR       "AICSemi"
-#define DRV_VERS_MOD "1.0"
-
-int testmode = FW_NORMAL_MODE;
-int adap_test = 0;
-char paringid[100];
-int n_para = 1;
-int ble_scan_wakeup_reboot_time = 1000;
-int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
-int flash_erase_len = 0x400000;
-uint32_t ad_data_filter_mask = 0;
-uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
-uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
-
-module_param(aicwf_dbg_level, int, 0660);
-module_param(ble_scan_wakeup_reboot_time, int, 0660);
-module_param(testmode, int, 0660);
-module_param(adap_test, int, 0660);
-module_param_string(paringid, paringid, 100, 0660);
-module_param(flash_erase_len, int, 0660);
-
-
-static void aicsmac_driver_register(void)
-{
-    aicwf_usb_register();
-}
-
-static int __init aic_bluetooth_mod_init(void)
-{
-    printk("%s \n", __func__);
-    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_init();
-#endif
-
-    aicsmac_driver_register();
-    return 0;
-}
-
-static void __exit aic_bluetooth_mod_exit(void)
-{
-    printk("%s\n", __func__);
-    aicwf_usb_exit();
-    
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_exit();
-#endif
-
-#ifdef CONFIG_PREALLOC_TXQ
-    aicwf_prealloc_txq_free();
-#endif
-}
-
-
-module_init(aic_bluetooth_mod_init);
-module_exit(aic_bluetooth_mod_exit);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
-MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
-#endif
-
-MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
-MODULE_DESCRIPTION(DRV_DESCRIPTION);
-MODULE_VERSION(DRV_VERS_MOD);
-MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
-MODULE_LICENSE("GPL");
-
+#include <linux/module.h>
+#include <linux/inetdevice.h>
+#include <linux/version.h>
+
+#include "aicwf_usb.h"
+#include "rwnx_version_gen.h"
+#include "aicwf_rx_prealloc.h"
+#include "aicwf_debug.h"
+#include "aicwf_txq_prealloc.h"
+
+
+#define DRV_CONFIG_FW_NAME             "fw.bin"
+#define DRV_DESCRIPTION  "AIC BLUETOOTH"
+#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
+#define DRV_AUTHOR       "AICSemi"
+#define DRV_VERS_MOD "1.0"
+
+int testmode = FW_NORMAL_MODE;
+int adap_test = 0;
+char paringid[100];
+int n_para = 1;
+int ble_scan_wakeup_reboot_time = 1000;
+int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
+int flash_erase_len = 0x400000;
+uint32_t ad_data_filter_mask = 0;
+uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
+uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
+
+module_param(aicwf_dbg_level, int, 0660);
+module_param(ble_scan_wakeup_reboot_time, int, 0660);
+module_param(testmode, int, 0660);
+module_param(adap_test, int, 0660);
+module_param_string(paringid, paringid, 100, 0660);
+module_param(flash_erase_len, int, 0660);
+
+
+static void aicsmac_driver_register(void)
+{
+    aicwf_usb_register();
+}
+
+static int __init aic_bluetooth_mod_init(void)
+{
+    printk("%s \n", __func__);
+    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_init();
+#endif
+
+    aicsmac_driver_register();
+    return 0;
+}
+
+static void __exit aic_bluetooth_mod_exit(void)
+{
+    printk("%s\n", __func__);
+    aicwf_usb_exit();
+    
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_exit();
+#endif
+
+#ifdef CONFIG_PREALLOC_TXQ
+    aicwf_prealloc_txq_free();
+#endif
+}
+
+
+module_init(aic_bluetooth_mod_init);
+module_exit(aic_bluetooth_mod_exit);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_VERSION(DRV_VERS_MOD);
+MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
index b1859370a..65eb6e832 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
@@ -16,8 +16,8 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size);
 void rwnx_release_firmware_common(u32** buffer);
 
 extern int testmode;
-extern int chip_id;
-u8 chip_mcu_id = 0;
+extern u8 chip_id;
+extern u8 chip_mcu_id;
 
 typedef u32 (*array2_tbl_t)[2];
 
@@ -39,6 +39,16 @@ typedef struct {
 #define AIC_PATCH_OFST(mem) ((size_t) &((aic_patch_t *)0)->mem)
 #define AIC_PATCH_ADDR(mem) ((u32) (aic_patch_str_base + AIC_PATCH_OFST(mem)))
 
+#define USER_PWROFST_COVER_CALIB_FLAG	0x01U
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+#define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
+
+#define CFG_PWROFST_COVER_CALIB     1
+#define CFG_USER_CHAN_MAX_TXPWR_EN  1
+#define CFG_USER_TX_USE_ANA_F       0
+
+#define CFG_USER_EXT_FLAGS_EN   (CFG_PWROFST_COVER_CALIB || CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
+
 u32 patch_tbl_d80[][2] =
 {
     #ifdef USE_5G
@@ -46,7 +56,25 @@ u32 patch_tbl_d80[][2] =
     #else
     {0x00b4, 0xf3010000},
     #endif
-    {0x0170, 0x00000001},//rx aggr counter
+#ifdef CONFIG_PLATFORM_HI
+    {0x0170, 0x00010001},//rx aggr counter
+#else
+    {0x0170, 0x0001000A},//rx aggr counter
+#endif
+
+    #if CFG_USER_EXT_FLAGS_EN
+    {0x0188, 0x00000000
+	#if CFG_PWROFST_COVER_CALIB
+	| USER_PWROFST_COVER_CALIB_FLAG
+	#endif
+        #if CFG_USER_CHAN_MAX_TXPWR_EN
+        | USER_CHAN_MAX_TXPWR_EN_FLAG
+        #endif
+        #if CFG_USER_TX_USE_ANA_F
+        | USER_TX_USE_ANA_F_FLAG
+        #endif
+    }, // user_ext_flags
+    #endif
 };
 
 //adap test
@@ -67,11 +95,16 @@ u32 syscfg_tbl_8800d80[][2] = {
 
 extern int adap_test;
 
+#define NEW_PATCH_BUFFER_MAP    1
+
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
 {
     u32 rd_patch_addr;
     u32 aic_patch_addr;
     u32 config_base, aic_patch_str_base;
+    #if (NEW_PATCH_BUFFER_MAP)
+    u32 patch_buff_addr, patch_buff_base, rd_version_addr, rd_version_val;
+    #endif
     uint32_t start_addr = 0x001D7000;
     u32 patch_addr = start_addr;
     u32 patch_cnt = sizeof(patch_tbl_d80) / 4 / 2;
@@ -108,6 +141,32 @@ int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
     AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
     aic_patch_str_base = rd_patch_addr_cfm.memdata;
 
+    #if (NEW_PATCH_BUFFER_MAP)
+    if (chip_id == CHIP_REV_U01) {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80 + 0x01C;
+    } else {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80_U02 + 0x01C;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_version_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "version val[0x%x] rd fail: %d\n", rd_version_addr, ret);
+        return ret;
+    }
+    rd_version_val = rd_patch_addr_cfm.memdata;
+    AICWFDBG(LOGINFO, "rd_version_val=%08X\n", rd_version_val);
+    usb_dev->fw_version_uint = rd_version_val;
+    if (rd_version_val > 0x06090100) {
+        patch_buff_addr = rd_patch_addr + 12;
+        ret = rwnx_send_dbg_mem_read_req(usb_dev, patch_buff_addr, &rd_patch_addr_cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "patch buf rd fail\n");
+            return ret;
+        }
+        AICWFDBG(LOGINFO, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+        patch_buff_base = rd_patch_addr_cfm.memdata;
+        patch_addr = start_addr = patch_buff_base;
+    }
+    #endif
+
     if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num), AIC_PATCH_MAGIG_NUM))) {
         AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num), ret);
         return ret;
@@ -260,6 +319,38 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 }
 
 
+static int aicbt_ext_patch_data_load(struct aic_usb_dev *usb_dev, struct aicbt_patch_info_t *patch_info)
+{
+    int ret = 0;
+    uint32_t ext_patch_nb = patch_info->ext_patch_nb;
+    char ext_patch_file_name[50];
+    int index = 0;
+    uint32_t id = 0;
+    uint32_t addr = 0;
+
+    
+    if (ext_patch_nb > 0){
+        
+        for (index = 0; index < patch_info->ext_patch_nb; index++){
+            id = *(patch_info->ext_patch_param + (index * 2));
+            addr = *(patch_info->ext_patch_param + (index * 2) + 1); 
+            memset(ext_patch_file_name, 0, sizeof(ext_patch_file_name));
+            sprintf(ext_patch_file_name,"%s%d.bin",
+                FW_PATCH_BASE_NAME_8800D80_U02_EXT,
+                id);
+            AICWFDBG(LOGDEBUG, "%s ext_patch_file_name:%s ext_patch_id:%x ext_patch_addr:%x \r\n",
+                __func__,ext_patch_file_name, id, addr);
+            
+            if (rwnx_plat_bin_fw_upload_android(usb_dev, addr, ext_patch_file_name)) {
+                ret = -1;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+
 int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
 {
     struct aicbt_patch_table *head = NULL;
@@ -314,17 +405,21 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80_U02)) {
                 return -1;
             }
-            #if 0
-            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
+
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
                 return -1;
             }
-            #else
+
             if (aicbt_patch_table_load(usb_dev, head)) {
                 return -1;
             }
-            #endif
-            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_U02)) {
-                return -1;
+
+            if (IS_CHIP_ID_H()){
+                if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_H_U02))
+                    return -1;
+            } else {
+                if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_U02))
+                    return -1;
             }
             #if 0
             if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_CALIBMODE_ADDR_8800D80_U02, FW_CALIBMODE_NAME_8800D80_U02)) {
@@ -372,15 +467,15 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80_U02)) {
                 return -1;
             }
-#if 0
-            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
+
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
                 return -1;
             }
-#else
+
             if (aicbt_patch_table_load(usb_dev, head)) {
                 return -1;
             }
-#endif
+
 
             if (chip_mcu_id) {
                 int ret = 0;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
index 51a241908..de6d99f89 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
@@ -3,6 +3,8 @@
 
 #define USB_DEVICE_ID_AIC_8800D80       0x8D80
 #define USB_DEVICE_ID_AIC_8800D81       0x8D81
+#define USB_DEVICE_ID_AIC_8800D40       0x8D40
+#define USB_DEVICE_ID_AIC_8800D41       0x8D41
 
 #define FW_BASE_NAME_8800D80                "fmacfw_8800d80.bin"
 #define FW_RF_BASE_NAME_8800D80             "fmacfw_rf_8800d80.bin"
@@ -10,9 +12,16 @@
 #define FW_ADID_BASE_NAME_8800D80           "fw_adid_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80         "fw_patch_table_8800d80.bin"
 
+#ifdef CONFIG_FOR_IPCAM
+#define FW_BASE_NAME_8800D80_U02            "fmacfw_8800d80_u02_ipc.bin"
+#define FW_BASE_NAME_8800D80_H_U02          "fmacfw_8800d80_h_u02_ipc.bin"
+#else
 #define FW_BASE_NAME_8800D80_U02            "fmacfw_8800d80_u02.bin"
+#define FW_BASE_NAME_8800D80_H_U02          "fmacfw_8800d80_h_u02.bin"
+#endif
 #define FW_RF_BASE_NAME_8800D80_U02         "lmacfw_rf_8800d80_u02.bin"
 #define FW_PATCH_BASE_NAME_8800D80_U02      "fw_patch_8800d80_u02.bin"
+#define FW_PATCH_BASE_NAME_8800D80_U02_EXT  "fw_patch_8800d80_u02_ext"
 #define FW_ADID_BASE_NAME_8800D80_U02       "fw_adid_8800d80_u02.bin"
 #define FW_CALIBMODE_NAME_8800D80_U02       "calibmode_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80_U02     "fw_patch_table_8800d80_u02.bin"
@@ -34,6 +43,8 @@
 
 #define FLASH_BIN_ADDR_8800M80             0x8000000
 
+#define CHIP_ID_H_MASK  0xC0
+#define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
 
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev);
 int rwnx_plat_userconfig_load_8800d80(struct aic_usb_dev *usbdev);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c
new file mode 100644
index 000000000..0c65eddc9
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c
@@ -0,0 +1,688 @@
+#include "aic_txrxif.h"
+#include "aicwf_usb.h"
+#include "aicbluetooth.h"
+#include "aic_compat_8800d80x2.h"
+#include "aicwf_debug.h"
+extern int ble_scan_wakeup_reboot_time;
+extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
+
+int rwnx_plat_bin_fw_upload_2(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename);
+int rwnx_request_firmware_common(struct aic_usb_dev *usbdev,
+	u32** buffer, const char *filename);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+void rwnx_release_firmware_common(u32** buffer);
+
+extern int testmode;
+extern u8 chip_id;
+extern u8 chip_mcu_id;
+
+typedef u32 (*array2_tbl_t)[2];
+
+#define AIC_PATCH_MAGIG_NUM     0x48435450 // "PTCH"
+#define AIC_PATCH_MAGIG_NUM_2   0x50544348 // "HCTP"
+#define AIC_PATCH_BLOCK_MAX     4
+
+typedef struct {
+    uint32_t magic_num;
+    uint32_t pair_start;
+    uint32_t magic_num_2;
+    uint32_t pair_count;
+    uint32_t block_dst[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_src[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_size[AIC_PATCH_BLOCK_MAX]; // word count
+} aic_patch_t;
+
+
+#define AIC_PATCH_OFST(mem) ((size_t) &((aic_patch_t *)0)->mem)
+#define AIC_PATCH_ADDR(mem) ((u32) (aic_patch_str_base + AIC_PATCH_OFST(mem)))
+
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+#define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
+
+#define CFG_USER_CHAN_MAX_TXPWR_EN  0
+#define CFG_USER_TX_USE_ANA_F       0
+
+#define CFG_USER_EXT_FLAGS_EN   (CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
+
+u32 patch_tbl_d80x2[][2] =
+{
+    {0x021c, 0x04000000},//hs amsdu
+    {0x0220, 0x04010101},//ss amsdu
+    {0x0224, 0x50000a01},//hs aggr
+    {0x0228, 0x50000a00},//ss aggr
+
+#if 0
+    #ifdef USE_5G
+    {0x00b4, 0xf3010001},
+    #else
+    {0x00b4, 0xf3010000},
+    #endif
+#ifdef CONFIG_PLATFORM_HI
+    {0x0170, 0x00000001},//rx aggr counter
+#else
+    {0x0170, 0x0000000A},//rx aggr counter
+#endif
+
+    #if CFG_USER_EXT_FLAGS_EN
+    {0x0188, 0x00000001
+        #if CFG_USER_CHAN_MAX_TXPWR_EN
+        | USER_CHAN_MAX_TXPWR_EN_FLAG
+        #endif
+        #if CFG_USER_TX_USE_ANA_F
+        | USER_TX_USE_ANA_F_FLAG
+        #endif
+    }, // user_ext_flags
+    #endif
+#endif
+};
+
+//adap test
+u32 adaptivity_patch_tbl_d80x2[][2] = {
+#if 0
+    {0x000C, 0x0000320A}, //linkloss_thd
+    {0x009C, 0x00000000}, //ac_param_conf
+    {0x01CC, 0x00010000}, //tx_adaptivity_en
+#endif
+};
+
+u32 syscfg_tbl_masked_8800d80x2[][3] = {
+};
+
+u32 syscfg_tbl_8800d80x2[][2] = {
+    #ifdef CONFIG_PMIC_SETTING
+    {0x70001408, 0x00000000}, // stop wdg
+    #endif /* CONFIG_PMIC_SETTING */
+    {0x40500010, 0x00000006},//cpu performance
+    {0x40500024, 0x0000001f},
+};
+
+extern int adap_test;
+
+#define NEW_PATCH_BUFFER_MAP    1
+
+int aicwf_patch_config_8800d80x2(struct aic_usb_dev *usb_dev)
+{
+#if 1
+    u32 rd_patch_addr;
+    u32 aic_patch_addr;
+    u32 config_base, aic_patch_str_base;
+    #if (NEW_PATCH_BUFFER_MAP)
+    u32 patch_buff_addr, patch_buff_base, rd_version_addr, rd_version_val;
+    #endif
+    uint32_t start_addr = 0x001D7000;
+    u32 patch_addr = start_addr;
+    u32 patch_cnt = sizeof(patch_tbl_d80x2) / 4 / 2;
+    struct dbg_mem_read_cfm rd_patch_addr_cfm;
+    int ret = 0;
+    int cnt = 0;
+    //adap test
+    int adap_patch_cnt = 0;
+
+    if (adap_test) {
+        AICWFDBG(LOGINFO, "%s adap test \r\n", __func__);
+        adap_patch_cnt = sizeof(adaptivity_patch_tbl_d80x2)/sizeof(u32)/2;
+    }
+
+    rd_patch_addr = RAM_FMAC_FW_ADDR_8800D80X2 + 0x01A8;
+    aic_patch_addr = rd_patch_addr + 8;
+
+    AICWFDBG(LOGERROR, "Read FW mem: %08x\n", rd_patch_addr);
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_patch_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "setting base[0x%x] rd fail: %d\n", rd_patch_addr, ret);
+        return ret;
+    }
+    AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+    config_base = rd_patch_addr_cfm.memdata;
+
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, aic_patch_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "patch_str_base[0x%x] rd fail: %d\n", aic_patch_addr, ret);
+        return ret;
+    }
+    AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+    aic_patch_str_base = rd_patch_addr_cfm.memdata;
+
+    #if (NEW_PATCH_BUFFER_MAP)
+    rd_version_addr = RAM_FMAC_FW_ADDR_8800D80X2 + 0x01C;
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_version_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "version val[0x%x] rd fail: %d\n", rd_version_addr, ret);
+        return ret;
+    }
+    rd_version_val = rd_patch_addr_cfm.memdata;
+    AICWFDBG(LOGINFO, "rd_version_val=%08X\n", rd_version_val);
+    usb_dev->fw_version_uint = rd_version_val;
+    patch_buff_addr = rd_patch_addr + 12;
+    ret = rwnx_send_dbg_mem_read_req(usb_dev, patch_buff_addr, &rd_patch_addr_cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "patch buf rd fail\n");
+        return ret;
+    }
+    AICWFDBG(LOGINFO, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+    patch_buff_base = rd_patch_addr_cfm.memdata;
+    patch_addr = start_addr = patch_buff_base;
+    #endif
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num), AIC_PATCH_MAGIG_NUM))) {
+        AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num_2), AIC_PATCH_MAGIG_NUM_2))) {
+        AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num_2), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(pair_start), patch_addr))) {
+        AICWFDBG(LOGERROR, "pair_start[0x%x] write fail: %d\n", AIC_PATCH_ADDR(pair_start), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(pair_count), patch_cnt + adap_patch_cnt))) {
+        AICWFDBG(LOGERROR, "pair_count[0x%x] write fail: %d\n", AIC_PATCH_ADDR(pair_count), ret);
+        return ret;
+    }
+
+    for (cnt = 0; cnt < patch_cnt; cnt++) {
+        if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt, patch_tbl_d80x2[cnt][0]+config_base))) {
+            AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt);
+            return ret;
+        }
+        if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt+4, patch_tbl_d80x2[cnt][1]))) {
+            AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt+4);
+            return ret;
+        }
+    }
+
+    if (adap_test){
+        int tmp_cnt = patch_cnt + adap_patch_cnt;
+        AICWFDBG(LOGINFO, "%s set adap_test patch \r\n", __func__);
+        for (cnt = patch_cnt; cnt < tmp_cnt; cnt++) {
+            int tbl_idx = cnt - patch_cnt;
+            if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt, adaptivity_patch_tbl_d80x2[tbl_idx][0]+config_base))) {
+                AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt);
+            return ret;
+            }
+            if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt+4, adaptivity_patch_tbl_d80x2[tbl_idx][1]))) {
+                AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt+4);
+            return ret;
+            }
+        }
+    }
+
+    /*
+     *  Patch block 0 ~ 3, that is void by default, can be set as:
+     *
+     *  const u32 patch_block_0[3] = {0x11223344, 0x55667788, 0xaabbccdd};
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_dst[0]), 0x160000))) {
+     *      printk("block_dst [0x%x] write fail: %d\n", (u32)(&aic_patch->block_dst[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_src[0]), 0x307000))) {
+     *      printk("block_src [0x%x] write fail: %d\n", (u32)(&aic_patch->block_src[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_size[0]), sizeof(patch_block_0) / sizeof(u32)))) {
+     *      printk("block_size[0x%x] write fail: %d\n", (u32)(&aic_patch->block_size[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_block_write_req(usb_dev, 0x307000, sizeof(patch_block_0), patch_block_0))) {
+     *      printk("blk set fail: %d\n", ret);
+     *  }
+     */
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[0]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[0]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[1]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[1]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[2]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[2]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[3]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[3]), ret);
+        return ret;
+    }
+#endif
+
+    return 0;
+}
+
+
+#if 0
+extern char aic_fw_path[200];
+
+int rwnx_plat_userconfig_load_8800d80x2(struct aic_usb_dev *usb_dev){
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800D80X2;
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(usb_dev, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
+#endif
+int system_config_8800d80x2(struct aic_usb_dev *usb_dev){
+		int syscfg_num;
+		int ret, cnt;
+		const u32 mem_addr = 0x40500000;
+		const u32 mem_addr2 = 0x40500004;
+		struct dbg_mem_read_cfm rd_mem_addr_cfm;
+		ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr, &rd_mem_addr_cfm);
+		if (ret) {
+			printk("%x rd fail: %d\n", mem_addr, ret);
+			return ret;
+		}
+		chip_id = rd_mem_addr_cfm.memdata >> 16;
+
+		ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr2, &rd_mem_addr_cfm);
+		if (ret) {
+			printk("%x rd fail: %d\n", mem_addr2, ret);
+			return ret;
+		}
+		if (((rd_mem_addr_cfm.memdata >> 17) & 0x01UL) == 0x00UL) {
+			chip_mcu_id = 1;
+		}
+
+		printk("chip_id=%x, chip_mcu_id = %d\n", chip_id, chip_mcu_id);
+	#if 1
+		syscfg_num = sizeof(syscfg_tbl_8800d80x2) / sizeof(u32) / 2;
+		for (cnt = 0; cnt < syscfg_num; cnt++) {
+			ret = rwnx_send_dbg_mem_write_req(usb_dev, syscfg_tbl_8800d80x2[cnt][0], syscfg_tbl_8800d80x2[cnt][1]);
+			if (ret) {
+				printk("%x write fail: %d\n", syscfg_tbl_8800d80x2[cnt][0], ret);
+				return ret;
+			}
+		}
+		syscfg_num = sizeof(syscfg_tbl_masked_8800d80x2) / sizeof(u32) / 3;
+		for (cnt = 0; cnt < syscfg_num; cnt++) {
+			ret = rwnx_send_dbg_mem_mask_write_req(usb_dev,
+				syscfg_tbl_masked_8800d80x2[cnt][0], syscfg_tbl_masked_8800d80x2[cnt][1], syscfg_tbl_masked_8800d80x2[cnt][2]);
+			if (ret) {
+				printk("%x mask write fail: %d\n", syscfg_tbl_masked_8800d80x2[cnt][0], ret);
+				return ret;
+			}
+		}
+	#endif
+
+	return 0;
+}
+
+
+static int aicbt_ext_patch_data_load(struct aic_usb_dev *usb_dev, struct aicbt_patch_info_t *patch_info)
+{
+    int ret = 0;
+    uint32_t ext_patch_nb = patch_info->ext_patch_nb;
+    char ext_patch_file_name[50];
+    int index = 0;
+    uint32_t id = 0;
+    uint32_t addr = 0;
+
+    
+    if (ext_patch_nb > 0){
+        
+        for (index = 0; index < patch_info->ext_patch_nb; index++){
+            id = *(patch_info->ext_patch_param + (index * 2));
+            addr = *(patch_info->ext_patch_param + (index * 2) + 1); 
+            memset(ext_patch_file_name, 0, sizeof(ext_patch_file_name));
+            sprintf(ext_patch_file_name,"%s%d.bin",
+                FW_PATCH_BASE_NAME_8800D80X2_U03_EXT,
+                id);
+            AICWFDBG(LOGDEBUG, "%s ext_patch_file_name:%s ext_patch_id:%x ext_patch_addr:%x \r\n",
+                __func__,ext_patch_file_name, id, addr);
+            
+            if (rwnx_plat_bin_fw_upload_android(usb_dev, addr, ext_patch_file_name)) {
+                ret = -1;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+
+int aicfw_download_fw_8800d80x2(struct aic_usb_dev *usb_dev)
+{
+#ifdef CONFIG_USB_BT
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_info_t patch_info = {
+        .info_len          = 0,
+        .adid_addrinf      = 0,
+        .addr_adid         = 0,
+        .patch_addrinf     = 0,
+        .addr_patch        = 0,
+        .reset_addr        = 0,
+        .reset_val         = 0,
+        .adid_flag_addr    = 0,
+        .adid_flag         = 0,
+    };
+
+    //int i = 0;
+
+    if (chip_id < CHIP_REV_U05) {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2_U03);
+    } else {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2_U05);
+    }
+    if (head == NULL){
+        printk("aicbt_patch_table_alloc fail\n");
+        return -1;
+    }
+
+    if(head == NULL){
+        return -1;
+    }
+    if (chip_id < CHIP_REV_U05) {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80X2_U03;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80X2_U03;
+    } else {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80X2_U05;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80X2_U05;
+    }
+    aicbt_patch_info_unpack(&patch_info, head);
+    if(patch_info.info_len == 0) {
+        printk("%s, aicbt_patch_info_unpack fail\n", __func__);
+        return -1;
+    }
+
+    printk("addr_adid 0x%x, addr_patch 0x%x\n", patch_info.addr_adid, patch_info.addr_patch);
+
+    if (chip_mcu_id) {
+        int ret = 0;
+        u32 retry = 0;
+        const u32 mem_addr = 0x40506030;
+        const u32 mem_addr2 = 0x40506004;
+        u32 mem_data;
+        struct dbg_mem_read_cfm rd_mem_addr_cfm;
+        ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr, &rd_mem_addr_cfm);
+        if (ret) {
+            printk("%x rd fail: %d\n", mem_addr, ret);
+            return ret;
+        }
+        if (0 == (rd_mem_addr_cfm.memdata & (0x01UL << 2))) {
+            ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr2, &rd_mem_addr_cfm);
+            if (ret) {
+                printk("%x rd fail: %d\n", mem_addr2, ret);
+                return ret;
+            }
+            mem_data = (rd_mem_addr_cfm.memdata | (0x01UL << 17)) & (~(0x01UL << 18));
+
+            ret = rwnx_send_dbg_mem_write_req(usb_dev, mem_addr2, mem_data);
+            if (ret) {
+                printk("%x wr fail: %d\n", mem_addr2, ret);
+                return ret;
+            }
+            mdelay(1);
+
+            while (1) {
+                ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr, &rd_mem_addr_cfm);
+                if (ret) {
+                    printk("%x rd fail: %d\n", mem_addr, ret);
+                    return ret;
+                }
+                if (0 == (rd_mem_addr_cfm.memdata & (0x01UL << 2))) {
+                    mdelay(1);
+                    retry++;
+                    if (retry > 20) {
+                        printk("bt pwron timeout\n");
+                        return -1;
+                    }
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+#endif
+
+    if(testmode == FW_NORMAL_MODE){
+
+        if (chip_id < CHIP_REV_U05){
+#ifdef CONFIG_USB_BT
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U03)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U03)) {
+                return -1;
+            }
+
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
+                return -1;
+            }
+
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+
+            mdelay(100);
+#endif
+
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, FW_BASE_NAME_8800D80X2)) {
+                return -1;
+            }
+            #if 0
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_CALIBMODE_ADDR_8800D80X2_U02, FW_CALIBMODE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            if (rwnx_send_dbg_mem_write_req(usb_dev, 0x40500048, 0x1e0000))
+                return -1;
+            #endif
+            if (aicwf_patch_config_8800d80x2(usb_dev)) {
+                return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+                return -1;
+            }
+        }else {
+#ifdef CONFIG_USB_BT
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U05)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U05)) {
+                return -1;
+            }
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
+                return -1;
+            }
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+
+            mdelay(100);
+#endif
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, FW_BASE_NAME_8800D80X2)) {
+                return -1;
+            }
+            if (aicwf_patch_config_8800d80x2(usb_dev)) {
+                return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+                return -1;
+            }
+        }
+    }else if(testmode == FW_TEST_MODE){
+        if (chip_id < CHIP_REV_U05){
+#ifdef CONFIG_USB_BT
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U03)) {
+                return -1;
+            }
+
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U03)) {
+                return -1;
+            }
+
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
+                return -1;
+            }
+
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+
+            mdelay(100);
+#endif
+
+            if (chip_mcu_id) {
+                int ret = 0;
+                ret = rwnx_plat_flash_bin_upload_android(usb_dev, FLASH_BIN_ADDR_8800M80X2, FLASH_BIN_8800M80X2);
+                if (ret && ret!= ENOENT) {
+                    AICWFDBG(LOGERROR,"%s flash bin download fail \r\n", __func__);
+                    return -1;
+                }
+            }
+
+			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, FW_RF_BASE_NAME_8800D80X2)) {
+				AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+				return -1;
+			}
+			if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+				return -1;
+			}
+	    } else {
+#ifdef CONFIG_USB_BT
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U05)) {
+                return -1;
+            }
+
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U05)) {
+                return -1;
+            }
+
+            if (aicbt_ext_patch_data_load(usb_dev, &patch_info)) {
+                return -1;
+            }
+
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+
+            mdelay(100);
+#endif
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, FW_RF_BASE_NAME_8800D80X2)) {
+             AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+                    return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+                    return -1;
+            }
+	    }
+    }else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
+/*
+        data and ad_data_filter_mask instructions for use
+        ex.
+        data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
+        mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
+
+        data  = 0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42
+        mask =  1      1       0     0     0    0     0     0    0     1      1     1    1    1      1      1      1      1      0     0...... fill 0
+
+        data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
+        using data & mask value condition to wakeup host_wake_bt gpio
+*/
+#if 0
+        struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+        uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+        printk("%s ble scan wakeup \r\n", __func__);
+
+        memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
+        rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80X2, FW_BLE_SCAN_AD_FILTER_NAME);
+        wakeup_param->magic_num = 0x53454C42;//magic_num
+        wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+        wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+        /******************************************************************/
+        ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+        wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+        wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+        ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+        wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+        wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+        /********************************************************************/
+        //MAX_AD_FILTER_NUM=5 :num 0
+        {
+            const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+            wakeup_param->ad_filter[0].ad_len = 12;
+            wakeup_param->ad_filter[0].ad_type = 0x09;
+            memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+            wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+            wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+            wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+        }
+        /********************************************************************/
+        //MAX_AD_FILTER_NUM=5 :num 1
+        {
+            const uint8_t data[2] = {0x12,0x18};
+            wakeup_param->ad_filter[1].ad_len = 3;
+            wakeup_param->ad_filter[1].ad_type = 0x3;
+            memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+            wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+            wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+            wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+        }
+        /********************************************************************/
+        //MAX_AD_FILTER_NUM=5 :num 2
+        {
+            //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+            wakeup_param->ad_filter[2].ad_len = 0;
+            wakeup_param->ad_filter[2].ad_type = 0;
+            //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+            wakeup_param->ad_filter[2].ad_data_mask = 0;
+            wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+            wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+        }
+        /********************************************************************/
+        //MAX_AD_FILTER_NUM=5 :num 3
+        {
+            //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+            wakeup_param->ad_filter[3].ad_len = 0;
+            wakeup_param->ad_filter[3].ad_type = 0;
+            //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+            wakeup_param->ad_filter[3].ad_data_mask = 0;
+            wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+            wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+        }
+        /********************************************************************/
+        //MAX_AD_FILTER_NUM=5 :num 4
+        {
+            //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+            wakeup_param->ad_filter[4].ad_len = 0;
+            wakeup_param->ad_filter[4].ad_type = 0x09;
+            //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+            wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+            wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+            wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+        }
+
+        for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
+            printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
+            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
+        }
+        rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80X2, HOST_START_APP_AUTO);
+        kfree(wakeup_param);
+#endif
+
+        return -1;
+    }
+
+    return 0;
+}
+
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h
new file mode 100644
index 000000000..95bdf6a77
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h
@@ -0,0 +1,45 @@
+#include <linux/types.h>
+#include "aicwf_usb.h"
+
+#define USB_DEVICE_ID_AIC_8800D80X2       0x8D90
+#define USB_DEVICE_ID_AIC_8800D81X2       0x8D91
+#define USB_DEVICE_ID_AIC_8800D89X2       0x8D99
+
+#ifdef CONFIG_FOR_IPCAM
+#define FW_BASE_NAME_8800D80X2                "fmacfw_8800d80x2_ipc.bin"
+#else
+#define FW_BASE_NAME_8800D80X2                "fmacfw_8800d80x2.bin"
+#endif
+#define FW_RF_BASE_NAME_8800D80X2             "lmacfw_rf_8800d80x2.bin"
+
+#define FW_PATCH_BASE_NAME_8800D80X2_U03      "fw_patch_8800d80x2_u03.bin"
+#define FW_PATCH_BASE_NAME_8800D80X2_U03_EXT  "fw_patch_8800d80x2_u03_ext"
+#define FW_ADID_BASE_NAME_8800D80X2_U03       "fw_adid_8800d80x2_u03.bin"
+#define FW_PATCH_TABLE_NAME_8800D80X2_U03     "fw_patch_table_8800d80x2_u03.bin"
+
+#define FW_PATCH_BASE_NAME_8800D80X2_U05      "fw_patch_8800d80x2_u05.bin"
+#define FW_PATCH_BASE_NAME_8800D80X2_U05_EXT  "fw_patch_8800d80x2_u05_ext"
+#define FW_ADID_BASE_NAME_8800D80X2_U05       "fw_adid_8800d80x2_u05.bin"
+#define FW_PATCH_TABLE_NAME_8800D80X2_U05     "fw_patch_table_8800d80x2_u05.bin"
+
+#define FLASH_BIN_8800M80X2                   "host_wb_8800m80x2.bin"
+
+#define FW_USERCONFIG_NAME_8800D80X2          "aic_userconfig_8800d80x2.txt"
+
+#define RAM_FMAC_FW_ADDR_8800D80X2           0x120000
+#define RAM_FMAC_RF_FW_ADDR_8800D80X2        0x120000
+
+#define FW_RAM_ADID_BASE_ADDR_8800D80X2_U03  0x003018f8
+#define FW_RAM_PATCH_BASE_ADDR_8800D80X2_U03 0x0030b494
+
+#define FW_RAM_ADID_BASE_ADDR_8800D80X2_U05  0x003018f8
+#define FW_RAM_PATCH_BASE_ADDR_8800D80X2_U05 0x0030b48c
+
+#define FLASH_BIN_ADDR_8800M80X2             0x8000000
+
+
+int aicwf_patch_config_8800d80x2(struct aic_usb_dev *usb_dev);
+int rwnx_plat_userconfig_load_8800d80x2(struct aic_usb_dev *usbdev);
+int system_config_8800d80x2(struct aic_usb_dev *usb_dev);
+int aicfw_download_fw_8800d80x2(struct aic_usb_dev *usb_dev);
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
index 184d85711..df0d11d3d 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
@@ -1,1313 +1,1362 @@
-#include <linux/version.h>
-#include <linux/vmalloc.h>
-#include "aicbluetooth_cmds.h"
-#include "aicwf_usb.h"
-#include "aic_txrxif.h"
-#include "md5.h"
-#include "aicbluetooth.h"
-#ifdef CONFIG_USE_FW_REQUEST
-#include <linux/firmware.h>
-#endif
-
-//Parser state
-#define INIT 0
-#define CMD 1
-#define PRINT 2
-#define GET_VALUE 3
-
-extern int flash_erase_len;
-
-typedef struct
-{
-    int8_t enable;
-    int8_t dsss;
-    int8_t ofdmlowrate_2g4;
-    int8_t ofdm64qam_2g4;
-    int8_t ofdm256qam_2g4;
-    int8_t ofdm1024qam_2g4;
-    int8_t ofdmlowrate_5g;
-    int8_t ofdm64qam_5g;
-    int8_t ofdm256qam_5g;
-    int8_t ofdm1024qam_5g;
-} txpwr_idx_conf_t;
-
-
-txpwr_idx_conf_t userconfig_txpwr_idx = {
-	.enable 		  = 1,
-	.dsss			  = 9,
-	.ofdmlowrate_2g4  = 8,
-	.ofdm64qam_2g4	  = 8,
-	.ofdm256qam_2g4   = 8,
-	.ofdm1024qam_2g4  = 8,
-	.ofdmlowrate_5g   = 11,
-	.ofdm64qam_5g	  = 10,
-	.ofdm256qam_5g	  = 9,
-	.ofdm1024qam_5g   = 9
-
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t chan_1_4;
-    int8_t chan_5_9;
-    int8_t chan_10_13;
-    int8_t chan_36_64;
-    int8_t chan_100_120;
-    int8_t chan_122_140;
-    int8_t chan_142_165;
-} txpwr_ofst_conf_t;
-
-txpwr_ofst_conf_t userconfig_txpwr_ofst = {
-	.enable = 1,
-	.chan_1_4 = 0,
-	.chan_5_9 = 0,
-	.chan_10_13 = 0,
-	.chan_36_64 = 0,
-	.chan_100_120 = 0,
-	.chan_122_140 = 0,
-	.chan_142_165 = 0
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t xtal_cap;
-    int8_t xtal_cap_fine;
-} xtal_cap_conf_t;
-
-
-xtal_cap_conf_t userconfig_xtal_cap = {
-	.enable = 0,
-	.xtal_cap = 24,
-	.xtal_cap_fine = 31,
-};
-
-struct aicbt_info_t {
-    uint32_t btmode;
-    uint32_t btport;
-    uint32_t uart_baud;
-    uint32_t uart_flowctrl;
-	uint32_t lpm_enable;
-	uint32_t txpwr_lvl;
-};
-
-struct aicbsp_info_t {
-    int hwinfo;
-    uint32_t cpmode;
-};
-
-
-enum aicbt_btport_type {
-    AICBT_BTPORT_NULL,
-    AICBT_BTPORT_MB,
-    AICBT_BTPORT_UART,
-};
-
-/*  btmode
- * used for force bt mode,if not AICBSP_MODE_NULL
- * efuse valid and vendor_info will be invalid, even has beed set valid
-*/
-enum aicbt_btmode_type {
-    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
-    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
-    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
-    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
-    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
-    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
-    AICBT_MODE_NULL = 0xFF,           // invalid value
-};
-
-/*  uart_baud
- * used for config uart baud when btport set to uart,
- * otherwise meaningless
-*/
-enum aicbt_uart_baud_type {
-    AICBT_UART_BAUD_115200     = 115200,
-    AICBT_UART_BAUD_921600     = 921600,
-    AICBT_UART_BAUD_1_5M       = 1500000,
-    AICBT_UART_BAUD_3_25M      = 3250000,
-};
-
-enum aicbt_uart_flowctrl_type {
-    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
-    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
-};
-
-enum aicbsp_cpmode_type {
-    AICBSP_CPMODE_WORK,
-    AICBSP_CPMODE_TEST,
-};
-#define AIC_M2D_OTA_INFO_ADDR       0x88000020
-#define AIC_M2D_OTA_DATA_ADDR       0x88000040
-#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
-#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
-#define AIC_M2D_OTA_VER_ADDR        0x0800418c
-///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
-///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
-#define AICBT_TXPWR_LVL            0x00006020
-#define AICBT_TXPWR_LVL_8800d80     0x00006F2F
-
-#define AICBSP_MODE_BT_HCI_MODE_NULL              0
-#define AICBSP_MODE_BT_HCI_MODE_MB                1
-#define AICBSP_MODE_BT_HCI_MODE_UART              2
-
-#define AICBSP_HWINFO_DEFAULT       (-1)
-#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
-
-#define AICBT_BTMODE_DEFAULT_8800d80        AICBT_BTMODE_BT_ONLY_COANT
-#define AICBT_BTMODE_DEFAULT                AICBT_BTMODE_BT_ONLY
-#define AICBT_BTPORT_DEFAULT                AICBT_BTPORT_MB
-#define AICBT_UART_BAUD_DEFAULT             AICBT_UART_BAUD_1_5M
-#define AICBT_UART_FC_DEFAULT               AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT            0
-#define AICBT_TXPWR_LVL_DEFAULT             AICBT_TXPWR_LVL
-#define AICBT_TXPWR_LVL_DEFAULT_8800d80     AICBT_TXPWR_LVL_8800d80
-
-
-#define AIC_HW_INFO 0x21
-
-#define FW_PATH_MAX 200
-#if defined(CONFIG_PLATFORM_UBUNTU)
-static const char* aic_default_fw_path = "/usr/lib/firmware";
-#else
-static const char* aic_default_fw_path = "/usr/lib/firmware";
-#endif
-char aic_fw_path[FW_PATH_MAX];
-module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-char saved_sdk_ver[64];
-module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
-#endif
-
-
-int aic_bt_platform_init(struct aic_usb_dev *usbdev)
-{
-    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
-    usbdev->cmd_mgr.usbdev = (void *)usbdev;
-    return 0;
-
-}
-
-void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
-{
-	rwnx_cmd_mgr_deinit(&usbdev->cmd_mgr);
-}
-
-#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
-#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
-
-static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
-{
-
-#ifdef CONFIG_USE_FW_REQUEST
-	const struct firmware *fw = NULL;
-	u32 *dst = NULL;
-	void *buffer=NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-	int size = 0;
-	int ret = 0;
-
-	printk("%s: request firmware = %s \n", __func__ ,name);
-
-
-	ret = request_firmware(&fw, name, NULL);
-	
-	if (ret < 0) {
-		printk("Load %s fail\n", name);
-		release_firmware(fw);
-		return -1;
-	}
-	
-	size = fw->size;
-	dst = (u32 *)fw->data;
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		release_firmware(fw);
-		return -1;
-	}
-
-
-	buffer = vmalloc(size);
-	memset(buffer, 0, size);
-	memcpy(buffer, dst, size);
-	
-	*fw_buf = buffer;
-
-	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)buffer, size);
-	MD5Final(&md5, decrypt);
-	printk(MD5PINRT, MD5(decrypt));
-	
-	release_firmware(fw);
-	
-	return size;
-#else
-    void *buffer=NULL;
-    char *path=NULL;
-    struct file *fp=NULL;
-    int size = 0, len=0;//, i=0;
-    ssize_t rdlen=0;
-    //u32 *src=NULL, *dst = NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-#if defined(CONFIG_PLATFORM_UBUNTU)
-    struct aicwf_bus *bus_if = dev_get_drvdata(device);
-    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
-#endif
-
-    /* get the firmware path */
-    path = __getname();
-    if (!path){
-            *fw_buf=NULL;
-            return -1;
-    }
-
-    if (strlen(aic_fw_path) > 0) {
-		printk("%s: use customer define fw_path\n", __func__);
-		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
-    } else {
-    #if defined(CONFIG_PLATFORM_UBUNTU)
-        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
-        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
-        } else {
-            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
-        }
-	#else
-		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
-	#endif
-    }
-
-    if (len >= FW_PATH_MAX) {
-    	printk("%s: %s file's path too long\n", __func__, name);
-        *fw_buf=NULL;
-        __putname(path);
-        return -1;
-    }
-
-    printk("%s :firmware path = %s  \n", __func__ ,path);
-
-
-    /* open the firmware file */
-    fp=filp_open(path, O_RDONLY, 0);
-    if(IS_ERR(fp) || (!fp)){
-            printk("%s: %s file failed to open\n", __func__, name);
-            if(IS_ERR(fp))
-		printk("is_Err\n");
-	if((!fp))
-		printk("null\n");
-	*fw_buf=NULL;
-            __putname(path);
-            fp=NULL;
-            return -1;
-    }
-
-    size = i_size_read(file_inode(fp));
-    if(size<=0){
-            printk("%s: %s file size invalid %d\n", __func__, name, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-}
-
-    /* start to read from firmware file */
-    buffer = vmalloc(size);
-    memset(buffer, 0, size);
-    if(!buffer){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-    }
-
-
-    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
-    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
-    #else
-    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
-    #endif
-
-    if(size != rdlen){
-            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-    if(rdlen > 0){
-            fp->f_pos += rdlen;
-            //printk("f_pos=%d\n", (int)fp->f_pos);
-    }
-
-
-#if 0
-   /*start to transform the data format*/
-    src = (u32*)buffer;
-    //printk("malloc dst\n");
-    dst = (u32*)vmalloc(size);
-    memset(dst, 0, size);
-
-    if(!dst){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-
-    for(i=0;i<(size/4);i++){
-            dst[i] = src[i];
-    }
-#endif
-
-    __putname(path);
-    filp_close(fp,NULL);
-    fp=NULL;
-    //vfree(buffer);
-    //buffer=NULL;
-    //*fw_buf = dst;
-	*fw_buf = (u32 *)buffer;
-
-	MD5Init(&md5);
-	//MD5Update(&md5, (unsigned char *)dst, size);
-	MD5Update(&md5, (unsigned char *)buffer, size);
-	MD5Final(&md5, decrypt);
-
-	printk(MD5PINRT, MD5(decrypt));
-
-    return size;
-#endif
-
-}
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
-                               char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
-
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
-                if (err) {
-                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
-        if (err) {
-            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-    printk("fw download complete\n\n");
-
-    return err;
-}
-
-extern int testmode;
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of m2d file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0,j=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret=0;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
-	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
-	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	u32 driver_sdk_ver_addr_idx = 0;
-	u32 code_start_addr = 0xffffffff;
-	u32 sdk_ver_addr = 0xffffffff;
-	u32 drv_code_start_addr = 0xffffffff;
-	u32 drv_sdk_ver_addr = 0xffffffff;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-	char m2d_sdk_ver[64];
-	char flash_sdk_ver[64];
-	u32 flash_ver[16];
-	u32 ota_ver[16];
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	code_start_addr = rd_mem_addr_cfm.memdata;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	sdk_ver_addr = rd_mem_addr_cfm.memdata;
-	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
-
-	/* load aic firmware */
-	size = aic_load_firmware(&dst, filename, dev);
-	if(size<=0){
-			printk("wrong size of m2d file\n");
-			vfree(dst);
-			dst = NULL;
-			return -1;
-	}
-	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
-		printk("########m2d flash old version , must be upgrade\n");
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-	} else {
-		for(i=0;i<16;i++){
-			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
-			if (ret){
-				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-				return ret;
-			}
-			flash_ver[i] = rd_mem_addr_cfm.memdata;
-		}
-		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
-        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
-		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
-				
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
-		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
-
-		if (driver_sdk_ver_addr_idx){
-			for(j = 0; j < 16; j++){
-				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
-			}
-			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
-			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
-		} else {
-			return -1;
-		}
-		
-		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
-			printk("######## m2d %s flash is not need upgrade\r\n", filename);
-			return -1;
-		}
-	}
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
-
-int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
-                               char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-    const u32 mem_addr = fw_addr;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return ENOENT;
-    }
-
-    printk("size %x, flash_erase_len %x\n", size, flash_erase_len);
-    if (size != flash_erase_len || (flash_erase_len & 0xFFF)) {
-        printk("wrong size of flash_erase_len %d\n", flash_erase_len);
-        vfree(dst);
-        dst = NULL;
-        return -1;
-    }
-
-    err = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (err) {
-        printk("%x rd fail: %d\n", mem_addr, err);
-        return err;
-    }
-
-    if (rd_mem_addr_cfm.memdata != 0xffffffff) {
-        //erase flash
-        if (size > 0x40000) {
-            for (i = 0; i < (size - 0x40000); i +=0x40000) {//each time erase 256K
-                err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr+i, 0xf150e250, 0x40000);
-                if (err) {
-                    printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
-                    return err;
-                }
-            }
-        }
-        if (!err && (i < size)) {// <256KB data
-            err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr + i, 0xf150e250, size - i);
-            if (err) {
-                printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
-            }
-        }
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
-
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
-                if (err) {
-                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
-        if (err) {
-            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-    printk("fw download complete\n\n");
-
-    return err;
-}
-
-
-uint32_t rwnx_atoli(char *value){
-	int len = 0;
-	int temp_len = 0;
-	int i = 0;
-	uint32_t result = 0;
-	
-	temp_len = strlen(value);
-
-	for(i = 0;i < temp_len; i++){
-		if((value[i] >= 48 && value[i] <= 57) ||
-			(value[i] >= 65 && value[i] <= 70) ||
-			(value[i] >= 97 && value[i] <= 102)){
-			len++;
-		}
-	}
-
-	//printk("%s len:%d \r\n", __func__, len);
-	
-	for(i = 0; i < len; i++){
-		result = result * 16;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else if(value[i] >= 65 && value[i] <= 70){
-			result += (value[i] - 65) + 10;
-		}else if(value[i] >= 97 && value[i] <= 102){
-			result += (value[i] - 97) + 10;
-		}
-	}
-	
-	return result;
-}
-
-int8_t rwnx_atoi(char *value){
-	int len = 0;
-	int i = 0;
-	int8_t result = 0;
-	int8_t signal = 1;
-
-	len = strlen(value);
-	//printk("%s len:%d \r\n", __func__, len);
-
-	for(i = 0;i < len ;i++){
-		if(i == 0 && value[0] == '-'){
-			signal = -1;
-			continue;
-		}
-
-		result = result * 10;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else{
-			result = 0;
-			break;
-		}
-	}
-
-	result = result * signal;
-	//printk("%s result:%d \r\n", __func__, result);
-
-	return result;
-}
-
-void get_fw_path(char* fw_path){
-	if (strlen(aic_fw_path) > 0) {
-		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
-	}else{
-		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
-	}
-} 
-
-void set_testmode(int val){
-	testmode = val;
-}
-
-int get_testmode(void){
-	return testmode;
-}
-
-int get_hardware_info(void){
-	return AIC_HW_INFO;
-}
-
-extern int adap_test;
-int get_adap_test(void){
-    return adap_test;
-}
-
-EXPORT_SYMBOL(get_fw_path);
-
-EXPORT_SYMBOL(get_testmode);
-
-EXPORT_SYMBOL(set_testmode);
-
-EXPORT_SYMBOL(get_hardware_info);
-
-EXPORT_SYMBOL(get_adap_test);
-
-
-void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
-{
-	xtal_cap->enable = userconfig_xtal_cap.enable;
-	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
-	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
-
-    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
-    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
-    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
-}
-
-EXPORT_SYMBOL(get_userconfig_xtal_cap);
-
-void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
-	txpwr_idx->enable = userconfig_txpwr_idx.enable;
-	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
-	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
-	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
-	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
-	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
-	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
-	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
-	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
-	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
-
-	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
-	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
-	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
-	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
-	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
-	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
-	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
-	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
-	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
-	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_idx);
-
-void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
-	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
-	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
-	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
-	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
-	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
-	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
-	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
-	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
-
-	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
-	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
-	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
-	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
-	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
-	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
-	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
-	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
-
-void rwnx_plat_userconfig_set_value(char *command, char *value){	
-	//TODO send command
-	printk("%s:command=%s value=%s \r\n", __func__, command, value);
-	if(!strcmp(command, "enable")){
-		userconfig_txpwr_idx.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "dsss")){
-		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_2g4")){
-		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_2g4")){
-		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_2g4")){
-		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_2g4")){
-		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_5g")){
-		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_5g")){
-		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_5g")){
-		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_5g")){
-		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_enable")){
-		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_1_4")){
-		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_5_9")){
-		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_10_13")){
-		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_36_64")){
-		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_100_120")){
-		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_122_140")){
-		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_142_165")){
-		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_enable")){
-		userconfig_xtal_cap.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap")){
-		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap_fine")){
-		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
-	}
-}
-
-void rwnx_plat_userconfig_parsing(char *buffer, int size){
-    int i = 0;
-	int parse_state = 0;
-	char command[30];
-	char value[100];
-	int char_counter = 0;
-
-	memset(command, 0, 30);
-	memset(value, 0, 100);
-
-    for(i = 0; i < size; i++){
-
-		//Send command or print nvram log when char is \r or \n
-		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-			if(command[0] != 0 && value[0] != 0){
-				if(parse_state == PRINT){
-					printk("%s:%s\r\n", __func__, value);
-				}else if(parse_state == GET_VALUE){
-					rwnx_plat_userconfig_set_value(command, value);
-				}
-			}
-			//Reset command value and char_counter
-			memset(command, 0, 30);
-			memset(value, 0, 100);
-			char_counter = 0;
-			parse_state = INIT;
-			continue;
-		}
-
-		//Switch parser state
-		if(parse_state == INIT){
-			if(buffer[i] == '#'){
-				parse_state = PRINT;
-				continue;
-			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-				parse_state = INIT;
-				continue;
-			}else{
-				parse_state = CMD;
-			}
-		}
-
-		//Fill data to command and value
-		if(parse_state == PRINT){
-			command[0] = 0x01;
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == CMD){
-			if(command[0] != 0 && buffer[i] == '='){
-				parse_state = GET_VALUE;
-				char_counter = 0;
-				continue;
-			}
-			command[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == GET_VALUE){
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}
-	}
-
-
-}
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    int size;
-    u32 *dst=NULL;
-    struct device *dev = usbdev->dev;
-
-	printk("userconfig file path:%s \r\n", filename);
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size <= 0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return 0;
-    }
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s userconfig, size=%d\n", filename, size);
-
-	rwnx_plat_userconfig_parsing((char *)dst, size);
-
-	if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-	printk("userconfig download complete\n\n");
-	return 0;
-}
-
-
-
-int aicbt_patch_table_free(struct aicbt_patch_table *head)
-{
-	struct aicbt_patch_table *p = head, *n = NULL;
-	while (p) {
-		n = p->next;
-		vfree(p->name);
-		vfree(p->data);
-		vfree(p);
-		p = n;
-	}
-	head = NULL;
-	return 0;
-}
-
-struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev,const char *filename)
-{
-	struct device *dev = usbdev->dev;
-	struct aicbt_patch_table *head = NULL;
-	struct aicbt_patch_table *new = NULL;
-	struct aicbt_patch_table *cur = NULL;
-	int size;
-	int ret = 0;
-	uint8_t *rawdata=NULL;
-	uint8_t *p = NULL;
-
-	/* load aic firmware */
-	size = aic_load_firmware((u32 **)&rawdata, filename, dev);
-
-	/* Copy the file on the Embedded side */
-	printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		ret = -1;
-		goto err;
-	}
-
-	p = rawdata;
-
-	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-		printk("TAG err\n");
-		ret = -1;
-		goto err;
-	}
-	p += 16;
-
-	while (p - rawdata < size) {
-		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
-		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
-		memset(new, 0, sizeof(struct aicbt_patch_table));
-		if (head == NULL) {
-			head = new;
-			cur  = new;
-		} else {
-			cur->next = new;
-			cur = cur->next;
-		}
-
-		cur->name = (char *)vmalloc(sizeof(char) * 16);
-		memset(cur->name, 0, sizeof(char) * 16);
-		memcpy(cur->name, p, 16);
-		p += 16;
-
-		cur->type = *(uint32_t *)p;
-		p += 4;
-
-		cur->len = *(uint32_t *)p;
-		p += 4;
-
-		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
-			cur->len = 0;
-		}else{
-			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
-			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-			memcpy(cur->data, p, cur->len * 8);
-			p += cur->len * 8;
-		}
-	}
-
-	vfree(rawdata);
-
-	return head;
-
-err:
-	aicbt_patch_table_free(head);
-	if (rawdata)
-		vfree(rawdata);
-	return NULL;
-}
-
-struct aicbsp_info_t aicbsp_info = {
-    .hwinfo   = AICBSP_HWINFO_DEFAULT,
-    .cpmode   = AICBSP_CPMODE_DEFAULT,
-};
-
-
-
-static struct aicbt_info_t aicbt_info[] = {
-    {   
-        .btmode        = AICBT_BTMODE_DEFAULT,
-        .btport        = AICBT_BTPORT_DEFAULT,
-        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
-    },//PRODUCT_ID_AIC8800
-    {
-    },//PRODUCT_ID_AIC8801
-    {
-    },//PRODUCT_ID_AIC8800DC
-    {
-    },//PRODUCT_ID_AIC8800DW
-    {
-        .btmode        = AICBT_BTMODE_DEFAULT_8800d80,
-        .btport        = AICBT_BTPORT_DEFAULT,
-        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80,
-    },//PRODUCT_ID_AIC8800D80
-    {
-    },//PRODUCT_ID_AIC8800D81
-};
-
-int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
-{
-	struct aicbt_patch_table *head, *p;
-	int ret = 0, i;
-	uint32_t *data = NULL;
-
-	head = _head;
-
-	for (p = head; p != NULL; p = p->next) {
-		data = p->data;
-		if(AICBT_PT_BTMODE == p->type){
-			*(data + 1)  = aicbsp_info.hwinfo < 0;
-			*(data + 3) = aicbsp_info.hwinfo;
-			*(data + 5)  = aicbsp_info.cpmode;
-
-			*(data + 7) = aicbt_info[usbdev->chipid].btmode;
-			*(data + 9) = aicbt_info[usbdev->chipid].btport;
-			*(data + 11) = aicbt_info[usbdev->chipid].uart_baud;
-			*(data + 13) = aicbt_info[usbdev->chipid].uart_flowctrl;
-			*(data + 15) = aicbt_info[usbdev->chipid].lpm_enable;
-			*(data + 17) = aicbt_info[usbdev->chipid].txpwr_lvl;
-            
-            printk("%s bt btmode[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].btmode);
-    		printk("%s bt uart_baud[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_baud);
-    		printk("%s bt uart_flowctrl[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_flowctrl);
-    		printk("%s bt lpm_enable[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].lpm_enable);
-    		printk("%s bt tx_pwr[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].txpwr_lvl);
-
-		}
-		if (p->type == 0x06) {
-			char *data_s = (char *)p->data;
-			printk("patch version %s\n", data_s);
-			continue;
-		}
-		for (i = 0; i < p->len; i++) {
-			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
-			if (ret != 0)
-				return ret;
-			data += 2;
-		}
-		if (p->type == AICBT_PT_PWRON)
-			udelay(500);
-	}
-	aicbt_patch_table_free(head);
-	return 0;
-}
-
-int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
-{
-    if (AICBT_PT_INF == head_t->type) {
-        patch_info->info_len = head_t->len;
-        if(patch_info->info_len == 0)
-            return 0;
-        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
-    }
-    return 0;
-}
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    struct device *dev = usbdev->dev;
-	struct aicbt_patch_table *head = NULL;
-	struct aicbt_patch_table *new = NULL;
-	struct aicbt_patch_table *cur = NULL;
-   	 int size;
-	int ret = 0;
-   	uint8_t *rawdata=NULL;
-	uint8_t *p = NULL;
-
-    /* load aic firmware */
-    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		ret = -1;
-		goto err;
-	}
-
-	p = rawdata;
-
-	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-		printk("TAG err\n");
-		ret = -1;
-		goto err;
-	}
-	p += 16;
-
-	while (p - rawdata < size) {
-		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
-		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
-		memset(new, 0, sizeof(struct aicbt_patch_table));
-		if (head == NULL) {
-			head = new;
-			cur  = new;
-		} else {
-			cur->next = new;
-			cur = cur->next;
-		}
-
-		cur->name = (char *)vmalloc(sizeof(char) * 16);
-		memset(cur->name, 0, sizeof(char) * 16);
-		memcpy(cur->name, p, 16);
-		p += 16;
-
-		cur->type = *(uint32_t *)p;
-		p += 4;
-
-		cur->len = *(uint32_t *)p;
-		p += 4;
-
-		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
-			cur->len = 0;
-		}else{
-			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
-			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-			memcpy(cur->data, p, cur->len * 8);
-			p += cur->len * 8;
-		}
-	}
-
-	vfree(rawdata);
-	aicbt_patch_table_load(usbdev, head);
-	printk("fw_patch_table download complete\n\n");
-
-	return ret;
-err:
-	//aicbt_patch_table_free(&head);
-
-	if (rawdata){
-		vfree(rawdata);
-	}
-	return ret;
-}
-
-
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include "aicbluetooth_cmds.h"
+#include "aicwf_usb.h"
+#include "aic_txrxif.h"
+#include "md5.h"
+#include "aicbluetooth.h"
+#include "aicwf_debug.h"
+#ifdef CONFIG_USE_FW_REQUEST
+#include <linux/firmware.h>
+#endif
+
+//Parser state
+#define INIT 0
+#define CMD 1
+#define PRINT 2
+#define GET_VALUE 3
+
+extern int flash_erase_len;
+
+typedef struct
+{
+    int8_t enable;
+    int8_t dsss;
+    int8_t ofdmlowrate_2g4;
+    int8_t ofdm64qam_2g4;
+    int8_t ofdm256qam_2g4;
+    int8_t ofdm1024qam_2g4;
+    int8_t ofdmlowrate_5g;
+    int8_t ofdm64qam_5g;
+    int8_t ofdm256qam_5g;
+    int8_t ofdm1024qam_5g;
+} txpwr_idx_conf_t;
+
+
+txpwr_idx_conf_t userconfig_txpwr_idx = {
+	.enable 		  = 1,
+	.dsss			  = 9,
+	.ofdmlowrate_2g4  = 8,
+	.ofdm64qam_2g4	  = 8,
+	.ofdm256qam_2g4   = 8,
+	.ofdm1024qam_2g4  = 8,
+	.ofdmlowrate_5g   = 11,
+	.ofdm64qam_5g	  = 10,
+	.ofdm256qam_5g	  = 9,
+	.ofdm1024qam_5g   = 9
+
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t chan_1_4;
+    int8_t chan_5_9;
+    int8_t chan_10_13;
+    int8_t chan_36_64;
+    int8_t chan_100_120;
+    int8_t chan_122_140;
+    int8_t chan_142_165;
+} txpwr_ofst_conf_t;
+
+txpwr_ofst_conf_t userconfig_txpwr_ofst = {
+	.enable = 1,
+	.chan_1_4 = 0,
+	.chan_5_9 = 0,
+	.chan_10_13 = 0,
+	.chan_36_64 = 0,
+	.chan_100_120 = 0,
+	.chan_122_140 = 0,
+	.chan_142_165 = 0
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t xtal_cap;
+    int8_t xtal_cap_fine;
+} xtal_cap_conf_t;
+
+
+xtal_cap_conf_t userconfig_xtal_cap = {
+	.enable = 0,
+	.xtal_cap = 24,
+	.xtal_cap_fine = 31,
+};
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+	uint32_t lpm_enable;
+	uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+/*  uart_baud
+ * used for config uart baud when btport set to uart,
+ * otherwise meaningless
+*/
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+#define AIC_M2D_OTA_INFO_ADDR       0x88000020
+#define AIC_M2D_OTA_DATA_ADDR       0x88000040
+#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
+#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
+#define AIC_M2D_OTA_VER_ADDR        0x0800418c
+///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
+///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
+#define AICBT_TXPWR_LVL            0x00006020
+#define AICBT_TXPWR_LVL_8800d80    0x00006F2F
+#define AICBT_TXPWR_LVL_8800d80x2  0x00006F2F
+
+
+#define AICBSP_MODE_BT_HCI_MODE_NULL              0
+#define AICBSP_MODE_BT_HCI_MODE_MB                1
+#define AICBSP_MODE_BT_HCI_MODE_UART              2
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+
+#define AICBT_BTMODE_DEFAULT_8800d80x2      AICBT_BTMODE_BT_ONLY_COANT
+#define AICBT_BTMODE_DEFAULT_8800d80        AICBT_BTMODE_BT_ONLY_COANT
+#define AICBT_BTMODE_DEFAULT                AICBT_BTMODE_BT_ONLY
+#define AICBT_BTPORT_DEFAULT                AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT             AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT               AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT            0
+#define AICBT_TXPWR_LVL_DEFAULT             AICBT_TXPWR_LVL
+#define AICBT_TXPWR_LVL_DEFAULT_8800d80     AICBT_TXPWR_LVL_8800d80
+#define AICBT_TXPWR_LVL_DEFAULT_8800d80x2   AICBT_TXPWR_LVL_8800d80x2
+
+
+#define AIC_HW_INFO 0x21
+
+#define FW_PATH_MAX 200
+#if defined(CONFIG_PLATFORM_UBUNTU)
+static const char* aic_default_fw_path = "/lib/firmware";
+#else
+static const char* aic_default_fw_path = "/vendor/etc/firmware";
+#endif
+char aic_fw_path[FW_PATH_MAX];
+module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+char saved_sdk_ver[64];
+module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
+#endif
+
+
+int aic_bt_platform_init(struct aic_usb_dev *usbdev)
+{
+    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
+    usbdev->cmd_mgr.usbdev = (void *)usbdev;
+    return 0;
+
+}
+
+void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
+{
+	rwnx_cmd_mgr_deinit(&usbdev->cmd_mgr);
+}
+
+#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
+#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
+
+static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
+{
+
+#ifdef CONFIG_USE_FW_REQUEST
+	const struct firmware *fw = NULL;
+	u32 *dst = NULL;
+	void *buffer=NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+	int size = 0;
+	int ret = 0;
+
+	printk("%s: request firmware = %s \n", __func__ ,name);
+
+
+	ret = request_firmware(&fw, name, NULL);
+	
+	if (ret < 0) {
+		printk("Load %s fail\n", name);
+		release_firmware(fw);
+		return -1;
+	}
+	
+	size = fw->size;
+	dst = (u32 *)fw->data;
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		release_firmware(fw);
+		return -1;
+	}
+
+
+	buffer = vmalloc(size);
+	memset(buffer, 0, size);
+	memcpy(buffer, dst, size);
+	
+	*fw_buf = buffer;
+
+	MD5Init(&md5);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+	printk(MD5PINRT, MD5(decrypt));
+	
+	release_firmware(fw);
+	
+	return size;
+#else
+    void *buffer=NULL;
+    char *path=NULL;
+    struct file *fp=NULL;
+    int size = 0, len=0;//, i=0;
+    ssize_t rdlen=0;
+    //u32 *src=NULL, *dst = NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+#if defined(CONFIG_PLATFORM_UBUNTU)
+    struct aicwf_bus *bus_if = dev_get_drvdata(device);
+    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
+#endif
+
+    /* get the firmware path */
+    path = __getname();
+    if (!path){
+            *fw_buf=NULL;
+            return -1;
+    }
+
+    if (strlen(aic_fw_path) > 0) {
+		printk("%s: use customer define fw_path\n", __func__);
+		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
+    } else {
+    #if defined(CONFIG_PLATFORM_UBUNTU)
+        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
+        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
+        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80X2) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80X2", name);
+        }else {
+            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
+        }
+	#else
+		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
+	#endif
+    }
+
+    if (len >= FW_PATH_MAX) {
+    	printk("%s: %s file's path too long\n", __func__, name);
+        *fw_buf=NULL;
+        __putname(path);
+        return -1;
+    }
+
+    printk("%s :firmware path = %s  \n", __func__ ,path);
+
+
+    /* open the firmware file */
+    fp=filp_open(path, O_RDONLY, 0);
+    if(IS_ERR(fp) || (!fp)){
+            printk("%s: %s file failed to open\n", __func__, name);
+            if(IS_ERR(fp))
+		printk("is_Err\n");
+	if((!fp))
+		printk("null\n");
+	*fw_buf=NULL;
+            __putname(path);
+            fp=NULL;
+            return -1;
+    }
+
+    size = i_size_read(file_inode(fp));
+    if(size<=0){
+            printk("%s: %s file size invalid %d\n", __func__, name, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+}
+
+    /* start to read from firmware file */
+    buffer = vmalloc(size);
+    memset(buffer, 0, size);
+    if(!buffer){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+    }
+
+
+    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
+    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
+    #else
+    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
+    #endif
+
+    if(size != rdlen){
+            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+    if(rdlen > 0){
+            fp->f_pos += rdlen;
+            //printk("f_pos=%d\n", (int)fp->f_pos);
+    }
+
+
+#if 0
+   /*start to transform the data format*/
+    src = (u32*)buffer;
+    //printk("malloc dst\n");
+    dst = (u32*)vmalloc(size);
+    memset(dst, 0, size);
+
+    if(!dst){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+
+    for(i=0;i<(size/4);i++){
+            dst[i] = src[i];
+    }
+#endif
+
+    __putname(path);
+    filp_close(fp,NULL);
+    fp=NULL;
+    //vfree(buffer);
+    //buffer=NULL;
+    //*fw_buf = dst;
+	*fw_buf = (u32 *)buffer;
+
+	MD5Init(&md5);
+	//MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+
+	printk(MD5PINRT, MD5(decrypt));
+
+    return size;
+#endif
+
+}
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+extern int testmode;
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of m2d file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0,j=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret=0;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
+	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
+	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	u32 driver_sdk_ver_addr_idx = 0;
+	u32 code_start_addr = 0xffffffff;
+	u32 sdk_ver_addr = 0xffffffff;
+	u32 drv_code_start_addr = 0xffffffff;
+	u32 drv_sdk_ver_addr = 0xffffffff;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+	char m2d_sdk_ver[64];
+	char flash_sdk_ver[64];
+	u32 flash_ver[16];
+	u32 ota_ver[16];
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	code_start_addr = rd_mem_addr_cfm.memdata;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	sdk_ver_addr = rd_mem_addr_cfm.memdata;
+	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
+
+	/* load aic firmware */
+	size = aic_load_firmware(&dst, filename, dev);
+	if(size<=0){
+			printk("wrong size of m2d file\n");
+			vfree(dst);
+			dst = NULL;
+			return -1;
+	}
+	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
+		printk("########m2d flash old version , must be upgrade\n");
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+	} else {
+		for(i=0;i<16;i++){
+			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
+			if (ret){
+				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+				return ret;
+			}
+			flash_ver[i] = rd_mem_addr_cfm.memdata;
+		}
+		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
+        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
+		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
+				
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
+		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
+
+		if (driver_sdk_ver_addr_idx){
+			for(j = 0; j < 16; j++){
+				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
+			}
+			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
+			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
+		} else {
+			return -1;
+		}
+		
+		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
+			printk("######## m2d %s flash is not need upgrade\r\n", filename);
+			return -1;
+		}
+	}
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
+
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+    const u32 mem_addr = fw_addr;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return ENOENT;
+    }
+
+    printk("size %x, flash_erase_len %x\n", size, flash_erase_len);
+    if (size != flash_erase_len || (flash_erase_len & 0xFFF)) {
+        printk("wrong size of flash_erase_len %d\n", flash_erase_len);
+        vfree(dst);
+        dst = NULL;
+        return -1;
+    }
+
+    err = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (err) {
+        printk("%x rd fail: %d\n", mem_addr, err);
+        return err;
+    }
+
+    if (rd_mem_addr_cfm.memdata != 0xffffffff) {
+        //erase flash
+        if (size > 0x40000) {
+            for (i = 0; i < (size - 0x40000); i +=0x40000) {//each time erase 256K
+                err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr+i, 0xf150e250, 0x40000);
+                if (err) {
+                    printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+                    return err;
+                }
+            }
+        }
+        if (!err && (i < size)) {// <256KB data
+            err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr + i, 0xf150e250, size - i);
+            if (err) {
+                printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+            }
+        }
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+
+uint32_t rwnx_atoli(char *value){
+	int len = 0;
+	int temp_len = 0;
+	int i = 0;
+	uint32_t result = 0;
+	
+	temp_len = strlen(value);
+
+	for(i = 0;i < temp_len; i++){
+		if((value[i] >= 48 && value[i] <= 57) ||
+			(value[i] >= 65 && value[i] <= 70) ||
+			(value[i] >= 97 && value[i] <= 102)){
+			len++;
+		}
+	}
+
+	//printk("%s len:%d \r\n", __func__, len);
+	
+	for(i = 0; i < len; i++){
+		result = result * 16;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else if(value[i] >= 65 && value[i] <= 70){
+			result += (value[i] - 65) + 10;
+		}else if(value[i] >= 97 && value[i] <= 102){
+			result += (value[i] - 97) + 10;
+		}
+	}
+	
+	return result;
+}
+
+int8_t rwnx_atoi(char *value){
+	int len = 0;
+	int i = 0;
+	int8_t result = 0;
+	int8_t signal = 1;
+
+	len = strlen(value);
+	//printk("%s len:%d \r\n", __func__, len);
+
+	for(i = 0;i < len ;i++){
+		if(i == 0 && value[0] == '-'){
+			signal = -1;
+			continue;
+		}
+
+		result = result * 10;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else{
+			result = 0;
+			break;
+		}
+	}
+
+	result = result * signal;
+	//printk("%s result:%d \r\n", __func__, result);
+
+	return result;
+}
+
+void get_fw_path(char* fw_path){
+	if (strlen(aic_fw_path) > 0) {
+		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
+	}else{
+		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
+	}
+} 
+
+void set_testmode(int val){
+	testmode = val;
+}
+
+int get_testmode(void){
+	return testmode;
+}
+
+int get_hardware_info(void){
+	return AIC_HW_INFO;
+}
+
+extern int adap_test;
+int get_adap_test(void){
+    return adap_test;
+}
+
+EXPORT_SYMBOL(get_fw_path);
+
+EXPORT_SYMBOL(get_testmode);
+
+EXPORT_SYMBOL(set_testmode);
+
+EXPORT_SYMBOL(get_hardware_info);
+
+EXPORT_SYMBOL(get_adap_test);
+
+
+void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
+{
+	xtal_cap->enable = userconfig_xtal_cap.enable;
+	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
+	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
+
+    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
+    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
+    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
+}
+
+EXPORT_SYMBOL(get_userconfig_xtal_cap);
+
+void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
+	txpwr_idx->enable = userconfig_txpwr_idx.enable;
+	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
+	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
+	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
+	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
+	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
+	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
+	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
+	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
+	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
+
+	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
+	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
+	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
+	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
+	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
+	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
+	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
+	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
+	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
+	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_idx);
+
+void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
+	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
+	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
+	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
+	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
+	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
+	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
+	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
+	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
+
+	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
+	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
+	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
+	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
+	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
+	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
+	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
+	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
+
+void rwnx_plat_userconfig_set_value(char *command, char *value){	
+	//TODO send command
+	printk("%s:command=%s value=%s \r\n", __func__, command, value);
+	if(!strcmp(command, "enable")){
+		userconfig_txpwr_idx.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "dsss")){
+		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_2g4")){
+		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_2g4")){
+		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_2g4")){
+		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_2g4")){
+		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_5g")){
+		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_5g")){
+		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_5g")){
+		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_5g")){
+		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_enable")){
+		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_1_4")){
+		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_5_9")){
+		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_10_13")){
+		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_36_64")){
+		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_100_120")){
+		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_122_140")){
+		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_142_165")){
+		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_enable")){
+		userconfig_xtal_cap.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap")){
+		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap_fine")){
+		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
+	}
+}
+
+void rwnx_plat_userconfig_parsing(char *buffer, int size){
+    int i = 0;
+	int parse_state = 0;
+	char command[30];
+	char value[100];
+	int char_counter = 0;
+
+	memset(command, 0, 30);
+	memset(value, 0, 100);
+
+    for(i = 0; i < size; i++){
+
+		//Send command or print nvram log when char is \r or \n
+		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+			if(command[0] != 0 && value[0] != 0){
+				if(parse_state == PRINT){
+					printk("%s:%s\r\n", __func__, value);
+				}else if(parse_state == GET_VALUE){
+					rwnx_plat_userconfig_set_value(command, value);
+				}
+			}
+			//Reset command value and char_counter
+			memset(command, 0, 30);
+			memset(value, 0, 100);
+			char_counter = 0;
+			parse_state = INIT;
+			continue;
+		}
+
+		//Switch parser state
+		if(parse_state == INIT){
+			if(buffer[i] == '#'){
+				parse_state = PRINT;
+				continue;
+			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+				parse_state = INIT;
+				continue;
+			}else{
+				parse_state = CMD;
+			}
+		}
+
+		//Fill data to command and value
+		if(parse_state == PRINT){
+			command[0] = 0x01;
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == CMD){
+			if(command[0] != 0 && buffer[i] == '='){
+				parse_state = GET_VALUE;
+				char_counter = 0;
+				continue;
+			}
+			command[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == GET_VALUE){
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}
+	}
+
+
+}
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    int size;
+    u32 *dst=NULL;
+    struct device *dev = usbdev->dev;
+
+	printk("userconfig file path:%s \r\n", filename);
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size <= 0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s userconfig, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing((char *)dst, size);
+
+	if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+	printk("userconfig download complete\n\n");
+	return 0;
+}
+
+
+
+int aicbt_patch_table_free(struct aicbt_patch_table *head)
+{
+	struct aicbt_patch_table *p = head, *n = NULL;
+	while (p) {
+		n = p->next;
+		vfree(p->name);
+		vfree(p->data);
+		vfree(p);
+		p = n;
+	}
+	head = NULL;
+	return 0;
+}
+
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev,const char *filename)
+{
+	struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+	int size;
+	int ret = 0;
+	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+	/* load aic firmware */
+	size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+	printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+
+	return head;
+
+err:
+	aicbt_patch_table_free(head);
+	if (rawdata)
+		vfree(rawdata);
+	return NULL;
+}
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+
+
+static struct aicbt_info_t aicbt_info[] = {
+    {   
+        .btmode        = AICBT_BTMODE_DEFAULT,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+    },//PRODUCT_ID_AIC8800
+    {
+    },//PRODUCT_ID_AIC8801
+    {
+    },//PRODUCT_ID_AIC8800DC
+    {
+    },//PRODUCT_ID_AIC8800DW
+    {
+        .btmode        = AICBT_BTMODE_DEFAULT_8800d80,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80,
+    },//PRODUCT_ID_AIC8800D80
+    {
+    },//PRODUCT_ID_AIC8800D81
+    {
+        .btmode        = AICBT_BTMODE_DEFAULT_8800d80x2,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80x2,
+    },//PRODUCT_ID_AIC8800D80X2
+};
+
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
+{
+	struct aicbt_patch_table *head, *p;
+	int ret = 0, i;
+	uint32_t *data = NULL;
+
+	head = _head;
+
+	for (p = head; p != NULL; p = p->next) {
+		data = p->data;
+		if(AICBT_PT_BTMODE == p->type){
+			*(data + 1)  = aicbsp_info.hwinfo < 0;
+			*(data + 3) = aicbsp_info.hwinfo;
+			*(data + 5)  = aicbsp_info.cpmode;
+
+			*(data + 7) = aicbt_info[usbdev->chipid].btmode;
+			*(data + 9) = aicbt_info[usbdev->chipid].btport;
+			*(data + 11) = aicbt_info[usbdev->chipid].uart_baud;
+			*(data + 13) = aicbt_info[usbdev->chipid].uart_flowctrl;
+			*(data + 15) = aicbt_info[usbdev->chipid].lpm_enable;
+			*(data + 17) = aicbt_info[usbdev->chipid].txpwr_lvl;
+            
+            printk("%s bt btmode[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].btmode);
+    		printk("%s bt uart_baud[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_baud);
+    		printk("%s bt uart_flowctrl[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_flowctrl);
+    		printk("%s bt lpm_enable[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].lpm_enable);
+    		printk("%s bt tx_pwr[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].txpwr_lvl);
+
+		}
+		if (p->type == 0x06) {
+			char *data_s = (char *)p->data;
+			printk("patch version %s\n", data_s);
+			continue;
+		}
+		for (i = 0; i < p->len; i++) {
+			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
+			if (ret != 0)
+				return ret;
+			data += 2;
+		}
+		if (p->type == AICBT_PT_PWRON)
+			udelay(500);
+	}
+	aicbt_patch_table_free(head);
+	return 0;
+}
+
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
+{
+    uint8_t *patch_info_array = (uint8_t*)patch_info;
+    int base_len = 0;
+    int memcpy_len = 0;
+    
+    if (AICBT_PT_INF == head_t->type) {
+        base_len = ((offsetof(struct aicbt_patch_info_t,  ext_patch_nb_addr) - offsetof(struct aicbt_patch_info_t,  adid_addrinf) )/sizeof(uint32_t))/2;
+        AICWFDBG(LOGDEBUG, "%s head_t->len:%d base_len:%d \r\n", __func__, head_t->len, base_len);
+
+        if (head_t->len > base_len){
+            patch_info->info_len = base_len;
+            memcpy_len = patch_info->info_len + 1;//include ext patch nb     
+        } else{
+            patch_info->info_len = head_t->len;
+            memcpy_len = patch_info->info_len;
+        }
+        AICWFDBG(LOGDEBUG, "%s memcpy_len:%d \r\n", __func__, memcpy_len);   
+
+        if (patch_info->info_len == 0)
+            return 0;
+       
+        memcpy(((patch_info_array) + sizeof(patch_info->info_len)), 
+            head_t->data, 
+            memcpy_len * sizeof(uint32_t) * 2);
+        AICWFDBG(LOGDEBUG, "%s adid_addrinf:%x addr_adid:%x \r\n", __func__, 
+            ((struct aicbt_patch_info_t *)patch_info_array)->adid_addrinf,
+            ((struct aicbt_patch_info_t *)patch_info_array)->addr_adid);
+
+        if (patch_info->ext_patch_nb > 0){
+            int index = 0;
+            patch_info->ext_patch_param = (uint32_t *)(head_t->data + ((memcpy_len) * 2));
+            
+            for(index = 0; index < patch_info->ext_patch_nb; index++){
+                AICWFDBG(LOGDEBUG, "%s id:%x addr:%x \r\n", __func__, 
+                    *(patch_info->ext_patch_param + (index * 2)),
+                    *(patch_info->ext_patch_param + (index * 2) + 1));
+            }
+        }
+
+    }
+    return 0;
+
+}
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+   	 int size;
+	int ret = 0;
+   	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+	aicbt_patch_table_load(usbdev, head);
+	printk("fw_patch_table download complete\n\n");
+
+	return ret;
+err:
+	//aicbt_patch_table_free(&head);
+
+	if (rawdata){
+		vfree(rawdata);
+	}
+	return ret;
+}
+
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
index d4af0c72d..5451358d9 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
@@ -1,36 +1,36 @@
-#ifndef _AICBLUETOOTH_H
-#define _AICBLUETOOTH_H
-
-struct aicbt_patch_table {
-	char     *name;
-	uint32_t type;
-	uint32_t *data;
-	uint32_t len;
-	struct aicbt_patch_table *next;
-};
-
-
-int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
-
-void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
-                               char *filename);
-
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
-int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr, char *filename);
-
-int8_t rwnx_atoi(char *value);
-uint32_t rwnx_atoli(char *value);
-int aicbt_patch_table_free(struct aicbt_patch_table *head);
-struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev, const char *filename);
-int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t);
-int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head);
-
-#endif
+#ifndef _AICBLUETOOTH_H
+#define _AICBLUETOOTH_H
+
+struct aicbt_patch_table {
+	char     *name;
+	uint32_t type;
+	uint32_t *data;
+	uint32_t len;
+	struct aicbt_patch_table *next;
+};
+
+
+int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
+
+void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
+                               char *filename);
+
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr, char *filename);
+
+int8_t rwnx_atoi(char *value);
+uint32_t rwnx_atoli(char *value);
+int aicbt_patch_table_free(struct aicbt_patch_table *head);
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev, const char *filename);
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t);
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
index 352258b6a..3b54bf96e 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
@@ -59,6 +59,7 @@ struct lmac_msg
 
 struct aicbt_patch_info_t {
     uint32_t info_len;
+//base len start
     uint32_t adid_addrinf;
     uint32_t addr_adid;
     uint32_t patch_addrinf;
@@ -67,6 +68,12 @@ struct aicbt_patch_info_t {
     uint32_t reset_val;
     uint32_t adid_flag_addr;
     uint32_t adid_flag;
+//base len end
+//ext patch nb
+    uint32_t ext_patch_nb_addr;
+    uint32_t ext_patch_nb;
+    uint32_t *ext_patch_param;
+
 };
 
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
index 85cfb3151..d29edfd41 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
@@ -7,11 +7,15 @@
 #include "aicwf_debug.h"
 
 #ifdef CONFIG_PREALLOC_RX_SKB
+
 struct aicwf_rx_buff_list aic_rx_buff_list;
 
 int aic_rxbuff_num_max = 1000;
-
+#ifdef CONFIG_PLATFORM_HI
 int aic_rxbuff_size = (4 * 512) * 1;
+#else
+int aic_rxbuff_size = (4 * 512) * 10;
+#endif
 
 int rx_buff_list_ava = 0;
 
@@ -32,7 +36,8 @@ struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock)
     if(rx_buff_list_ava < 10){
         AICWFDBG(LOGERROR, "%s WARNING rxbuff is running out %d\r\n", __func__,
             rx_buff_list_ava);
-        msleep(10);
+        //msleep(10);
+        mdelay(10);
     }
 
     if (list_empty(&aic_rx_buff_list.rxbuff_list)) {
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
index c2136fe8a..a952f4deb 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
@@ -25,6 +25,7 @@
 #include "aicbluetooth.h"
 #include "aicwf_debug.h"
 #include "aic_compat_8800d80.h"
+#include "aic_compat_8800d80x2.h"
 
 #define JUMP_TABLE_BASE   0x161928
 #define JUMP_TABLE_OFFSET(i) ((u32)(JUMP_TABLE_BASE+(i)*4))
@@ -37,6 +38,7 @@ extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
 extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
 u8 chip_id = 0;
 u8 chip_sub_id = 0;
+u8 chip_mcu_id = 0;
 int fw_loaded = 0;
 
 void aicwf_usb_tx_flowctrl(struct aic_usb_dev *usb_dev, bool state)
@@ -820,8 +822,10 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 
 #ifdef CONFIG_USB_MSG_EP
 	if ( usb_dev->msg_out_pipe != 0 &&
-        (usb_dev->chipid == PRODUCT_ID_AIC8801 || 
-        usb_dev->chipid == PRODUCT_ID_AIC8800D81)){
+        (usb_dev->chipid == PRODUCT_ID_AIC8801 ||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D81||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D89X2)){
 		printk("TX Msg Bulk EP found\n");
 		usb_dev->use_msg_ep = 1;
 	}else{
@@ -838,12 +842,11 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 #endif
 #endif
 
-
-    if (usb->speed == USB_SPEED_HIGH) {
-        printk("Aic high speed USB device detected\n");
-    } else {
-        printk("Aic full speed USB device detected\n");
-    }
+    printk("Aic %s speed USB device detected\n", 
+            (usb->speed == USB_SPEED_SUPER) ? "super" :
+            (usb->speed == USB_SPEED_HIGH)  ? "high"  :
+            (usb->speed == USB_SPEED_FULL)  ? "full"  :
+            (usb->speed == USB_SPEED_LOW)   ? "low"   : "NG");
     exit:
     return ret;
 }
@@ -979,6 +982,14 @@ u32 patch_tbl[][2] ={
 #if !defined(CONFIG_LINK_DET_5G)
 {0x0104, 0x00000000}, //link_det_5g
 #endif
+#ifdef CONFIG_USB_SUSPEND_REBOOT_TIME
+{0x0110, 0x03e80001}//reboot time when usb suspend,0001 enables reboot on suspend, default 0x3e8 = 1000ms reboot
+#else
+#ifdef CONFIG_SUPPORT_USB_SUSP
+//USB SUSP keep working 0x0100:enable 0x0000:disable
+{0x0110, 0x00000100}
+#endif
+#endif
 };
 
 
@@ -1081,7 +1092,7 @@ static int system_config_8800(struct aic_usb_dev *usb_dev){
         printk("%x rd fail: %d\n", mem_addr, ret);
         return ret;
     }
-    chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
+    chip_id =(u8)(rd_mem_addr_cfm.memdata >> 16);
     //printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
     ret = rwnx_send_dbg_mem_read_req(usb_dev, 0x00000004, &rd_mem_addr_cfm);
     if (ret) {
@@ -1130,6 +1141,8 @@ static int system_config(struct aic_usb_dev *usb_dev)
         return system_config_8800(usb_dev);
     }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80){
         return system_config_8800d80(usb_dev);
+    }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80X2){
+        return system_config_8800d80x2(usb_dev);
     }else{
         return -1;
     }
@@ -1320,20 +1333,40 @@ static int aicloadfw_chipmatch(struct aic_usb_dev *usb_dev, u16 vid, u16 pid){
 
     if(pid == USB_DEVICE_ID_AIC){
         usb_dev->chipid = PRODUCT_ID_AIC8800;
-		AICWFDBG(LOGINFO, "%s USE AIC8800\r\n", __func__);
+	AICWFDBG(LOGINFO, "%s USE AIC8800\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8801){
+	usb_dev->chipid = PRODUCT_ID_AIC8801;
+	AICWFDBG(LOGINFO, "%s USE AIC8801\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D80){
+	usb_dev->chipid = PRODUCT_ID_AIC8800D80;
+	AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D81){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D81;
+	AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+        return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D40){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D80;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D40\r\n", __func__);
+        return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D41){
+	usb_dev->chipid = PRODUCT_ID_AIC8800D81;
+	AICWFDBG(LOGINFO, "%s USE AIC8800D41\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D80X2 && vid == USB_VENDOR_ID_AIC_V2){
+		usb_dev->chipid = PRODUCT_ID_AIC8800D80X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D80X2\r\n", __func__);
 		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8801){
-		usb_dev->chipid = PRODUCT_ID_AIC8801;
-		AICWFDBG(LOGINFO, "%s USE AIC8801\r\n", __func__);
+    }else if(pid == USB_DEVICE_ID_AIC_8800D81X2 && vid == USB_VENDOR_ID_AIC_V2){
+		usb_dev->chipid = PRODUCT_ID_AIC8800D81X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D81X2\r\n", __func__);
 		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8800D80){
-		usb_dev->chipid = PRODUCT_ID_AIC8800D80;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
+    }else if(pid == USB_DEVICE_ID_AIC_8800D89X2 && vid == USB_VENDOR_ID_AIC_V2){
+		usb_dev->chipid = PRODUCT_ID_AIC8800D89X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D89X2\r\n", __func__);
 		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8800D81){
-        usb_dev->chipid = PRODUCT_ID_AIC8800D81;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
-        return 0;
     }else{
         return -1;
     }
@@ -1569,6 +1602,8 @@ int aicfw_download_fw(struct aic_usb_dev *usb_dev)
         return aicfw_download_fw_8800(usb_dev);
     }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80){
         return aicfw_download_fw_8800d80(usb_dev);
+    }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80X2){
+        return aicfw_download_fw_8800d80x2(usb_dev);
     }else{
         return -1;
     }
@@ -1594,7 +1629,10 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 
 	if(fw_loaded == 1 && 
         (id->idProduct == USB_DEVICE_ID_AIC_8801 || 
-        id->idProduct == USB_DEVICE_ID_AIC_8800D81)){
+        id->idProduct == USB_DEVICE_ID_AIC_8800D81 ||
+	    id->idProduct == USB_DEVICE_ID_AIC_8800D41 ||
+	    id->idProduct == USB_DEVICE_ID_AIC_8800D81X2 ||
+	    id->idProduct == USB_DEVICE_ID_AIC_8800D89X2)){
 		return -1;
 	}
 
@@ -1661,15 +1699,17 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 
     aic_bt_platform_init(usb_dev);
 
-    if (usb->speed != USB_SPEED_HIGH) {
-        printk("Aic full speed USB device detected\n");
+    if ((usb->speed != USB_SPEED_HIGH) && (usb->speed != USB_SPEED_SUPER)) {
+        printk("Aic USB device detected speed = %d\n", usb->speed);
         system_reboot(usb_dev);
         goto out_free_bus;
     }
 
 	if(fw_loaded == 0 && 
-        (usb_dev->chipid == PRODUCT_ID_AIC8801 || 
-        usb_dev->chipid == PRODUCT_ID_AIC8800D81)){
+        (usb_dev->chipid == PRODUCT_ID_AIC8801 ||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D81||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        usb_dev->chipid == PRODUCT_ID_AIC8800D89X2)){
 		rwnx_send_reboot(usb_dev);
 		goto out_free_bus;
 	}
@@ -1750,6 +1790,11 @@ static struct usb_device_id aicwf_usb_id_table[] = {
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8801)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D80)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D81)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D40)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D41)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_DEVICE_ID_AIC_8800D80X2)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_DEVICE_ID_AIC_8800D81X2)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_DEVICE_ID_AIC_8800D89X2)},
     {}
 };
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
index 65ff4f07d..e1b3d6354 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
@@ -21,21 +21,27 @@
 
 /* USB Device ID */
 #define USB_VENDOR_ID_AIC               0xA69C
+#define USB_VENDOR_ID_AIC_V2            0x368B
 #define USB_DEVICE_ID_AIC               0x8800
-#define USB_DEVICE_ID_AIC_8801		    0x8801
+#define USB_DEVICE_ID_AIC_8801          0x8801
 
 #define CHIP_REV_U01        0x1
 #define CHIP_REV_U02        0x3
 #define CHIP_REV_U03        0x7
+#define CHIP_REV_U04        0xf
+#define CHIP_REV_U05        0x1f
 #define CHIP_SUB_REV_U04    0x20
 
 enum AICWF_IC{
     PRODUCT_ID_AIC8800 =   0,
-	PRODUCT_ID_AIC8801,
-	PRODUCT_ID_AIC8800DC,
-	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80,
-	PRODUCT_ID_AIC8800D81,
+    PRODUCT_ID_AIC8801,
+    PRODUCT_ID_AIC8800DC,
+    PRODUCT_ID_AIC8800DW,
+    PRODUCT_ID_AIC8800D80,
+    PRODUCT_ID_AIC8800D81,
+    PRODUCT_ID_AIC8800D80X2,
+    PRODUCT_ID_AIC8800D81X2,
+    PRODUCT_ID_AIC8800D89X2,
 };
 
 
@@ -210,6 +216,7 @@ struct aic_usb_dev {
     u16 chipid;
     bool tbusy;
     bool app_cmp;
+    u32 fw_version_uint;
 };
 
 extern void aicwf_usb_exit(void);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
index 5de5fc50e..379017422 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_1212_15dcf017"
+#define RELEASE_DATE "2024_1119_06da8476"
-- 
2.34.1

